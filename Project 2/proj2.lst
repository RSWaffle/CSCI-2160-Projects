Microsoft (R) Macro Assembler Version 6.11		    09/29/19 01:26:57
proj2.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj2.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:          Proj1
				;*  Date:         10/04/2019
				;*  Purpose:      This program accepts an amount of numbers specified by the user, then calculates the sum, calculates
				;*				  The average, calculates the modulo remainder, maximum and minimum value, 
				;*                and displays the numbers in reverse order via a stack.
				;******************************************************************************************
					.486						;This tells assembler to generate 32-bit code
					.model flat					;This tells assembler that all addresses are real addresses
					.stack 100h					;EVERY program needs to have a stack allocated
				;******************************************************************************************
				;  List all necessary prototypes for methods to be called here
					ExitProcess PROTO NEAR32 stdcall, dwExitCode:DWORD  					;Executes "normal" termination
					intasc32 PROTO NEAR32 stdcall, lpStringToHold:dword, dval:dword			;Will convert any D-Word number into ACSII characters
					putstring  PROTO NEAR stdcall, lpStringToDisplay:dword  				;Will display ;characters until the NULL character is found
					getstring 	PROTO stdcall, lpStringToHoldInput:dword, maxNumChars:dword ;Get input from user and convert. 
					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				;This converts ASCII characters to the dword value
					
				;******************************************************************************************
 00000000				.DATA							;declare all data identifiers after this directive
					
 00000000 0A 0A 48 6F 77		strEnterAmtNumbers byte 10,10, "How many values to input: ", 0
	   20 6D 61 6E 79
	   20 76 61 6C 75
	   65 73 20 74 6F
	   20 69 6E 70 75
	   74 3A 20 00
 0000001D 0A 0A 54 79 70		strEnterNumbers byte 10,10, "Type each value and press ENTER after each one: ", 0
	   65 20 65 61 63
	   68 20 76 61 6C
	   75 65 20 61 6E
	   64 20 70 72 65
	   73 73 20 45 4E
	   54 45 52 20 61
	   66 74 65 72 20
	   65 61 63 68 20
	   6F 6E 65 3A 20
	   00
 00000050 4D 61 78 69 6D		strMaxAmount byte "Maximum amount is 10 numbers.", 0
	   75 6D 20 61 6D
	   6F 75 6E 74 20
	   69 73 20 31 30
	   20 6E 75 6D 62
	   65 72 73 2E 00
 0000006E 4D 61 78 69 6D		strMaxNumber byte "Maximum number you can enter is 4,294,967,295.", 0
	   75 6D 20 6E 75
	   6D 62 65 72 20
	   79 6F 75 20 63
	   61 6E 20 65 6E
	   74 65 72 20 69
	   73 20 34 2C 32
	   39 34 2C 39 36
	   37 2C 32 39 35
	   2E 00
 0000009D 54 68 65 20 73		strSum byte "The sum of all the numbers is: ", 0
	   75 6D 20 6F 66
	   20 61 6C 6C 20
	   74 68 65 20 6E
	   75 6D 62 65 72
	   73 20 69 73 3A
	   20 00
 000000BD 0A 0D 09 4E 61		strProjInfo byte  10,13,9,
	   6D 65 3A 20 52
	   79 61 6E 20 53
	   68 75 70 65 0A
	   20 20 20 20 20
	   20 20 43 6C 61
	   73 73 3A 20 43
	   53 43 49 20 32
	   31 36 30 2D 30
	   30 31 0A 20 20
	   20 20 20 20 20
	   20 44 61 74 65
	   3A 20 31 30 2F
	   30 34 2F 32 30
	   31 39 0A 20 20
	   20 20 20 20 20
	   20 20 4C 61 62
	   3A 20 50 72 6F
	   6A 65 63 74 20
	   32 00
				        "Name: Ryan Shupe",10,
				"       Class: CSCI 2160-001",10,
				"        Date: 10/04/2019",10,
				"         Lab: Project 2",0
 0000011E  0000000A [			strSumResult byte 10 dup (?)
	    00
	   ]
 00000128 0A 0D 00		    crlf byte  10,13,0				;Null-terminated string to skip to new line
 0000012B  0000003C [			strInput byte 60 dup (?)		;Set aside 60 bytes of memory for strInput
	    00
	   ]
 00000167 0002				sNumNumbers word 2				;Maximum number of chars that can be typed in the console for specifying how many numbers. 
 00000169 000A				sNum word 10					;Maximum number of chars that can be typed in the console for entering a number.
 0000016B 00000000			iNumOfNums dword ?				;Number of numbers to be input/calculated
 0000016F  0000000A [			iNumbers dword 10 dup (?)		;Set aside 10 dwords in memory to hold future numbers.
	    00000000
	   ]
 00000197 FFFFFFFF			iMaxNumber dword 4294967295		;Maximum number for a dword for reference later
 0000019B 00000000			iTempNum dword ?				;Temporary variable to be used for comparing later
 0000019F 00000000			iResult dword ?					;Temporary variable to store results before displaying
					
					
				;******************************************************************************************
 00000000				.CODE
					
 00000000			_start:
 00000000  B8 00000000			MOV EAX, 0										;Statement to help in debugging
					
 00000005 00000005		main PROC
					
 00000005			getNumofNums:
					INVOKE putstring, ADDR strProjInfo     			;Skip to new line, tab, and display Project information "Name: Ryan Shupe" etc. 
					INVOKE putstring, ADDR crlf						;Display the characters to skip to a new line
					INVOKE putstring, ADDR strEnterAmtNumbers  	    ;Display the "Enter amount of numbers" message
					INVOKE getstring, ADDR strInput, sNumNumbers	;Take the string input and store it into a variable, max amount of chars typed is sNumChars
					INVOKE ascint32, ADDR strInput					;Convert the ASCII value to its true decimal number
 00000040  A3 0000016B R		MOV iNumOfNums, EAX								;Move the result of above method stored in EAX into variable so it isnt lost.
 00000045  8B 0D 0000016B R		MOV ECX, iNumOfNums								;Put the value of iNumOfNums into ECX so we can use it to loop later
 0000004B  BF 00000000			MOV EDI, 0										;Put 0 into EDI so we can start at a 0 offset into iNumbers
						
 00000050  83 3D 0000016B R		CMP iNumOfNums, 0								;Compare iNumOfNums to 0 to see if the user typed null character
	   00
 00000057  0F 84 00000093		JE maxAmountMessage								;If it is null then jump to maxAmountMessage
 0000005D  83 3D 0000016B R		CMP iNumOfNums, 10								;Compare iNumOfNums to 10 to see if the user typed a number greater than 10.
	   0A
 00000064  0F 8F 00000086		JG maxAmountMessage								;If greater than, jump to maxAmountMessage
 0000006A  83 3D 0000016B R		CMP iNumOfNums, 10								;Compare iNumOfNums to 10 to see if it is less than or equal to 10	
	   0A
 00000071  7E 00			JLE getNums										;If so, jump to getNums so we can get the numbers for calculation 

 00000073			getNums:
					
					INVOKE putstring, ADDR strEnterNumbers   		;Display the "Type each value and press ENTER after each one:" message
 0000007D				lpGetNums:
 0000007D  B8 00000000				MOV EAX, 0									;Reset EAX to 0 to prevent errors
						INVOKE putstring, ADDR crlf					;Display the characters to skip to a new line
				 
						INVOKE getstring, ADDR strInput, sNum		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
						INVOKE ascint32, ADDR strInput				;Convert the ASCII value to its true decimal number
 000000A9  A3 0000019B R			MOV iTempNum, EAX							;Move the EAX value into a variable so it isnt lost. 
 000000AE  8B 15 00000197 R			MOV EDX, iMaxNumber							;Moves into EBX the max dword value to compare 
					
 000000B4  83 3D 0000019B R			CMP iTempNum, 0								;Compare EAX to 0 to see if the user typed null character
	   00
 000000BB  74 10				JE invalidNum							    ;If it is null then jump to maxAmountMessage
 000000BD  3B 15 0000019B R			CMP EDX, iTempNum							;Compare EDX to maximum dWord value
 000000C3  7F 08				JG invalidNum								;If it is greater than, jump to invalidNum section
 000000C5  3B 15 0000019B R			CMP EDX, iTempNum							;Compare EDX to maximum dWord value
 000000CB  7E 16				JLE validNum								;If the number complies, jump to the validNum section

 000000CD					invalidNum:
							INVOKE putstring, ADDR crlf				;Display the characters to skip to a new line
							INVOKE putstring, ADDR strMaxNumber		;Display the max possible dword value string
 000000E1  EB 90					JMP getNums								;Jump to the top and repeat until complied
					
 000000E3					validNum:
 000000E3  89 87 0000016F R				MOV iNumbers[EDI], EAX					;Move EBX into iNumbers to be saved for later
 000000E9  83 C7 04					ADD EDI, 4								;Add 4 to EDI to put the number into the correct place in iNumbers
							
 000000EC  E2 8F			loop lpgetNums									;Keep looping this until all of the numbers to be entered are filled.
					
 000000EE  EB 20		JMP sumCalc											;Jump to the calculation section to preform the required calculation
					
 000000F0			maxAmountMessage:
 000000F0  B9 00000064			MOV ECX, 100									;Set ECX to 100 to let the loop know when to terminate and how many lines to skip
 000000F5				lpClearSc:										;Loop to simulate a clear screen
						INVOKE putstring, ADDR crlf					;Display the characters to skip to a new line
 000000FF  E2 F4				loop lpClearSc								;Decrement ECX so the loop knows when to terminate
					INVOKE putstring, ADDR strMaxAmount				;Display a message letting the user know that the maximum amount of numbers to enter is 10
 0000010B  E9 FFFFFEF5			JMP getNumofNums								;Jump back up to the getNumofNums section and it will repeat until the user enters a value less than or equal to 10
					
 00000110			sumCalc:
 00000110  BA 00000000			MOV EDX, 0										;Move 0 into EAX to prevent calculation errors
 00000115  83 EF 04			SUB EDI, 4										;Subtract 4 from EDI so it doesnt point to the end of the iNumbers array
 00000118  8B 0D 0000016B R		MOV ECX, iNumOfNums								;Put the amount of numbers in ECX so the loop runs that amount of times.
 0000011E				lpSum:
 0000011E  8B 87 0000016F R			MOV EAX, iNumbers[EDI]						;Moves the value offset EDI in iNumbers into EAX
 00000124  03 D0				ADD EDX, EAX								;Add the two registers to eventually get the sum in EAX
 00000126  83 EF 04				SUB EDI, 4									;Subtract 4 from EDI so we get the next number in the array
 00000129  E2 F3			loop lpSum										;Decrement ECX to eventually terminate the loop
					
 0000012B  89 15 0000019F R		MOV iResult, EDX								;Moves the result into a variable so it can be set up for display
					INVOKE putstring, ADDR crlf						;Skips to a new line
					INVOKE putstring, ADDR strSum					;display the string "The sum of the values is:"
					INVOKE intasc32, ADDR strSumResult, iResult     ;convert the D-WORD IResult to ASCII characters
					INVOKE putstring, ADDR strSumResult             ;display the numeric string
					
					
				;************************************* the instructions below calls for "normal termination"	
 0000015F			finished:
					INVOKE ExitProcess,0						 
					PUBLIC _start
					
 00000166			main ENDP
					END												;Signals assembler that there are no instructions after this statement
					
Microsoft (R) Macro Assembler Version 6.11		    09/29/19 01:26:57
proj2.asm						     Symbols 2 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000001A3 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000166 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

$$$$$$00001  . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000005 Private
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
getstring  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000005 _TEXT	Length= 00000161 Public
  getNumofNums . . . . . . . . .	L Near	 00000005 _TEXT	
  getNums  . . . . . . . . . . .	L Near	 00000073 _TEXT	
  lpGetNums  . . . . . . . . . .	L Near	 0000007D _TEXT	
  invalidNum . . . . . . . . . .	L Near	 000000CD _TEXT	
  validNum . . . . . . . . . . .	L Near	 000000E3 _TEXT	
  maxAmountMessage . . . . . . .	L Near	 000000F0 _TEXT	
  lpClearSc  . . . . . . . . . .	L Near	 000000F5 _TEXT	
  sumCalc  . . . . . . . . . . .	L Near	 00000110 _TEXT	
  lpSum  . . . . . . . . . . . .	L Near	 0000011E _TEXT	
  finished . . . . . . . . . . .	L Near	 0000015F _TEXT	
putstring  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_start . . . . . . . . . . . . .	L Near	 00000000 _TEXT	Public
crlf . . . . . . . . . . . . . .	Byte	 00000128 _DATA	
iMaxNumber . . . . . . . . . . .	DWord	 00000197 _DATA	
iNumOfNums . . . . . . . . . . .	DWord	 0000016B _DATA	
iNumbers . . . . . . . . . . . .	DWord	 0000016F _DATA	
iResult  . . . . . . . . . . . .	DWord	 0000019F _DATA	
iTempNum . . . . . . . . . . . .	DWord	 0000019B _DATA	
sNumNumbers  . . . . . . . . . .	Word	 00000167 _DATA	
sNum . . . . . . . . . . . . . .	Word	 00000169 _DATA	
strEnterAmtNumbers . . . . . . .	Byte	 00000000 _DATA	
strEnterNumbers  . . . . . . . .	Byte	 0000001D _DATA	
strInput . . . . . . . . . . . .	Byte	 0000012B _DATA	
strMaxAmount . . . . . . . . . .	Byte	 00000050 _DATA	
strMaxNumber . . . . . . . . . .	Byte	 0000006E _DATA	
strProjInfo  . . . . . . . . . .	Byte	 000000BD _DATA	
strSumResult . . . . . . . . . .	Byte	 0000011E _DATA	
strSum . . . . . . . . . . . . .	Byte	 0000009D _DATA	

	   0 Warnings
	   0 Errors
