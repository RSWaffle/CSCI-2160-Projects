Microsoft (R) Macro Assembler Version 6.11		    11/06/19 21:07:10
proj4.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj4.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001 
				;*  Lab:          Proj4
				;*  Date:         11/02/2019
				;*  Purpose:      This is the driver program that handles input and output and calls other classes to 
				;*				  manipulate matrices 
				;******************************************************************************************

					.486						;This tells assembler to generate 32-bit code

					.model flat					;This tells assembler that all addresses are real addresses

					.stack 100h					;EVERY program needs to have a stack allocated
					.listall

				;******************************************************************************************

				;  List all necessary prototypes for methods to be called here

					ExitProcess PROTO NEAR32 stdcall, dwExitCode:DWORD  					;Executes "normal" termination

					intasc32 PROTO NEAR32 stdcall, lpStringToHold:dword, dval:dword			;Will convert any D-Word number into ACSII characters

					putstring  PROTO NEAR stdcall, lpStringToDisplay:dword  				;Will display ;characters until the NULL character is found

					getstring 	PROTO stdcall, lpStringToHoldInput:dword, maxNumChars:dword ;Get input from user and convert. 

					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				;This converts ASCII characters to the dword value
					
					extractDwords PROTO Near32 C, StringofChars:dword, ArrayDwords:dword
					
					displayArray PROTO Near32 C, lpArrayDwords:dword, rows:dword, cols:dword, lpStringtoHold:dword
					
					selectionSort PROTO Near32 C, lpArrayDwords:dword, iLength:dword
					
					sumUpArray PROTO Near32 C, lpArrayDwords:dword, rows:dword, cols:dword
					
					smallestValue PROTO Near32 C, lpArrayDwords:dword, rows:dword, cols:dword

				;******************************************************************************************

				COMMENT %

				******************************************************************************
				*Name: DisplayString                                                         *
				*Purpose:                                                                    *
				*	The purpose of this macro is to display a set of strings to the console  *
				*                                                                            *
				*Date Created: 10/02/2019                                                    *
				*Date Modified: 10/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				DisplayString MACRO String:REQ

					INVOKE putstring, ADDR String    				;;display The string passed in 

				ENDM

				COMMENT %
				******************************************************************************
				*Name: PullString                                                            *
				*Purpose:                                                                    *
				*	The purpose is to get information from the user and store into a variable*
				*                                                                            *
				*Date Created: 10/09/2019                                                    *
				*Date Modified: 10/09/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*@param limit:byte                                                           *
				*****************************************************************************%
				PullString MACRO String:REQ, limit:REQ

						INVOKE getstring, ADDR String, limit		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
						
				ENDM

				COMMENT %
				******************************************************************************
				*Name: CvtoToNum                                                             *
				*Purpose:                                                                    *
				*	converts a string to its real decimal number.                            *
				*                                                                            *
				*Date Created: 10/09/2019                                                    *
				*Date Modified: 10/09/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				CvtoNum MACRO String:REQ

					INVOKE ascint32, ADDR String					;Convert the ASCII value to its true decimal number
					
				ENDM

				COMMENT %

				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  Intakes an address and counts the number of bytes into a string including*
				*     the null char and returns the number.                                  *
				*Date Created: 10/24/2019                                                    *
				*Date Modified: 10/25/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytes MACRO String:REQ
					LOCAL stLoop
					LOCAL done
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM

				;******************************************************************************************
 00000000			.DATA
 00000000 0A 0D 09 4E 61		strProjInfo byte  10,13,9,
	   6D 65 3A 20 52
	   79 61 6E 20 53
	   68 75 70 65 0A
	   20 20 20 20 20
	   20 20 43 6C 61
	   73 73 3A 20 43
	   53 43 49 20 32
	   31 36 30 2D 30
	   30 31 0A 20 20
	   20 20 20 20 20
	   20 44 61 74 65
	   3A 20 31 31 2F
	   30 32 2F 32 30
	   31 39 0A 20 20
	   20 20 20 20 20
	   20 20 4C 61 62
	   3A 20 50 72 6F
	   6A 65 63 74 20
	   34 00
				        "Name: Ryan Shupe",10,
				"       Class: CSCI 2160-001",10,
				"        Date: 11/02/2019",10,
				"         Lab: Project 4",0

 00000061 0A 0A 0A 0D 09		strMenu byte 10,10,10,13,9, "M E N U",10,
	   4D 20 45 20 4E
	   20 55 0A 61 29
	   20 53 65 74 20
	   76 61 6C 75 65
	   73 20 66 6F 72
	   20 6D 61 74 72
	   69 78 20 41 0A
	   62 29 20 53 65
	   74 20 76 61 6C
	   75 65 73 20 66
	   6F 72 20 6D 61
	   74 72 69 78 20
	   42 0A 63 29 20
	   44 69 73 70 6C
	   61 79 20 76 61
	   6C 75 65 73 20
	   69 6E 20 61 72
	   72 61 79 20 41
	   0A 64 29 20 44
	   69 73 70 6C 61
	   79 20 76 61 6C
	   75 65 73 20 69
	   6E 20 61 72 72
	   61 79 20 42 0A
	   65 29 20 41 64
	   64 20 75 70 20
	   74 68 65 20 76
	   61 6C 75 65 73
	   20 69 6E 20 41
	   20 61 72 72 61
	   79 0A 66 29 20
	   41 64 64 20 75
	   70 20 74 68 65
	   20 76 61 6C 75
	   65 73 20 69 6E
	   20 42 20 61 72
	   72 61 79 0A 67
	   29 20 53 6F 72
	   74 20 61 6E 64
	   20 64 69 73 70
	   6C 61 79 20 74
	   68 65 20 76 61
	   6C 75 65 73 20
	   6F 66 20 61 72
	   72 61 79 20 41
	   0A 68 29 20 53
	   6F 72 74 20 61
	   6E 64 20 64 69
	   73 70 6C 61 79
	   20 74 68 65 20
	   76 61 6C 75 65
	   73 20 6F 66 20
	   61 72 72 61 79
	   20 42 00
					"a) Set values for matrix A",10,
					"b) Set values for matrix B",10,
					"c) Display values in array A",10,
					"d) Display values in array B",10,
					"e) Add up the values in A array",10,
					"f) Add up the values in B array",10,
					"g) Sort and display the values of array A",10,
					"h) Sort and display the values of array B",0
					
 00000172 0A 69 29 20 4D		strMenu2 byte 10,
	   75 6C 74 69 70
	   6C 79 20 6D 61
	   74 72 69 78 20
	   41 20 61 6E 64
	   20 42 20 74 6F
	   20 67 65 74 20
	   6D 61 74 72 69
	   78 20 43 0A 6A
	   29 20 44 69 73
	   70 6C 61 79 20
	   76 61 6C 75 65
	   73 20 69 6E 20
	   6D 61 74 72 69
	   78 20 43 0A 6B
	   29 20 41 64 64
	   20 75 70 20 74
	   68 65 20 76 61
	   6C 75 65 73 20
	   69 6E 20 43 20
	   61 72 72 61 79
	   0A 6C 29 20 53
	   6F 72 74 20 61
	   6E 64 20 64 69
	   73 70 6C 61 79
	   20 74 68 65 20
	   76 61 6C 75 65
	   73 20 6F 66 20
	   61 72 72 61 79
	   20 43 0A 6D 29
	   20 53 6D 61 6C
	   6C 65 73 74 20
	   56 61 6C 75 65
	   20 69 6E 20 61
	   72 72 61 79 20
	   41 0A 6E 29 20
	   53 6D 61 6C 6C
	   65 73 74 20 56
	   61 6C 75 65 20
	   69 6E 20 61 72
	   72 61 79 20 42
	   0A 6F 29 20 53
	   6D 61 6C 6C 65
	   73 74 20 76 61
	   6C 75 65 20 69
	   6E 20 61 72 72
	   61 79 20 43 0A
	   70 29 0A 71 29
	   20 45 58 49 54
	   20 70 72 6F 67
	   72 61 6D 0A 0A
	   0D 00
					"i) Multiply matrix A and B to get matrix C",10,
					"j) Display values in matrix C",10,
					"k) Add up the values in C array",10,
					"l) Sort and display the values of array C",10,
					"m) Smallest Value in array A",10,
					"n) Smallest Value in array B",10,
					"o) Smallest value in array C",10,
					"p)",10,
					"q) EXIT program",10,10,13,0
 00000273 0A 0A 0A 0A 0A		clearScr byte 10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,0
	   0A 0A 0A 0A 0A
	   0A 0A 0A 0A 0A
	   0A 00
 00000284 0A 0D 54 79 70		strTypeChoice byte 10,13, "Type the letter of your choice: ",0
	   65 20 74 68 65
	   20 6C 65 74 74
	   65 72 20 6F 66
	   20 79 6F 75 72
	   20 63 68 6F 69
	   63 65 3A 20 00
 000002A7 0A 0A 0D 45 6E		strAskValues byte 10,10,13, "Enter the values you wish to store in the array: ",0
	   74 65 72 20 74
	   68 65 20 76 61
	   6C 75 65 73 20
	   79 6F 75 20 77
	   69 73 68 20 74
	   6F 20 73 74 6F
	   72 65 20 69 6E
	   20 74 68 65 20
	   61 72 72 61 79
	   3A 20 00
 000002DC 0A 0D 56 61 6C		strValuesStored byte 10,13, "Values successfully stored!", 0
	   75 65 73 20 73
	   75 63 63 65 73
	   73 66 75 6C 6C
	   79 20 73 74 6F
	   72 65 64 21 00
 000002FA 0A 0D 45 52 52		strMethodNotAdded byte 10,13, "ERROR! Method not implemented!", 0
	   4F 52 21 20 4D
	   65 74 68 6F 64
	   20 6E 6F 74 20
	   69 6D 70 6C 65
	   6D 65 6E 74 65
	   64 21 00
 0000031B 0A 0A 0D 50 72		enterToCont byte 10,10,13, "Press ENTER to Continue...",0
	   65 73 73 20 45
	   4E 54 45 52 20
	   74 6F 20 43 6F
	   6E 74 69 6E 75
	   65 2E 2E 2E 00
 00000339 0A 0A 0D 45 6E		enterValCol byte 10,10,13, "Enter a value for col: ",0
	   74 65 72 20 61
	   20 76 61 6C 75
	   65 20 66 6F 72
	   20 63 6F 6C 3A
	   20 00
 00000354 0A 0A 0D 45 6E		enterValRow byte 10,10,13, "Enter a value for row: ",0
	   74 65 72 20 61
	   20 76 61 6C 75
	   65 20 66 6F 72
	   20 72 6F 77 3A
	   20 00
 0000036F 0A 0A 0D 54 68		strSum byte 10,10,13, "The sum of the values in the array is: ", 0
	   65 20 73 75 6D
	   20 6F 66 20 74
	   68 65 20 76 61
	   6C 75 65 73 20
	   69 6E 20 74 68
	   65 20 61 72 72
	   61 79 20 69 73
	   3A 20 00
 0000039A 0A 0A 0D 54 68		strSmallestNum byte 10,10,13, "The smallest value in the array is: ", 0
	   65 20 73 6D 61
	   6C 6C 65 73 74
	   20 76 61 6C 75
	   65 20 69 6E 20
	   74 68 65 20 61
	   72 72 61 79 20
	   69 73 3A 20 00
 000003C2 0A 0A 0D 45 6E		strSortLength byte 10,10,13, "Enter the number of elements you want to sort in the array: ",0
	   74 65 72 20 74
	   68 65 20 6E 75
	   6D 62 65 72 20
	   6F 66 20 65 6C
	   65 6D 65 6E 74
	   73 20 79 6F 75
	   20 77 61 6E 74
	   20 74 6F 20 73
	   6F 72 74 20 69
	   6E 20 74 68 65
	   20 61 72 72 61
	   79 3A 20 00
 00000402 0A 0A 0D 45 52		strLocked byte 10,10,13, "ERROR: This method is currently locked!", 0
	   52 4F 52 3A 20
	   54 68 69 73 20
	   6D 65 74 68 6F
	   64 20 69 73 20
	   63 75 72 72 65
	   6E 74 6C 79 20
	   6C 6F 63 6B 65
	   64 21 00
 0000042D 0A 0D 00			crlf byte  10,13,0								;Null-terminated string to skip to new line
 00000430 00				choiceASCII byte 0								;Holds the ascii number choice 
 00000431  000000C8 [			strDisplay dword 200 dup(0)						;memory to hold a display string
	    00000000
	   ]
 00000751  000000C8 [			numbersASCII byte 200 dup (?), 00				;memory to hold the ascii numbers
	    00
	   ] 00
 0000081A  00000064 [			arrayA dword 100 dup (?)						;memory to hold dwords in an array
	    00000000
	   ]
 000009AA  00000064 [			arrayB dword 100 dup (?)						;memory to hold dwords in an array
	    00000000
	   ]
 00000B3A 00				strEnter byte 0									;something to signify that the user pressing nothing but enter
 00000B3B 00000000			tempNum dword 0									;memory to hold a temp number
 00000B3F 00000000			numValues dword 0								;the number of values in array
 00000B43 00000000			rowA dword 0									;number of rows in A
 00000B47 00000000			colA dword 0									;numbers of cols in B
 00000B4B 00000000			rowB dword 0									;numbers of rows in B
 00000B4F 00000000			colB dword 0									;numbers of cols in B
 00000B53 00				matrixAActive byte 0							;byte to signify if A is active
 00000B54 00				matrixBActive byte 0							;byte to signify if B is active


				;******************************************************************************************
 00000000			.CODE

 00000000			_start:
 00000000  B8 00000000			MOV EAX, 0										;Statement to help in debugging
					
 00000005 00000005		main PROC

					DisplayString strProjInfo						;display the string that contains the project information
			     1	
 00000005  68 00000000 R   *	    push   OFFSET strProjInfo
 0000000A  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strProjInfo    				
			     1	
					
 0000000F			getUserChoice:	
					DisplayString strMenu							;display the first part of the menu
			     1	
 0000000F  68 00000061 R   *	    push   OFFSET strMenu
 00000014  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strMenu    				
			     1	
					DisplayString strMenu2							;display the second part of the menu
			     1	
 00000019  68 00000172 R   *	    push   OFFSET strMenu2
 0000001E  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strMenu2    				
			     1	
					DisplayString strTypeChoice						;display the message "enter choice"
			     1	
 00000023  68 00000284 R   *	    push   OFFSET strTypeChoice
 00000028  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strTypeChoice    				
			     1	
					
					PullString choiceASCII, 1						;read in the next line that the user inputs and store the ascii value.
			     1	
 0000002D  6A 01	   *	    push   +000000001h
 0000002F  68 00000430 R   *	    push   OFFSET choiceASCII
 00000034  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR choiceASCII, 1		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					
 00000039  80 3D 00000430 R		CMP choiceASCII, 65								;compare the ascii value to a capital A
	   41
 00000040  0F 84 000001A2		JE choiceA										;if it is equal to the capital value, jump to the choiceA secion of the code.
 00000046  80 3D 00000430 R		CMP choiceASCII, 97								;compare the ascii value to the lowercase a
	   61
 0000004D  0F 84 00000195		JE choiceA										;if it is equal to this number then jump to the choiceA section.
					
 00000053  80 3D 00000430 R		CMP choiceASCII, 66								;compare the ascii value to a capital B
	   42
 0000005A  0F 84 0000021F		JE choiceB										;if it is equal to the capital value, jump to the choiceB secion of the code.
 00000060  80 3D 00000430 R		CMP choiceASCII, 98								;compare the ascii value to the lowercase b
	   62
 00000067  0F 84 00000212		JE choiceB										;if it is equal to this number then jump to the choiceB section.
					
 0000006D  80 3D 00000430 R		CMP choiceASCII, 67								;compare the ascii value to a capital C
	   43
 00000074  0F 84 0000029C		JE choiceC										;if it is equal to this number then jump to the choiceC section.
 0000007A  80 3D 00000430 R		CMP choiceASCII, 99								;compare the ascii value to the lowercase c
	   63
 00000081  0F 84 0000028F		JE choiceC										;if it is equal to this number then jump to the choiceC section.
					
 00000087  80 3D 00000430 R		CMP choiceASCII, 68								;compare the ascii value to a capital D
	   44
 0000008E  0F 84 00000344		JE choiceD										;if it is equal to this number then jump to the choiceD section.
 00000094  80 3D 00000430 R		CMP choiceASCII, 100							;compare the ascii value to the lowercase d
	   64
 0000009B  0F 84 00000337		JE choiceD										;if it is equal to this number then jump to the choiceD section.
					
 000000A1  80 3D 00000430 R		CMP choiceASCII, 69								;compare the ascii value to a capital E
	   45
 000000A8  0F 84 000003EC		JE choiceE										;if it is equal to this number then jump to the choiceE section.
 000000AE  80 3D 00000430 R		CMP choiceASCII, 101							;compare the ascii value to the lowercase e
	   65
 000000B5  0F 84 000003DF		JE choiceE										;if it is equal to this number then jump to the choiceE section.
					
 000000BB  80 3D 00000430 R		CMP choiceASCII, 70								;compare the ascii value to a capital F
	   46
 000000C2  0F 84 00000490		JE choiceF										;if it is equal to this number then jump to the choiceF section.
 000000C8  80 3D 00000430 R		CMP choiceASCII, 102							;compare the ascii value to the lowercase f
	   66
 000000CF  0F 84 00000483		JE choiceF										;if it is equal to this number then jump to the choiceF section.
					
 000000D5  80 3D 00000430 R		CMP choiceASCII, 71								;compare the ascii value to a capital G
	   47
 000000DC  0F 84 00000534		JE choiceG										;if it is equal to this number then jump to the choiceG section.
 000000E2  80 3D 00000430 R		CMP choiceASCII, 103							;compare the ascii value to the lowercase g
	   67
 000000E9  0F 84 00000527		JE choiceG										;if it is equal to this number then jump to the choiceG section.
					
 000000EF  80 3D 00000430 R		CMP choiceASCII, 72								;compare the ascii value to a capital H
	   48
 000000F6  0F 84 00000598		JE choiceH										;if it is equal to this number then jump to the choiceH section.
 000000FC  80 3D 00000430 R		CMP choiceASCII, 104							;compare the ascii value to the lowercase h
	   68
 00000103  0F 84 0000058B		JE choiceH										;if it is equal to this number then jump to the choiceH section.
					
 00000109  80 3D 00000430 R		CMP choiceASCII, 73								;compare the ascii value to a capital I
	   49
 00000110  0F 84 000005FC		JE choiceI										;if it is equal to this number then jump to the choiceI section.
 00000116  80 3D 00000430 R		CMP choiceASCII, 105							;compare the ascii value to the lowercase i
	   69
 0000011D  0F 84 000005EF		JE choiceI										;if it is equal to this number then jump to the choiceI section.
					
 00000123  80 3D 00000430 R		CMP choiceASCII, 74								;compare the ascii value to a capital J
	   4A
 0000012A  0F 84 000005E7		JE choiceJ										;if it is equal to this number then jump to the choiceJ section.
 00000130  80 3D 00000430 R		CMP choiceASCII, 106							;compare the ascii value to the lowercase j
	   6A
 00000137  0F 84 000005DA		JE choiceJ										;if it is equal to this number then jump to the choiceJ section.
					
 0000013D  80 3D 00000430 R		CMP choiceASCII, 75								;compare the ascii value to a capital K
	   4B
 00000144  0F 84 000005D2		JE choiceK										;if it is equal to this number then jump to the choiceK section.
 0000014A  80 3D 00000430 R		CMP choiceASCII, 107							;compare the ascii value to the lowercase k
	   6B
 00000151  0F 84 000005C5		JE choiceK										;if it is equal to this number then jump to the choiceK section.
					
 00000157  80 3D 00000430 R		CMP choiceASCII, 76								;compare the ascii value to a capital L
	   4C
 0000015E  0F 84 000005BD		JE choiceL										;if it is equal to this number then jump to the choiceL section.
 00000164  80 3D 00000430 R		CMP choiceASCII, 108							;compare the ascii value to the lowercase l
	   6C
 0000016B  0F 84 000005B0		JE choiceL										;if it is equal to this number then jump to the choiceL section.
					
 00000171  80 3D 00000430 R		CMP choiceASCII, 77								;compare the ascii value to a capital M
	   4D
 00000178  0F 84 000005A8		JE choiceM										;if it is equal to this number then jump to the choiceM section.
 0000017E  80 3D 00000430 R		CMP choiceASCII, 109							;compare the ascii value to the lowercase m
	   6D
 00000185  0F 84 0000059B		JE choiceM										;if it is equal to this number then jump to the choiceM section.
					
 0000018B  80 3D 00000430 R		CMP choiceASCII, 78								;compare the ascii value to a capital N
	   4E
 00000192  0F 84 0000064C		JE choiceN										;if it is equal to this number then jump to the choiceN section.
 00000198  80 3D 00000430 R		CMP choiceASCII, 110							;compare the ascii value to the lowercase n
	   6E
 0000019F  0F 84 0000063F		JE choiceN										;if it is equal to this number then jump to the choiceN section.
					
 000001A5  80 3D 00000430 R		CMP choiceASCII, 79								;compare the ascii value to a capital O
	   4F
 000001AC  0F 84 000006F0		JE choiceO										;if it is equal to this number then jump to the choiceO section
 000001B2  80 3D 00000430 R		CMP choiceASCII, 111							;compare the ascii value to the lowercase o
	   6F
 000001B9  0F 84 000006E3		JE choiceO										;if it is equal to this number then jump to the choiceO section.
					
 000001BF  80 3D 00000430 R		CMP choiceASCII, 81								;compare the ascii value to a capital Q
	   51
 000001C6  0F 84 000006D8		JE choiceQ										;if it is equal to this number then jump to the choiceQ section.
 000001CC  80 3D 00000430 R		CMP choiceASCII, 113							;compare the ascii value to the lowercase q
	   71
 000001D3  0F 84 000006CB		JE choiceQ										;if it is equal to this number then jump to the choiceQ section.
						
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000001D9  68 00000273 R   *	    push   OFFSET clearScr
 000001DE  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 000001E3  E9 FFFFFE27			JMP getUserChoice								;jump back up to display the menu
					
					
 000001E8			choiceA: ;input a
 000001E8  B9 00000064			MOV ECX, lengthof arrayA						;moves the length of array a into ECX so we can clear that amount to clear the array
 000001ED				lpClearA:
 000001ED  C7 81 0000081A R		MOV arrayA[ECX], 0								;sets the byte at position ecx to 0 (this will exclude the first byte but thats ok because its going to be overwritten)
	   00000000
 000001F7  E2 F4			loop lpClearA									;decrement ECX and go to the top of the loop
					DisplayString strAskValues						;display the string asking which values to store
			     1	
 000001F9  68 000002A7 R   *	    push   OFFSET strAskValues
 000001FE  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strAskValues    				
			     1	
					PullString numbersASCII, 50						;get what the user typed and store into numbersASCII
			     1	
 00000203  6A 32	   *	    push   +000000032h
 00000205  68 00000751 R   *	    push   OFFSET numbersASCII
 0000020A  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR numbersASCII, 50		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					
					INVOKE extractDwords, OFFSET numbersASCII, 		;call the extract dwords function so we have our array properly loaded into mem
					OFFSET arrayA
 0000020F  68 0000081A R   *	    push   dword  ptr OFFSET FLAT:arrayA
 00000214  68 00000751 R   *	    push   dword  ptr OFFSET FLAT:numbersASCII
 00000219  E8 00000000 E   *	    call   extractDwords
 0000021E  83 C4 08	   *	    add    esp, 000000008h
					
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000221  68 00000273 R   *	    push   OFFSET clearScr
 00000226  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 0000022B  68 00000273 R   *	    push   OFFSET clearScr
 00000230  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
					DisplayString strValuesStored					;display a helpful message telling the user that the values have been stored. 
			     1	
 00000235  68 000002DC R   *	    push   OFFSET strValuesStored
 0000023A  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strValuesStored    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 0000023F  68 0000042D R   *	    push   OFFSET crlf
 00000244  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 00000249  68 0000042D R   *	    push   OFFSET crlf
 0000024E  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 00000253  68 0000031B R   *	    push   OFFSET enterToCont
 00000258  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for the user to press enter
			     1	
 0000025D  6A 00	   *	    push   +000000000h
 0000025F  68 00000B3A R   *	    push   OFFSET strEnter
 00000264  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000269  68 00000273 R   *	    push   OFFSET clearScr
 0000026E  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 00000273  C6 05 00000B53 R		MOV matrixAActive, 1 							;set the matrix as active so it unlocks the other methods
	   01
 0000027A  E9 FFFFFD90			JMP getUserChoice								;jump back up to display the menu
 0000027F			choiceB: ;input b
 0000027F  B9 00000064			MOV ECX, lengthof arrayB						;moves the length of array a into ECX so we can clear that amount to clear the array
 00000284				lpClearB:
 00000284  C7 81 000009AA R		MOV arrayB[ECX], 0								;sets the byte at position ecx to 0 (this will exclude the first byte but thats ok because its going to be overwritten)
	   00000000
 0000028E  E2 F4			loop lpClearB									;decrement ECX and go to the top of the loop
					DisplayString strAskValues						;display the string asking which values to store
			     1	
 00000290  68 000002A7 R   *	    push   OFFSET strAskValues
 00000295  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strAskValues    				
			     1	
					PullString numbersASCII, 50						;get what the user typed and store into numbersASCII
			     1	
 0000029A  6A 32	   *	    push   +000000032h
 0000029C  68 00000751 R   *	    push   OFFSET numbersASCII
 000002A1  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR numbersASCII, 50		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
						
					INVOKE extractDwords, OFFSET numbersASCII, 		;call the extract dwords function so we have our array properly loaded into mem
					OFFSET arrayB
 000002A6  68 000009AA R   *	    push   dword  ptr OFFSET FLAT:arrayB
 000002AB  68 00000751 R   *	    push   dword  ptr OFFSET FLAT:numbersASCII
 000002B0  E8 00000000 E   *	    call   extractDwords
 000002B5  83 C4 08	   *	    add    esp, 000000008h
					
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000002B8  68 00000273 R   *	    push   OFFSET clearScr
 000002BD  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000002C2  68 00000273 R   *	    push   OFFSET clearScr
 000002C7  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
					DisplayString strValuesStored					;display a helpful message telling the user that the values have been stored.
			     1	
 000002CC  68 000002DC R   *	    push   OFFSET strValuesStored
 000002D1  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strValuesStored    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 000002D6  68 0000042D R   *	    push   OFFSET crlf
 000002DB  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 000002E0  68 0000042D R   *	    push   OFFSET crlf
 000002E5  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 000002EA  68 0000031B R   *	    push   OFFSET enterToCont
 000002EF  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for the user to press enter
			     1	
 000002F4  6A 00	   *	    push   +000000000h
 000002F6  68 00000B3A R   *	    push   OFFSET strEnter
 000002FB  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000300  68 00000273 R   *	    push   OFFSET clearScr
 00000305  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 0000030A  C6 05 00000B54 R		MOV matrixBActive, 1 							;set the matrix as active so it unlocks the other methods
	   01
 00000311  E9 FFFFFCF9			JMP getUserChoice								;jump back up to display the menu
 00000316			choiceC: ;display a
 00000316  80 3D 00000B53 R		CMP matrixAActive, 1							;checks to see if the matrix is active before executing the method
	   01
 0000031D  0F 85 00000583		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString enterValRow						;Displays the string asking for the number of rows
			     1	
 00000323  68 00000354 R   *	    push   OFFSET enterValRow
 00000328  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValRow    				
			     1	
					PullString rowA, 10								;get the number input and put into variable
			     1	
 0000032D  6A 0A	   *	    push   +00000000Ah
 0000032F  68 00000B43 R   *	    push   OFFSET rowA
 00000334  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR rowA, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum rowA									;convert the ascii value into dec
			     1	
 00000339  68 00000B43 R   *	    push   OFFSET rowA
 0000033E  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR rowA					;Convert the ASCII value to its true decimal number
			     1		
 00000343  A3 00000B43 R		MOV rowA, EAX									;store this in vairiable
					DisplayString enterValCol						;Displays the string asking for the number of cols
			     1	
 00000348  68 00000339 R   *	    push   OFFSET enterValCol
 0000034D  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValCol    				
			     1	
					PullString colA, 10								;get the number input and put into variable
			     1	
 00000352  6A 0A	   *	    push   +00000000Ah
 00000354  68 00000B47 R   *	    push   OFFSET colA
 00000359  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR colA, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum colA									;convert the ascii value into dec
			     1	
 0000035E  68 00000B47 R   *	    push   OFFSET colA
 00000363  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR colA					;Convert the ASCII value to its true decimal number
			     1		
 00000368  A3 00000B47 R		MOV colA, EAX									;store this in vairiable
					
					INVOKE displayArray, OFFSET arrayA, rowA, colA, ;call the display array method so we have the set of characters in the strdisplay address
					OFFSET strDisplay
 0000036D  68 00000431 R   *	    push   dword  ptr OFFSET FLAT:strDisplay
 00000372  FF 35 00000B47 R *	    push   colA
 00000378  FF 35 00000B43 R *	    push   rowA
 0000037E  68 0000081A R   *	    push   dword  ptr OFFSET FLAT:arrayA
 00000383  E8 00000000 E   *	    call   displayArray
 00000388  83 C4 10	   *	    add    esp, 000000010h
					
					DisplayString crlf								;display characters to go to next line.
			     1	
 0000038B  68 0000042D R   *	    push   OFFSET crlf
 00000390  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 00000395  68 0000042D R   *	    push   OFFSET crlf
 0000039A  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 0000039F  68 0000042D R   *	    push   OFFSET crlf
 000003A4  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString strDisplay						;display the characters inside ofo the str display vairiable
			     1	
 000003A9  68 00000431 R   *	    push   OFFSET strDisplay
 000003AE  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strDisplay    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 000003B3  68 0000031B R   *	    push   OFFSET enterToCont
 000003B8  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for the user to press enter
			     1	
 000003BD  6A 00	   *	    push   +000000000h
 000003BF  68 00000B3A R   *	    push   OFFSET strEnter
 000003C4  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000003C9  68 00000273 R   *	    push   OFFSET clearScr
 000003CE  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 000003D3  E9 FFFFFC37			JMP getUserChoice								;jump back up to display the menu
 000003D8			choiceD: ;display b
 000003D8  80 3D 00000B54 R		CMP matrixBActive, 1							;checks to see if the matrix is active before executing the method
	   01
 000003DF  0F 85 000004C1		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString enterValRow						;Displays the string asking for the number of rows
			     1	
 000003E5  68 00000354 R   *	    push   OFFSET enterValRow
 000003EA  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValRow    				
			     1	
					PullString rowB, 10								;get the number input and put into variable
			     1	
 000003EF  6A 0A	   *	    push   +00000000Ah
 000003F1  68 00000B4B R   *	    push   OFFSET rowB
 000003F6  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR rowB, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum rowB									;convert the ascii value into dec
			     1	
 000003FB  68 00000B4B R   *	    push   OFFSET rowB
 00000400  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR rowB					;Convert the ASCII value to its true decimal number
			     1		
 00000405  A3 00000B4B R		MOV rowB, EAX									;store this in vairiable
					DisplayString enterValCol						;Displays the string asking for the number of cols
			     1	
 0000040A  68 00000339 R   *	    push   OFFSET enterValCol
 0000040F  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValCol    				
			     1	
					PullString colB, 10								;get the number input and put into variable
			     1	
 00000414  6A 0A	   *	    push   +00000000Ah
 00000416  68 00000B4F R   *	    push   OFFSET colB
 0000041B  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR colB, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum colB									;convert the ascii value into dec
			     1	
 00000420  68 00000B4F R   *	    push   OFFSET colB
 00000425  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR colB					;Convert the ASCII value to its true decimal number
			     1		
 0000042A  A3 00000B4F R		MOV colB, EAX									;store this in vairiable
					
					INVOKE displayArray, OFFSET arrayB, rowB, colB,	;call the display array method so we have the set of characters in the strdisplay address
					OFFSET strDisplay
 0000042F  68 00000431 R   *	    push   dword  ptr OFFSET FLAT:strDisplay
 00000434  FF 35 00000B4F R *	    push   colB
 0000043A  FF 35 00000B4B R *	    push   rowB
 00000440  68 000009AA R   *	    push   dword  ptr OFFSET FLAT:arrayB
 00000445  E8 00000000 E   *	    call   displayArray
 0000044A  83 C4 10	   *	    add    esp, 000000010h
					DisplayString crlf								;display characters to go to next line.	
			     1	
 0000044D  68 0000042D R   *	    push   OFFSET crlf
 00000452  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 00000457  68 0000042D R   *	    push   OFFSET crlf
 0000045C  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 00000461  68 0000042D R   *	    push   OFFSET crlf
 00000466  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString strDisplay						;display the characters inside ofo the str display vairiable
			     1	
 0000046B  68 00000431 R   *	    push   OFFSET strDisplay
 00000470  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strDisplay    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 00000475  68 0000031B R   *	    push   OFFSET enterToCont
 0000047A  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 0000047F  6A 00	   *	    push   +000000000h
 00000481  68 00000B3A R   *	    push   OFFSET strEnter
 00000486  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 0000048B  68 00000273 R   *	    push   OFFSET clearScr
 00000490  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 00000495  E9 FFFFFB75			JMP getUserChoice								;jump back up to display the menu							
 0000049A			choiceE: ;add up A
 0000049A  80 3D 00000B53 R		CMP matrixAActive, 1							;checks to see if the matrix is active before executing the method
	   01
 000004A1  0F 85 000003FF		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString enterValRow						;Displays the string asking for the number of rows
			     1	
 000004A7  68 00000354 R   *	    push   OFFSET enterValRow
 000004AC  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValRow    				
			     1	
					PullString rowA, 10								;get the number input and put into variable
			     1	
 000004B1  6A 0A	   *	    push   +00000000Ah
 000004B3  68 00000B43 R   *	    push   OFFSET rowA
 000004B8  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR rowA, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum rowA									;convert the ascii value into dec
			     1	
 000004BD  68 00000B43 R   *	    push   OFFSET rowA
 000004C2  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR rowA					;Convert the ASCII value to its true decimal number
			     1		
 000004C7  A3 00000B43 R		MOV rowA, EAX									;store this in vairiable
					DisplayString enterValCol						;Displays the string asking for the number of cols
			     1	
 000004CC  68 00000339 R   *	    push   OFFSET enterValCol
 000004D1  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValCol    				
			     1	
					PullString colA, 10								;get the number input and put into variable
			     1	
 000004D6  6A 0A	   *	    push   +00000000Ah
 000004D8  68 00000B47 R   *	    push   OFFSET colA
 000004DD  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR colA, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum colA									;convert the ascii value into dec
			     1	
 000004E2  68 00000B47 R   *	    push   OFFSET colA
 000004E7  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR colA					;Convert the ASCII value to its true decimal number
			     1		
 000004EC  A3 00000B47 R		MOV colA, EAX									;store this in vairiable
					
					INVOKE sumUpArray, OFFSET arrayA, rowA, colA	;call the sum up array method which returns the value in eax
 000004F1  FF 35 00000B47 R *	    push   colA
 000004F7  FF 35 00000B43 R *	    push   rowA
 000004FD  68 0000081A R   *	    push   dword  ptr OFFSET FLAT:arrayA
 00000502  E8 00000000 E   *	    call   sumUpArray
 00000507  83 C4 0C	   *	    add    esp, 00000000Ch
 0000050A  A3 00000B3B R		MOV tempNum, EAX								;store this into a variable so we dont pass eax as invoke
						
					INVOKE intasc32, addr strDisplay, tempNum		;convert the number into ascii and store into strdisplay
 0000050F  FF 35 00000B3B R *	    push   tempNum
 00000515  68 00000431 R   *	    push   OFFSET strDisplay
 0000051A  E8 00000000 E   *	    call   intasc32

					DisplayString strSum							;display the sum message
			     1	
 0000051F  68 0000036F R   *	    push   OFFSET strSum
 00000524  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strSum    				
			     1	
					DisplayString strDisplay						;display the characters inside ofo the str display vairiable
			     1	
 00000529  68 00000431 R   *	    push   OFFSET strDisplay
 0000052E  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strDisplay    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 00000533  68 0000031B R   *	    push   OFFSET enterToCont
 00000538  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 0000053D  6A 00	   *	    push   +000000000h
 0000053F  68 00000B3A R   *	    push   OFFSET strEnter
 00000544  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000549  68 00000273 R   *	    push   OFFSET clearScr
 0000054E  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 00000553  E9 FFFFFAB7			JMP getUserChoice								;jump back up to display the menu		
 00000558			choiceF: ;Add up B
 00000558  80 3D 00000B54 R		CMP matrixBActive, 1							;checks to see if the matrix is active before executing the method
	   01
 0000055F  0F 85 00000341		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString enterValRow						;Displays the string asking for the number of rows
			     1	
 00000565  68 00000354 R   *	    push   OFFSET enterValRow
 0000056A  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValRow    				
			     1	
					PullString rowB, 10								;get the number input and put into variable
			     1	
 0000056F  6A 0A	   *	    push   +00000000Ah
 00000571  68 00000B4B R   *	    push   OFFSET rowB
 00000576  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR rowB, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum rowB									;convert the ascii value into dec
			     1	
 0000057B  68 00000B4B R   *	    push   OFFSET rowB
 00000580  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR rowB					;Convert the ASCII value to its true decimal number
			     1		
 00000585  A3 00000B4B R		MOV rowB, EAX									;store this in vairiable
					DisplayString enterValCol						;Displays the string asking for the number of cols
			     1	
 0000058A  68 00000339 R   *	    push   OFFSET enterValCol
 0000058F  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValCol    				
			     1	
					PullString colB, 10								;get the number input and put into variable
			     1	
 00000594  6A 0A	   *	    push   +00000000Ah
 00000596  68 00000B4F R   *	    push   OFFSET colB
 0000059B  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR colB, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum colB									;convert the ascii value into dec
			     1	
 000005A0  68 00000B4F R   *	    push   OFFSET colB
 000005A5  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR colB					;Convert the ASCII value to its true decimal number
			     1		
 000005AA  A3 00000B4F R		MOV colB, EAX									;store this in vairiable
					
					INVOKE sumUpArray, OFFSET arrayB, rowB, colB	;call the sum up array method which returns the value in eax
 000005AF  FF 35 00000B4F R *	    push   colB
 000005B5  FF 35 00000B4B R *	    push   rowB
 000005BB  68 000009AA R   *	    push   dword  ptr OFFSET FLAT:arrayB
 000005C0  E8 00000000 E   *	    call   sumUpArray
 000005C5  83 C4 0C	   *	    add    esp, 00000000Ch
 000005C8  A3 00000B3B R		MOV tempNum, EAX								;store this into a variable so we dont pass eax as invoke
						
					INVOKE intasc32, addr strDisplay, tempNum		;convert the number into ascii and store into strdisplay
 000005CD  FF 35 00000B3B R *	    push   tempNum
 000005D3  68 00000431 R   *	    push   OFFSET strDisplay
 000005D8  E8 00000000 E   *	    call   intasc32

					DisplayString strSum							;display the sum message
			     1	
 000005DD  68 0000036F R   *	    push   OFFSET strSum
 000005E2  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strSum    				
			     1	
					DisplayString strDisplay						;display the characters inside ofo the str display vairiable
			     1	
 000005E7  68 00000431 R   *	    push   OFFSET strDisplay
 000005EC  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strDisplay    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 000005F1  68 0000031B R   *	    push   OFFSET enterToCont
 000005F6  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 000005FB  6A 00	   *	    push   +000000000h
 000005FD  68 00000B3A R   *	    push   OFFSET strEnter
 00000602  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000607  68 00000273 R   *	    push   OFFSET clearScr
 0000060C  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 00000611  E9 FFFFF9F9			JMP getUserChoice								;jump back up to display the menu		
 00000616			choiceG: ;sort and display A
 00000616  80 3D 00000B53 R		CMP matrixAActive, 1							;checks to see if the matrix is active before executing the method
	   01
 0000061D  0F 85 00000283		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString strSortLength						;display a string asking how many elements to sort
			     1	
 00000623  68 000003C2 R   *	    push   OFFSET strSortLength
 00000628  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strSortLength    				
			     1	
					PullString numValues, 10						;pull the string the user types in 
			     1	
 0000062D  6A 0A	   *	    push   +00000000Ah
 0000062F  68 00000B3F R   *	    push   OFFSET numValues
 00000634  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR numValues, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum numValues								;convert the ascii number to decimal
			     1	
 00000639  68 00000B3F R   *	    push   OFFSET numValues
 0000063E  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR numValues					;Convert the ASCII value to its true decimal number
			     1		
 00000643  A3 00000B3F R		MOV numValues, EAX								;move eax into a variable so we dont invoke it
					DisplayString crlf								;display characters to go to next line.
			     1	
 00000648  68 0000042D R   *	    push   OFFSET crlf
 0000064D  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 00000652  68 0000042D R   *	    push   OFFSET crlf
 00000657  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					INVOKE selectionSort, OFFSET arrayA, numValues  ;call the selection sort method to sort the array
 0000065C  FF 35 00000B3F R *	    push   numValues
 00000662  68 0000081A R   *	    push   dword  ptr OFFSET FLAT:arrayA
 00000667  E8 00000000 E   *	    call   selectionSort
 0000066C  83 C4 08	   *	    add    esp, 000000008h
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 0000066F  68 0000031B R   *	    push   OFFSET enterToCont
 00000674  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 00000679  6A 00	   *	    push   +000000000h
 0000067B  68 00000B3A R   *	    push   OFFSET strEnter
 00000680  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000685  68 00000273 R   *	    push   OFFSET clearScr
 0000068A  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 0000068F  E9 FFFFF97B			JMP getUserChoice								;jump back up to display the menu		
 00000694			choiceH: ;sort and display B
 00000694  80 3D 00000B54 R		CMP matrixBActive, 1							;checks to see if the matrix is active before executing the method
	   01
 0000069B  0F 85 00000205		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString strSortLength						;display a string asking how many elements to sort
			     1	
 000006A1  68 000003C2 R   *	    push   OFFSET strSortLength
 000006A6  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strSortLength    				
			     1	
					PullString numValues, 10						;pull the string the user types in 
			     1	
 000006AB  6A 0A	   *	    push   +00000000Ah
 000006AD  68 00000B3F R   *	    push   OFFSET numValues
 000006B2  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR numValues, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum numValues								;convert the ascii number to decimal
			     1	
 000006B7  68 00000B3F R   *	    push   OFFSET numValues
 000006BC  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR numValues					;Convert the ASCII value to its true decimal number
			     1		
 000006C1  A3 00000B3F R		MOV numValues, EAX								;move eax into a variable so we dont invoke it
					DisplayString crlf								;display characters to go to next line.
			     1	
 000006C6  68 0000042D R   *	    push   OFFSET crlf
 000006CB  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					DisplayString crlf								;display characters to go to next line.
			     1	
 000006D0  68 0000042D R   *	    push   OFFSET crlf
 000006D5  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR crlf    				
			     1	
					INVOKE selectionSort, OFFSET arrayB, numValues  ;call the selection sort method to sort the array
 000006DA  FF 35 00000B3F R *	    push   numValues
 000006E0  68 000009AA R   *	    push   dword  ptr OFFSET FLAT:arrayB
 000006E5  E8 00000000 E   *	    call   selectionSort
 000006EA  83 C4 08	   *	    add    esp, 000000008h
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 000006ED  68 0000031B R   *	    push   OFFSET enterToCont
 000006F2  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 000006F7  6A 00	   *	    push   +000000000h
 000006F9  68 00000B3A R   *	    push   OFFSET strEnter
 000006FE  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000703  68 00000273 R   *	    push   OFFSET clearScr
 00000708  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 0000070D  E9 FFFFF8FD			JMP getUserChoice								;jump back up to display the menu			
 00000712			choiceI: ;multiply
 00000712  E9 000001A8			JMP notImplemented								;jump to the not implemented section
 00000717			choiceJ: ;display c
 00000717  E9 000001A3			JMP notImplemented								;jump to the not implemented section
 0000071C			choiceK: ;add up c
 0000071C  E9 0000019E			JMP notImplemented								;jump to the not implemented section
 00000721			choiceL: ;sort c
 00000721  E9 00000199			JMP notImplemented								;jump to the not implemented section
 00000726			choiceM: ;smallest a
 00000726  80 3D 00000B53 R		CMP matrixAActive, 1							;checks to see if the matrix is active before executing the method
	   01
 0000072D  0F 85 00000173		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString enterValRow						;Displays the string asking for the number of rows
			     1	
 00000733  68 00000354 R   *	    push   OFFSET enterValRow
 00000738  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValRow    				
			     1	
					PullString rowA, 10								;get the number input and put into variable
			     1	
 0000073D  6A 0A	   *	    push   +00000000Ah
 0000073F  68 00000B43 R   *	    push   OFFSET rowA
 00000744  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR rowA, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum rowA									;convert the ascii value into dec
			     1	
 00000749  68 00000B43 R   *	    push   OFFSET rowA
 0000074E  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR rowA					;Convert the ASCII value to its true decimal number
			     1		
 00000753  A3 00000B43 R		MOV rowA, EAX									;store this in vairiable
					DisplayString enterValCol						;Displays the string asking for the number of cols
			     1	
 00000758  68 00000339 R   *	    push   OFFSET enterValCol
 0000075D  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValCol    				
			     1	
					PullString colA, 10								;get the number input and put into variable
			     1	
 00000762  6A 0A	   *	    push   +00000000Ah
 00000764  68 00000B47 R   *	    push   OFFSET colA
 00000769  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR colA, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum colA									;convert the ascii value into dec
			     1	
 0000076E  68 00000B47 R   *	    push   OFFSET colA
 00000773  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR colA					;Convert the ASCII value to its true decimal number
			     1		
 00000778  A3 00000B47 R		MOV colA, EAX									;store this in vairiable
					
					INVOKE smallestValue, OFFSET arrayA, rowA, colA	;call the sum up array method which returns the value in eax
 0000077D  FF 35 00000B47 R *	    push   colA
 00000783  FF 35 00000B43 R *	    push   rowA
 00000789  68 0000081A R   *	    push   dword  ptr OFFSET FLAT:arrayA
 0000078E  E8 00000000 E   *	    call   smallestValue
 00000793  83 C4 0C	   *	    add    esp, 00000000Ch
 00000796  A3 00000B3B R		MOV tempNum, EAX								;store this into a variable so we dont pass eax as invoke
						
					INVOKE intasc32, addr strDisplay, tempNum		;convert the number into ascii and store into strdisplay
 0000079B  FF 35 00000B3B R *	    push   tempNum
 000007A1  68 00000431 R   *	    push   OFFSET strDisplay
 000007A6  E8 00000000 E   *	    call   intasc32

					DisplayString strSmallestNum					;display the sum message
			     1	
 000007AB  68 0000039A R   *	    push   OFFSET strSmallestNum
 000007B0  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strSmallestNum    				
			     1	
					DisplayString strDisplay						;display the characters inside ofo the str display vairiable
			     1	
 000007B5  68 00000431 R   *	    push   OFFSET strDisplay
 000007BA  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strDisplay    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 000007BF  68 0000031B R   *	    push   OFFSET enterToCont
 000007C4  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 000007C9  6A 00	   *	    push   +000000000h
 000007CB  68 00000B3A R   *	    push   OFFSET strEnter
 000007D0  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000007D5  68 00000273 R   *	    push   OFFSET clearScr
 000007DA  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 000007DF  E9 FFFFF82B			JMP getUserChoice								;jump back up to display the menu	
 000007E4			choiceN: ;smallest b
 000007E4  80 3D 00000B54 R		CMP matrixBActive, 1							;checks to see if the matrix is active before executing the method
	   01
 000007EB  0F 85 000000B5		JNE lockedMethod								;if it is not active, then jump to display it is locked
					DisplayString enterValRow						;Displays the string asking for the number of rows
			     1	
 000007F1  68 00000354 R   *	    push   OFFSET enterValRow
 000007F6  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValRow    				
			     1	
					PullString rowB, 10								;get the number input and put into variable
			     1	
 000007FB  6A 0A	   *	    push   +00000000Ah
 000007FD  68 00000B4B R   *	    push   OFFSET rowB
 00000802  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR rowB, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum rowB									;convert the ascii value into dec
			     1	
 00000807  68 00000B4B R   *	    push   OFFSET rowB
 0000080C  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR rowB					;Convert the ASCII value to its true decimal number
			     1		
 00000811  A3 00000B4B R		MOV rowB, EAX									;store this in vairiable
					DisplayString enterValCol						;Displays the string asking for the number of cols
			     1	
 00000816  68 00000339 R   *	    push   OFFSET enterValCol
 0000081B  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterValCol    				
			     1	
					PullString colB, 10								;get the number input and put into variable
			     1	
 00000820  6A 0A	   *	    push   +00000000Ah
 00000822  68 00000B4F R   *	    push   OFFSET colB
 00000827  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR colB, 10		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					CvtoNum colB									;convert the ascii value into dec
			     1	
 0000082C  68 00000B4F R   *	    push   OFFSET colB
 00000831  E8 00000000 E   *	    call   ascint32
			     1		INVOKE ascint32, ADDR colB					;Convert the ASCII value to its true decimal number
			     1		
 00000836  A3 00000B4F R		MOV colB, EAX									;store this in vairiable
					
					INVOKE smallestValue, OFFSET arrayB, rowB, colB	;call the sum up array method which returns the value in eax
 0000083B  FF 35 00000B4F R *	    push   colB
 00000841  FF 35 00000B4B R *	    push   rowB
 00000847  68 000009AA R   *	    push   dword  ptr OFFSET FLAT:arrayB
 0000084C  E8 00000000 E   *	    call   smallestValue
 00000851  83 C4 0C	   *	    add    esp, 00000000Ch
 00000854  A3 00000B3B R		MOV tempNum, EAX								;store this into a variable so we dont pass eax as invoke
						
					INVOKE intasc32, addr strDisplay, tempNum		;convert the number into ascii and store into strdisplay
 00000859  FF 35 00000B3B R *	    push   tempNum
 0000085F  68 00000431 R   *	    push   OFFSET strDisplay
 00000864  E8 00000000 E   *	    call   intasc32

					DisplayString strSmallestNum					;display the sum message
			     1	
 00000869  68 0000039A R   *	    push   OFFSET strSmallestNum
 0000086E  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strSmallestNum    				
			     1	
					DisplayString strDisplay						;display the characters inside ofo the str display vairiable
			     1	
 00000873  68 00000431 R   *	    push   OFFSET strDisplay
 00000878  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strDisplay    				
			     1	
					DisplayString enterToCont						;display the press enter to continue message
			     1	
 0000087D  68 0000031B R   *	    push   OFFSET enterToCont
 00000882  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR enterToCont    				
			     1	
					PullString strEnter, 0							;wait for user to press enter
			     1	
 00000887  6A 00	   *	    push   +000000000h
 00000889  68 00000B3A R   *	    push   OFFSET strEnter
 0000088E  E8 00000000 E   *	    call   getstring
			     1			INVOKE getstring, ADDR strEnter, 0		;Take the string input and store it into a variable, max amount of chars typed is sNumChars
			     1			
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 00000893  68 00000273 R   *	    push   OFFSET clearScr
 00000898  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
 0000089D  E9 FFFFF76D			JMP getUserChoice								;jump back up to display the menu
 000008A2			choiceO: ;smallest c
 000008A2  EB 1B			JMP notImplemented								;jump to the not implemented section
 000008A4			choiceQ:
 000008A4  EB 32			JMP finished									;Jump to the end of the program, terminate.
					
 000008A6			lockedMethod:
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000008A6  68 00000273 R   *	    push   OFFSET clearScr
 000008AB  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
					DisplayString strLocked							;show a message telling the user that this method is currently locked
			     1	
 000008B0  68 00000402 R   *	    push   OFFSET strLocked
 000008B5  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strLocked    				
			     1	
 000008BA  E9 FFFFF750			JMP getUserChoice								;jump back up to display the menu	
 000008BF			notImplemented:
					DisplayString clearScr							;display the characters to clear the screen
			     1	
 000008BF  68 00000273 R   *	    push   OFFSET clearScr
 000008C4  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR clearScr    				
			     1	
					DisplayString strMethodNotAdded					;show a message telling the user that this method has not been implemented
			     1	
 000008C9  68 000002FA R   *	    push   OFFSET strMethodNotAdded
 000008CE  E8 00000000 E   *	    call   putstring
			     1		INVOKE putstring, ADDR strMethodNotAdded    				
			     1	
 000008D3  E9 FFFFF737			JMP getUserChoice								;jump back up to display the menu

				;************************************* the instructions below calls for "normal termination"	
 000008D8			finished:
					INVOKE ExitProcess,0						 
 000008D8  6A 00	   *	    push   +000000000h
 000008DA  E8 00000000 E   *	    call   ExitProcess
					PUBLIC _start
					
 000008DF			main ENDP

					END												;Signals assembler that there are no instructions after this statement
Microsoft (R) Macro Assembler Version 6.11		    11/06/19 21:07:10
proj4.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

CvtoNum  . . . . . . . . . . . .	Proc
DisplayString  . . . . . . . . .	Proc
PullString . . . . . . . . . . .	Proc
getBytes . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000B55 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000008DF DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

$$$$$$00001  . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000005 Private
ExitProcess  . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
displayArray . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
extractDwords  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
getstring  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
main . . . . . . . . . . . . . .	P Near	 00000005 _TEXT	Length= 000008DA Public
  getUserChoice  . . . . . . . .	L Near	 0000000F _TEXT	
  choiceA  . . . . . . . . . . .	L Near	 000001E8 _TEXT	
  lpClearA . . . . . . . . . . .	L Near	 000001ED _TEXT	
  choiceB  . . . . . . . . . . .	L Near	 0000027F _TEXT	
  lpClearB . . . . . . . . . . .	L Near	 00000284 _TEXT	
  choiceC  . . . . . . . . . . .	L Near	 00000316 _TEXT	
  choiceD  . . . . . . . . . . .	L Near	 000003D8 _TEXT	
  choiceE  . . . . . . . . . . .	L Near	 0000049A _TEXT	
  choiceF  . . . . . . . . . . .	L Near	 00000558 _TEXT	
  choiceG  . . . . . . . . . . .	L Near	 00000616 _TEXT	
  choiceH  . . . . . . . . . . .	L Near	 00000694 _TEXT	
  choiceI  . . . . . . . . . . .	L Near	 00000712 _TEXT	
  choiceJ  . . . . . . . . . . .	L Near	 00000717 _TEXT	
  choiceK  . . . . . . . . . . .	L Near	 0000071C _TEXT	
  choiceL  . . . . . . . . . . .	L Near	 00000721 _TEXT	
  choiceM  . . . . . . . . . . .	L Near	 00000726 _TEXT	
  choiceN  . . . . . . . . . . .	L Near	 000007E4 _TEXT	
  choiceO  . . . . . . . . . . .	L Near	 000008A2 _TEXT	
  choiceQ  . . . . . . . . . . .	L Near	 000008A4 _TEXT	
  lockedMethod . . . . . . . . .	L Near	 000008A6 _TEXT	
  notImplemented . . . . . . . .	L Near	 000008BF _TEXT	
  finished . . . . . . . . . . .	L Near	 000008D8 _TEXT	
putstring  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
selectionSort  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
smallestValue  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C
sumUpArray . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External C


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
_start . . . . . . . . . . . . .	L Near	 00000000 _TEXT	Public
arrayA . . . . . . . . . . . . .	DWord	 0000081A _DATA	
arrayB . . . . . . . . . . . . .	DWord	 000009AA _DATA	
choiceASCII  . . . . . . . . . .	Byte	 00000430 _DATA	
clearScr . . . . . . . . . . . .	Byte	 00000273 _DATA	
colA . . . . . . . . . . . . . .	DWord	 00000B47 _DATA	
colB . . . . . . . . . . . . . .	DWord	 00000B4F _DATA	
crlf . . . . . . . . . . . . . .	Byte	 0000042D _DATA	
enterToCont  . . . . . . . . . .	Byte	 0000031B _DATA	
enterValCol  . . . . . . . . . .	Byte	 00000339 _DATA	
enterValRow  . . . . . . . . . .	Byte	 00000354 _DATA	
matrixAActive  . . . . . . . . .	Byte	 00000B53 _DATA	
matrixBActive  . . . . . . . . .	Byte	 00000B54 _DATA	
numValues  . . . . . . . . . . .	DWord	 00000B3F _DATA	
numbersASCII . . . . . . . . . .	Byte	 00000751 _DATA	
rowA . . . . . . . . . . . . . .	DWord	 00000B43 _DATA	
rowB . . . . . . . . . . . . . .	DWord	 00000B4B _DATA	
strAskValues . . . . . . . . . .	Byte	 000002A7 _DATA	
strDisplay . . . . . . . . . . .	DWord	 00000431 _DATA	
strEnter . . . . . . . . . . . .	Byte	 00000B3A _DATA	
strLocked  . . . . . . . . . . .	Byte	 00000402 _DATA	
strMenu2 . . . . . . . . . . . .	Byte	 00000172 _DATA	
strMenu  . . . . . . . . . . . .	Byte	 00000061 _DATA	
strMethodNotAdded  . . . . . . .	Byte	 000002FA _DATA	
strProjInfo  . . . . . . . . . .	Byte	 00000000 _DATA	
strSmallestNum . . . . . . . . .	Byte	 0000039A _DATA	
strSortLength  . . . . . . . . .	Byte	 000003C2 _DATA	
strSum . . . . . . . . . . . . .	Byte	 0000036F _DATA	
strTypeChoice  . . . . . . . . .	Byte	 00000284 _DATA	
strValuesStored  . . . . . . . .	Byte	 000002DC _DATA	
tempNum  . . . . . . . . . . . .	DWord	 00000B3B _DATA	

	   0 Warnings
	   0 Errors
