Microsoft (R) Macro Assembler Version 6.11		    10/25/19 18:51:32
proj4procs.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj4procs.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:          Proj3
				;*  Date:         11/02/2019
				;*  Purpose:      This handles the manipulation of matrices. 
				;******************************************************************************************

					.486						;This tells assembler to generate 32-bit code

					.model flat					;This tells assembler that all addresses are real addresses

					.stack 100h					;EVERY program needs to have a stack allocated

				;******************************************************************************************

				;  List all necessary prototypes for methods to be called here

					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				;This converts ASCII characters to the dword value
					intasc32Comma proto Near32 stdcall, lpStringToHold:dword, dval:dword
					intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword
				;******************************************************************************************
				COMMENT %

				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  *
				*                                                                            *
				*Date Created: 10/02/2019                                                    *
				*Date Modified: 10/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytes MACRO String:REQ
					LOCAL stLoop
					LOCAL done
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
 00000000			.DATA

 00000000 30 31 32 33 34		WhiteListChars byte 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 43		;set of whitelisted characters, 0 1 2 3 4 5 6 7 8 9 + - 
	   35 36 37 38 39
	   2D 2B
 0000000C				tempNum dword 0 dup (12)
 0000000C 00				bNumBytes byte ?
 0000000D 00000000			iColCount dword 0
 00000011				bTemps byte 0 dup(?)													;memory to hold the number that is built in extractDwords

				;******************************************************************************************
 00000000			.CODE

				COMMENT %
				********************************************************************************
				*Name: extractDwords                                                           *
				*Purpose:                                                                      *
				*	     This method takes in two addresses, one with ascii characters and one *
				*        where the converted numbers will go. It translates the ascii character*
				*		 to the dword value and stores into the output location    			   *
				*Date Created: 10/23/2019                                                      *
				*Date Modified: 10/23/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param StringofChars:dword                                                    *
				*@param ArrayDwords:dword												 	   *
				*******************************************************************************%
 00000000			extractDwords PROC Near32 C uses EBX ECX EDX EDI , StringofChars:dword, ArrayDwords:dword
					LOCAL addOut:dword, addASCII:dword			;sets up our stack frame and declares our local variables. 
					
 0000000A  8B 45 0C			MOV EAX, ArrayDwords						;moves into EAX the address of the output array
 0000000D  89 45 FC			MOV addOut, EAX								;moves the address into our local variable for clarity.
 00000010  8B 45 08			MOV EAX, StringofChars						;moves into EAX the address of the array with ascii values.
 00000013  89 45 F8			MOV addASCII, EAX							;moves the address into our local variable for clarity.
					
 00000016  BB 00000000			MOV EBX, 0									;set EBX to 0 to avoid calculation error
 0000001B  BF 00000000			MOV EDI, 0									;sets our initial point in bTemps to the first place
					
 00000020				lpConvertandMove:	
 00000020  8B 45 F8				MOV EAX, addASCII						;moves the address of the ascii values into eax so we can reference it
 00000023  8A 18				MOV BL, byte ptr [EAX]					;moves into BL the byte at the address position
 00000025  80 FB 00				CMP BL, 00								;compares this byte to 00 to test if we are at the end of the array
 00000028  74 71				JE finished								;if it is equal to 00, then jump to the finished label. 
						
 0000002A  B9 0000000C				MOV ECX, lengthof WhiteListChars		;sets up our loop with the number of elements in the whitelisted characters array
 0000002F  BE 00000000				MOV ESI, 0								;sets our initial position in the whitelisted characters array to 0
						
 00000034					lpCompareWhitelist:
 00000034  3A 9E 00000000 R				CMP BL, WhiteListChars[ESI]			;compares bl to see if it is one of the whitelisted characters
 0000003A  74 08					JE ValidChar						;if it is a valid char, jump to the valid section
 0000003C  46						INC ESI								;increment esi to the next position in the whitelisted characters array
 0000003D  E2 F5				loop lpCompareWhitelist					;decrement ecx and loop back up
																;if it is not a valid char this executes:
 0000003F  FF 45 F8				INC addASCII							;increment addASCII so we get the next byte
 00000042  EB DC				JMP lpConvertandMove					;jump back up to the top to start the loop over again
						
 00000044					ValidChar:
 00000044  88 9F 00000011 R				MOV bTemps[EDI], BL					;Moves into btemps at position edi the byte in bl to hold that byte of the number that is building
 0000004A  FF 45 F8					INC addASCII						;increment to the next position of addascii so we can see if the next char is valid
 0000004D  8B 45 F8					MOV EAX, addASCII					;moves into eax the new address of the next byte 
 00000050  8A 18					MOV BL, byte ptr [EAX]				;moves the byte into Bl 
 00000052  FF 4D F8					DEC addASCII						;change it back to the previous character
							
 00000055  B9 0000000C					MOV ECX, lengthof WhiteListChars	;adds the number of elements in whitelisted characters array into ecx for the loop
 0000005A  BE 00000000					MOV ESI, 0							;sets our initial position in the whitelisted characters array to 0
						
 0000005F						lpCompareNext:
 0000005F  3A 9E 00000000 R					CMP BL, WhiteListChars[ESI]		;This compares the next byte to see if it is whitelisted too
 00000065  74 2E						JE ValidNextChar				;if it is a valid character, jump to the valid next char section
 00000067  46							INC ESI							;increment esi if it is not valid to get to the next position in whitelisted characters
 00000068  E2 F5					loop lpCompareNext					;decrement ECX and go to the top of the current loop
							
							INVOKE ascint32, ADDR bTemps		;if it is not a valid character, then we know the number is complete and we can execute asc to int conversion
 00000074  8B 55 FC					MOV EDX, addOut						;moves the address of the output array into edx so we can reference it
 00000077  89 02					MOV [EDX], EAX						;moves the resulting EAX value into the output array at the correct position
 00000079  B9 00000004					MOV ECX, 4							;imputs 4 into ECX so we can clear our bTemps variable to prevent curruption
 0000007E						lpClearBTemp:
 0000007E  C6 81 00000011 R					MOV [bTemps + ECX], 0			;moves 0 into the slot ECX of bTemps
	   00
 00000085  E2 F7					loop  lpClearBTemp					;jump back to the top of the current loop
 00000087  83 45 FC 04					ADD addOut, 4						;adds 4 to the output address so we can get the next dword starting point
 0000008B  BF 00000000					MOV EDI, 0							;resets edi to 0 so we get a clean bTemps variable
 00000090  FF 45 F8					INC addASCII						;increments addASCII so we get the next byte in memory
 00000093  EB 8B					JMP lpConvertandMove				;jump back up to the very top of the loop 
							
 00000095					ValidNextChar:
 00000095  47						INC EDI								;increment edi so we can input in the next position in bTemps
 00000096  FF 45 F8					INC addASCII						;increment addASCII so we get the next byte in memory
 00000099  EB 85					JMP lpConvertandMove				;jump back up to the very top of the loop
							
							
 0000009B				finished:
						RET										;return back to where i was called 
 000000A1			extractDwords ENDP 

				COMMENT %
				********************************************************************************
				*Name: displayArray                                                            *
				*Purpose:                                                                      *
				*	      *
				*        *
				*		     			   *
				*Date Created: 10/24/2019                                                      *
				*Date Modified: 10/25/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword												 	           *
				*@param cols:dword												 	           *
				*@param lpStringtoHold:dword									 	           *
				*******************************************************************************%
 000000A1			displayArray PROC Near32 C uses EBX EDX EDI, lpArrayDwords:dword, rows:dword, cols:dword, lpStringtoHold:dword
					LOCAL startAddr:dword, outAddr:dword, tempNumRow:dword, tempNumCol:dword
 000000AA  8B 45 0C			MOV EAX, rows	
 000000AD  89 45 F4			MOV tempNumRow, EAX
 000000B0  8B 45 10			MOV EAX, cols
 000000B3  89 45 F0			MOV tempNumCol, EAX	
 000000B6  8B 45 08			MOV EAX, lpArrayDwords						;moves into EAX the address of the output array
 000000B9  89 45 FC			MOV startAddr, EAX							;moves the address into our local variable for clarity.
 000000BC  8B 45 14			MOV EAX, lpStringtoHold						;moves into EAX the address of the array with ascii values.
 000000BF  89 45 F8			MOV outAddr, EAX							;moves the address into our local variable for clarity.

					
 000000C2  BF 00000000			MOV EDI, 0									;set the initial point into the original address to 0
 000000C7  BE 00000000			MOV ESI, 0									;set the initial point into the new address to 0
 000000CC  B9 00000001			MOV ECX, 1									;set ecx to 1 because we start with 1 col
 000000D1  8B 55 F8			MOV EDX, outAddr							;moves the address of out address to edx so we can derefrence the address
 000000D4  8B 5D FC			MOV EBX, startAddr							;moves the address of out address to edx so we can derefrence the address
					
 000000D7  C7 05 0000000C R		MOV tempNum, 09								;set the temp number to the tab character
	   00000009
 000000E1  8B DA			MOV EBX, EDX								;moves the address of out address into ebx so we can use it to put the character
 000000E3  53				PUSH EBX									;store ebx so we can have the unaffected value later
 000000E4  03 DE			ADD EBX, ESI								;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 000000E6  50				PUSH EAX									;preserve EAX so we can restore it later
 000000E7  A1 0000000C R		MOV EAX, tempNum							;move into eax the temp number which is tab
 000000EC  89 03			MOV [EBX], EAX								;moves into the location ebx points to the temp number 
 000000EE  5B				POP EBX										;restore our unaffected EBX
					getBytes EDX								;call the get bytes macro where we count the number of bytes used in the output address
 000000EF  55		     1		PUSH EBP							;preserves base register
 000000F0  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000000F2  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000000F3  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000000F4  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000000F6  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000000FB		     1		??0000:
 000000FB  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000000FF  74 03	     1			JE ??0001							;if it is jump to finished
 00000101  46		     1			INC ESI							;if not increment esi
 00000102  EB F7	     1			JMP ??0000						;jump to the top of the loop and look at the next char
 00000104		     1		??0001:		
 00000104  46		     1			INC ESI							;increment esi to include the null character in the string
 00000105  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000107  5E		     1		POP ESI								;restore original esi
 00000108  5B		     1		POP EBX								;restore original ebx
 00000109  5D		     1		POP EBP								;restore originla ebp
 0000010A  8B F0			MOV ESI, EAX								;moves into ESI the offset that the previous macro returns
 0000010C  4E				DEC ESI										;decrement ESI to take into acount the null character the macro counts for.
					
 0000010D  50				PUSH EAX									;preserve EAX so we can restore it later
 0000010E  8B 45 0C			MOV EAX, rows								;moves into eax the number of rows we have
 00000111  03 45 10			ADD EAX, cols								;adds the number of cols into eax so we can test if we have a 1x1 matrix
 00000114  83 F8 02			CMP EAX, 2									;compares eax to 2 to check if it is a 1x1  (1 + 1 = 2)
 00000117  0F 84 00000165		JE oneByone									;if it detects a 1x1 matrix, then jump to the proper section.
 0000011D  58				POP EAX										;otherwise, restore EAX so we can use the original value.
					
 0000011E				lpConvertToASCII:
 0000011E  83 7D 0C 00				CMP rows, 0								;check to see if we have used up the allowed number of rows
 00000122  0F 84 0000012E			JE finished								;if it is equal to 0, jump to the finished section
 00000128  8B 5D FC				MOV EBX, startAddr						;moves the address of out address to edx so we can derefrence the address
 0000012B  8B 04 1F				MOV EAX, [EBX + EDI]					;moves into eax the address of ebx + edi so we can get the correct number to convert
 0000012E  A3 0000000C R			MOV tempNum, EAX						;stores the number obtained in EAX into tempNum so we can use it in invoke, cant use eax
 00000133  8B DA				MOV EBX, EDX							;moves into ebx, the adress of the outaddress
 00000135  53					PUSH EBX								;stores our ebx variable so we can get it back later
 00000136  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
						INVOKE intasc32, EBX, tempNum			;calls intasc32 to convert the number into ascii characters and place into the address ebx points to
 00000144  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
 00000145  83 C7 04				ADD EDI, 4								;add 4 to edi so we get the next dword in the numbers to pull from.
						
 00000148  50					PUSH EAX								;store our EAX so we can get it back 
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000149  55		     1		PUSH EBP							;preserves base register
 0000014A  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 0000014C  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 0000014D  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000014E  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000150  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000155		     1		??0002:
 00000155  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000159  74 03	     1			JE ??0003							;if it is jump to finished
 0000015B  46		     1			INC ESI							;if not increment esi
 0000015C  EB F7	     1			JMP ??0002						;jump to the top of the loop and look at the next char
 0000015E		     1		??0003:		
 0000015E  46		     1			INC ESI							;increment esi to include the null character in the string
 0000015F  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000161  5E		     1		POP ESI								;restore original esi
 00000162  5B		     1		POP EBX								;restore original ebx
 00000163  5D		     1		POP EBP								;restore originla ebp
 00000164  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 00000166  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 00000167  58					POP EAX									;restore our original eax
						
 00000168  3B 4D 10				CMP ECX, cols							;compare ecx to the number of cols to check if we are at the end of the row
 0000016B  74 72				JE NoComma								;if there is no more numbers to the row, the jump to the no comma section 
						
 0000016D  C7 05 0000000C R			MOV tempNum, 44							;moves the comma ascii value into temp num
	   0000002C
 00000177  8B DA				MOV EBX, EDX							;moves into ebx, the adress of the outaddress
 00000179  53					PUSH EBX								;stores our ebx variable so we can get it back later
 0000017A  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 0000017C  50					PUSH EAX								;store our EAX so we can get it back 
 0000017D  A1 0000000C R			MOV EAX, tempNum						;moves into EAX the value temp num so we can but it into place without calling mem to mem
 00000182  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value of eax, which is temp num
 00000184  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000185  55		     1		PUSH EBP							;preserves base register
 00000186  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000188  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000189  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000018A  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 0000018C  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000191		     1		??0004:
 00000191  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000195  74 03	     1			JE ??0005							;if it is jump to finished
 00000197  46		     1			INC ESI							;if not increment esi
 00000198  EB F7	     1			JMP ??0004						;jump to the top of the loop and look at the next char
 0000019A		     1		??0005:		
 0000019A  46		     1			INC ESI							;increment esi to include the null character in the string
 0000019B  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 0000019D  5E		     1		POP ESI								;restore original esi
 0000019E  5B		     1		POP EBX								;restore original ebx
 0000019F  5D		     1		POP EBP								;restore originla ebp
 000001A0  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 000001A2  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 000001A3  C7 05 0000000C R			MOV tempNum, 32							;moves the space ascii value into temp num
	   00000020
 000001AD  8B DA				MOV EBX, EDX							;moves the address in edx into ebx so we can use it 
 000001AF  53					PUSH EBX								;stores our ebx variable so we can get it back later
 000001B0  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 000001B2  A1 0000000C R			MOV EAX, tempNum						;moves into EAX the value temp num so we can but it into place without calling mem to mem
 000001B7  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value of eax, which is temp num
 000001B9  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 000001BA  55		     1		PUSH EBP							;preserves base register
 000001BB  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001BD  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000001BE  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000001BF  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000001C1  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000001C6		     1		??0006:
 000001C6  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000001CA  74 03	     1			JE ??0007							;if it is jump to finished
 000001CC  46		     1			INC ESI							;if not increment esi
 000001CD  EB F7	     1			JMP ??0006						;jump to the top of the loop and look at the next char
 000001CF		     1		??0007:		
 000001CF  46		     1			INC ESI							;increment esi to include the null character in the string
 000001D0  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 000001D2  5E		     1		POP ESI								;restore original esi
 000001D3  5B		     1		POP EBX								;restore original ebx
 000001D4  5D		     1		POP EBP								;restore originla ebp
 000001D5  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 000001D7  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 000001D8  58					POP EAX									;restore our original eax
						
 000001D9  41					INC ECX									;increments we we know we are on the next col
 000001DA  E9 FFFFFF3F				JMP lpConvertToASCII					;jumps back to the top
						
 000001DF				NoComma:
 000001DF  B9 00000001				MOV ECX, 1								;reset the col value back to 1
 000001E4  FF 4D 0C				DEC rows								;decrement the number of rows so we can terminate this loop eventually
 000001E7  C7 05 0000000C R			MOV tempNum, 10							;moves the new line character into tempNum
	   0000000A
 000001F1  53					PUSH EBX								;pushes ebx to the stack so we can have the unaffected value later
 000001F2  03 DE				ADD EBX, ESI							;add the offset esi into ebx so we point to the right byte to place
 000001F4  50					PUSH EAX								;push eax to store it
 000001F5  A1 0000000C R			MOV EAX, tempNum						;moves the new line char into eax (avoid mem to mem)
 000001FA  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value eax which is new line
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 000001FC  55		     1		PUSH EBP							;preserves base register
 000001FD  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001FF  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000200  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000201  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000203  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000208		     1		??0008:
 00000208  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 0000020C  74 03	     1			JE ??0009							;if it is jump to finished
 0000020E  46		     1			INC ESI							;if not increment esi
 0000020F  EB F7	     1			JMP ??0008						;jump to the top of the loop and look at the next char
 00000211		     1		??0009:		
 00000211  46		     1			INC ESI							;increment esi to include the null character in the string
 00000212  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000214  5E		     1		POP ESI								;restore original esi
 00000215  5B		     1		POP EBX								;restore original ebx
 00000216  5D		     1		POP EBP								;restore originla ebp
 00000217  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 00000219  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 0000021A  58					POP EAX									;restore original eax
 0000021B  5B					POP EBX									;restore original ebx
 0000021C  C7 05 0000000C R			MOV tempNum, 09							;moves the tab character into tempNum
	   00000009
 00000226  53					PUSH EBX								;pushes ebx to the stack so we can have the unaffected value later
 00000227  03 DE				ADD EBX, ESI							;add the offset esi into ebx so we point to the right byte to place
 00000229  50					PUSH EAX								;push eax to store it
 0000022A  A1 0000000C R			MOV EAX, tempNum						;moves the new line char into eax (avoid mem to mem)
 0000022F  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value eax which is new line
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000231  55		     1		PUSH EBP							;preserves base register
 00000232  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000234  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000235  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000236  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000238  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 0000023D		     1		??000A:
 0000023D  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000241  74 03	     1			JE ??000B							;if it is jump to finished
 00000243  46		     1			INC ESI							;if not increment esi
 00000244  EB F7	     1			JMP ??000A						;jump to the top of the loop and look at the next char
 00000246		     1		??000B:		
 00000246  46		     1			INC ESI							;increment esi to include the null character in the string
 00000247  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000249  5E		     1		POP ESI								;restore original esi
 0000024A  5B		     1		POP EBX								;restore original ebx
 0000024B  5D		     1		POP EBP								;restore originla ebp
 0000024C  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 0000024E  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 0000024F  58					POP EAX									;restore original eax
 00000250  5B					POP EBX									;restore original ebx
 00000251  E9 FFFFFEC8				JMP lpConvertToASCII					;jump back to the top of the loop
						
 00000256				finished:
 00000256  83 7D F4 01				CMP tempNumRow, 1
 0000025A  74 21				JE FixRowCol
 0000025C  83 7D F0 01				CMP tempNumCol, 1
 00000260  74 1B				JE FixRowCol
					
 00000262  C7 05 0000000C R			MOV tempNum, 00							;moves the null character into tempNum
	   00000000
 0000026C  03 DE				ADD EBX, ESI							;adds the offset esi into ebx so we point to the right byte
 0000026E  83 EB 05				SUB EBX, 5								;subtracts 5 to point to the very end of the string....
 00000271  A1 0000000C R			MOV EAX, tempNum						;moves the value of temp num into eax
 00000276  89 03				MOV [EBX], EAX							;moves into the location ebx is pointing to the value of eax
						RET										;return back to where i was called
						
 0000027D					FixRowCol:
							RET
						
 00000282				oneByone:
 00000282  8B 5D FC				MOV EBX, startAddr						;moves the starting address into ebx
 00000285  8B 03				MOV EAX, [EBX]							;moves the value ebx points to into eax
 00000287  A3 0000000C R			MOV tempNum, EAX						;moves eax into the temp num variable
 0000028C  8B DA				MOV EBX, EDX							;moves the eaddress of edx into ebx so we can modify it
 0000028E  53					PUSH EBX								;pushes ebx to store it
 0000028F  03 DE				ADD EBX, ESI							;adds the offset esi into ebx so we point to the right place
						INVOKE intasc32, EBX, tempNum			;convert the number into the ascii format and put into where ebx points
 0000029D  5B					POP EBX									;restore ebx
 0000029E  EB B6				JMP finished

 000002A0			displayArray ENDP
				END
Microsoft (R) Macro Assembler Version 6.11		    10/25/19 18:51:32
proj4procs.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

getBytes . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000011 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000002A0 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
displayArray . . . . . . . . . .	P Near	 000000A1 _TEXT	Length= 000001FF Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  lpStringtoHold . . . . . . . .	DWord	 bp + 00000014
  startAddr  . . . . . . . . . .	DWord	 bp - 00000004
  outAddr  . . . . . . . . . . .	DWord	 bp - 00000008
  tempNumRow . . . . . . . . . .	DWord	 bp - 0000000C
  tempNumCol . . . . . . . . . .	DWord	 bp - 00000010
  ??0000 . . . . . . . . . . . .	L Near	 000000FB _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 00000104 _TEXT	
  lpConvertToASCII . . . . . . .	L Near	 0000011E _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000155 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 0000015E _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 00000191 _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 0000019A _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 000001C6 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 000001CF _TEXT	
  NoComma  . . . . . . . . . . .	L Near	 000001DF _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 00000208 _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 00000211 _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 0000023D _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 00000246 _TEXT	
  finished . . . . . . . . . . .	L Near	 00000256 _TEXT	
  FixRowCol  . . . . . . . . . .	L Near	 0000027D _TEXT	
  oneByone . . . . . . . . . . .	L Near	 00000282 _TEXT	
extractDwords  . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000A1 Public C
  StringofChars  . . . . . . . .	DWord	 bp + 00000008
  ArrayDwords  . . . . . . . . .	DWord	 bp + 0000000C
  addOut . . . . . . . . . . . .	DWord	 bp - 00000004
  addASCII . . . . . . . . . . .	DWord	 bp - 00000008
  lpConvertandMove . . . . . . .	L Near	 00000020 _TEXT	
  lpCompareWhitelist . . . . . .	L Near	 00000034 _TEXT	
  ValidChar  . . . . . . . . . .	L Near	 00000044 _TEXT	
  lpCompareNext  . . . . . . . .	L Near	 0000005F _TEXT	
  lpClearBTemp . . . . . . . . .	L Near	 0000007E _TEXT	
  ValidNextChar  . . . . . . . .	L Near	 00000095 _TEXT	
  finished . . . . . . . . . . .	L Near	 0000009B _TEXT	
intasc32Comma  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
WhiteListChars . . . . . . . . .	Byte	 00000000 _DATA	
bNumBytes  . . . . . . . . . . .	Byte	 0000000C _DATA	
bTemps . . . . . . . . . . . . .	Byte	 00000011 _DATA	
iColCount  . . . . . . . . . . .	DWord	 0000000D _DATA	
tempNum  . . . . . . . . . . . .	DWord	 0000000C _DATA	

	   0 Warnings
	   0 Errors
