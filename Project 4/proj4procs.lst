Microsoft (R) Macro Assembler Version 6.11		    10/25/19 00:45:22
proj4procs.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj4procs.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:          Proj3
				;*  Date:         11/02/2019
				;*  Purpose:      This handles the manipulation of matrices. 
				;******************************************************************************************

					.486						;This tells assembler to generate 32-bit code

					.model flat					;This tells assembler that all addresses are real addresses

					.stack 100h					;EVERY program needs to have a stack allocated

				;******************************************************************************************

				;  List all necessary prototypes for methods to be called here

					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				;This converts ASCII characters to the dword value
					intasc32Comma proto Near32 stdcall, lpStringToHold:dword, dval:dword
					intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword
				;******************************************************************************************
				COMMENT %

				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  *
				*                                                                            *
				*Date Created: 10/02/2019                                                    *
				*Date Modified: 10/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytes MACRO String:REQ
					LOCAL stLoop
					LOCAL done
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
 00000000			.DATA

 00000000 30 31 32 33 34		WhiteListChars byte 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 43		;set of whitelisted characters, 0 1 2 3 4 5 6 7 8 9 + - 
	   35 36 37 38 39
	   2D 2B
 0000000C				tempNum dword 0 dup (12)
 0000000C 00				bNumBytes byte ?
 0000000D 00000000			iColCount dword 0
 00000011				bTemps byte 0 dup(?)													;memory to hold the number that is built in extractDwords

				;******************************************************************************************
 00000000			.CODE

				COMMENT %
				********************************************************************************
				*Name: extractDwords                                                           *
				*Purpose:                                                                      *
				*	     This method takes in two addresses, one with ascii characters and one *
				*        where the converted numbers will go. It translates the ascii character*
				*		 to the dword value and stores into the output location    			   *
				*Date Created: 10/23/2019                                                      *
				*Date Modified: 10/23/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param StringofChars:dword                                                    *
				*@param ArrayDwords:dword												 	   *
				*******************************************************************************%
 00000000			extractDwords PROC Near32 C uses EBX ECX EDX EDI , StringofChars:dword, ArrayDwords:dword
					LOCAL addOut:dword, addASCII:dword			;sets up our stack frame and declares our local variables. 
					
 0000000A  8B 45 0C			MOV EAX, ArrayDwords						;moves into EAX the address of the output array
 0000000D  89 45 FC			MOV addOut, EAX								;moves the address into our local variable for clarity.
 00000010  8B 45 08			MOV EAX, StringofChars						;moves into EAX the address of the array with ascii values.
 00000013  89 45 F8			MOV addASCII, EAX							;moves the address into our local variable for clarity.
					
 00000016  BB 00000000			MOV EBX, 0									;set EBX to 0 to avoid calculation error
 0000001B  BF 00000000			MOV EDI, 0									;sets our initial point in bTemps to the first place
					
 00000020				lpConvertandMove:	
 00000020  8B 45 F8				MOV EAX, addASCII						;moves the address of the ascii values into eax so we can reference it
 00000023  8A 18				MOV BL, byte ptr [EAX]					;moves into BL the byte at the address position
 00000025  80 FB 00				CMP BL, 00								;compares this byte to 00 to test if we are at the end of the array
 00000028  74 71				JE finished								;if it is equal to 00, then jump to the finished label. 
						
 0000002A  B9 0000000C				MOV ECX, lengthof WhiteListChars		;sets up our loop with the number of elements in the whitelisted characters array
 0000002F  BE 00000000				MOV ESI, 0								;sets our initial position in the whitelisted characters array to 0
						
 00000034					lpCompareWhitelist:
 00000034  3A 9E 00000000 R				CMP BL, WhiteListChars[ESI]			;compares bl to see if it is one of the whitelisted characters
 0000003A  74 08					JE ValidChar						;if it is a valid char, jump to the valid section
 0000003C  46						INC ESI								;increment esi to the next position in the whitelisted characters array
 0000003D  E2 F5				loop lpCompareWhitelist					;decrement ecx and loop back up
																;if it is not a valid char this executes:
 0000003F  FF 45 F8				INC addASCII							;increment addASCII so we get the next byte
 00000042  EB DC				JMP lpConvertandMove					;jump back up to the top to start the loop over again
						
 00000044					ValidChar:
 00000044  88 9F 00000011 R				MOV bTemps[EDI], BL					;Moves into btemps at position edi the byte in bl to hold that byte of the number that is building
 0000004A  FF 45 F8					INC addASCII						;increment to the next position of addascii so we can see if the next char is valid
 0000004D  8B 45 F8					MOV EAX, addASCII					;moves into eax the new address of the next byte 
 00000050  8A 18					MOV BL, byte ptr [EAX]				;moves the byte into Bl 
 00000052  FF 4D F8					DEC addASCII						;change it back to the previous character
							
 00000055  B9 0000000C					MOV ECX, lengthof WhiteListChars	;adds the number of elements in whitelisted characters array into ecx for the loop
 0000005A  BE 00000000					MOV ESI, 0							;sets our initial position in the whitelisted characters array to 0
						
 0000005F						lpCompareNext:
 0000005F  3A 9E 00000000 R					CMP BL, WhiteListChars[ESI]		;This compares the next byte to see if it is whitelisted too
 00000065  74 2E						JE ValidNextChar				;if it is a valid character, jump to the valid next char section
 00000067  46							INC ESI							;increment esi if it is not valid to get to the next position in whitelisted characters
 00000068  E2 F5					loop lpCompareNext					;decrement ECX and go to the top of the current loop
							
							INVOKE ascint32, ADDR bTemps		;if it is not a valid character, then we know the number is complete and we can execute asc to int conversion
 00000074  8B 55 FC					MOV EDX, addOut						;moves the address of the output array into edx so we can reference it
 00000077  89 02					MOV [EDX], EAX						;moves the resulting EAX value into the output array at the correct position
 00000079  B9 00000004					MOV ECX, 4							;imputs 4 into ECX so we can clear our bTemps variable to prevent curruption
 0000007E						lpClearBTemp:
 0000007E  C6 81 00000011 R					MOV [bTemps + ECX], 0			;moves 0 into the slot ECX of bTemps
	   00
 00000085  E2 F7					loop  lpClearBTemp					;jump back to the top of the current loop
 00000087  83 45 FC 04					ADD addOut, 4						;adds 4 to the output address so we can get the next dword starting point
 0000008B  BF 00000000					MOV EDI, 0							;resets edi to 0 so we get a clean bTemps variable
 00000090  FF 45 F8					INC addASCII						;increments addASCII so we get the next byte in memory
 00000093  EB 8B					JMP lpConvertandMove				;jump back up to the very top of the loop 
							
 00000095					ValidNextChar:
 00000095  47						INC EDI								;increment edi so we can input in the next position in bTemps
 00000096  FF 45 F8					INC addASCII						;increment addASCII so we get the next byte in memory
 00000099  EB 85					JMP lpConvertandMove				;jump back up to the very top of the loop
							
							
 0000009B				finished:
						RET										;return back to where i was called 
 000000A1			extractDwords ENDP 

				COMMENT %
				********************************************************************************
				*Name: displayArray                                                            *
				*Purpose:                                                                      *
				*	      *
				*        *
				*		     			   *
				*Date Created: 10/24/2019                                                      *
				*Date Modified: 10/24/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword												 	           *
				*@param cols:dword												 	           *
				*@param lpStringtoHold:dword									 	           *
				*******************************************************************************%
 000000A1			displayArray PROC Near32 C uses EBX EDX EDI, lpArrayDwords:dword, rows:dword, cols:dword, lpStringtoHold:dword
					LOCAL startAddr:dword, outAddr:dword
						
 000000AA  8B 45 08			MOV EAX, lpArrayDwords						;moves into EAX the address of the output array
 000000AD  89 45 FC			MOV startAddr, EAX							;moves the address into our local variable for clarity.
 000000B0  8B 45 14			MOV EAX, lpStringtoHold						;moves into EAX the address of the array with ascii values.
 000000B3  89 45 F8			MOV outAddr, EAX							;moves the address into our local variable for clarity.
					
 000000B6  BF 00000000			MOV EDI, 0
 000000BB  BE 00000000			MOV ESI, 0
 000000C0  B9 00000001			MOV ECX, 1
 000000C5  8B 55 F8			MOV EDX, outAddr
 000000C8  8B 5D FC			MOV EBX, startAddr
					
 000000CB  C7 05 0000000C R		MOV tempNum, 09
	   00000009
 000000D5  8B DA			MOV EBX, EDX
 000000D7  53				PUSH EBX
 000000D8  03 DE			ADD EBX, ESI
 000000DA  50				PUSH EAX
 000000DB  A1 0000000C R		MOV EAX, tempNum
 000000E0  89 03			MOV [EBX], EAX
 000000E2  5B				POP EBX
					getBytes EDX
 000000E3  55		     1		PUSH EBP							;preserves base register
 000000E4  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000000E6  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000000E7  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000000E8  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000000EA  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000000EF		     1		??0000:
 000000EF  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000000F3  74 03	     1			JE ??0001							;if it is jump to finished
 000000F5  46		     1			INC ESI							;if not increment esi
 000000F6  EB F7	     1			JMP ??0000						;jump to the top of the loop and look at the next char
 000000F8		     1		??0001:		
 000000F8  46		     1			INC ESI							;increment esi to include the null character in the string
 000000F9  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 000000FB  5E		     1		POP ESI								;restore original esi
 000000FC  5B		     1		POP EBX								;restore original ebx
 000000FD  5D		     1		POP EBP								;restore originla ebp
 000000FE  8B F0			MOV ESI, EAX
 00000100  4E				DEC ESI
					
 00000101  83 FE 01			CMP ESI, 1
 00000104  0F 84 0000015B		JE oneByone
					
 0000010A				lpConvertToASCII:
 0000010A  83 7D 0C 00				CMP rows, 0
 0000010E  0F 84 0000012E			JE finished
 00000114  8B 5D FC				MOV EBX, startAddr
 00000117  8B 04 1F				MOV EAX, [EBX + EDI]
 0000011A  A3 0000000C R			MOV tempNum, EAX
 0000011F  8B DA				MOV EBX, EDX
 00000121  53					PUSH EBX
 00000122  03 DE				ADD EBX, ESI
						INVOKE intasc32, EBX, tempNum	
 00000130  5B					POP EBX
 00000131  83 C7 04				ADD EDI, 4
						
 00000134  50					PUSH EAX
						getBytes EDX
 00000135  55		     1		PUSH EBP							;preserves base register
 00000136  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000138  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000139  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000013A  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 0000013C  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000141		     1		??0002:
 00000141  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000145  74 03	     1			JE ??0003							;if it is jump to finished
 00000147  46		     1			INC ESI							;if not increment esi
 00000148  EB F7	     1			JMP ??0002						;jump to the top of the loop and look at the next char
 0000014A		     1		??0003:		
 0000014A  46		     1			INC ESI							;increment esi to include the null character in the string
 0000014B  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 0000014D  5E		     1		POP ESI								;restore original esi
 0000014E  5B		     1		POP EBX								;restore original ebx
 0000014F  5D		     1		POP EBP								;restore originla ebp
 00000150  8B F0				MOV ESI, EAX
 00000152  4E					DEC ESI
 00000153  58					POP EAX
						
 00000154  3B 4D 10				CMP ECX, cols
 00000157  74 72				JE NoComma
						
 00000159  C7 05 0000000C R			MOV tempNum, 44
	   0000002C
 00000163  8B DA				MOV EBX, EDX
 00000165  53					PUSH EBX
 00000166  03 DE				ADD EBX, ESI
 00000168  50					PUSH EAX
 00000169  A1 0000000C R			MOV EAX, tempNum
 0000016E  89 03				MOV [EBX], EAX
 00000170  5B					POP EBX
						getBytes EDX
 00000171  55		     1		PUSH EBP							;preserves base register
 00000172  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000174  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000175  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000176  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000178  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 0000017D		     1		??0004:
 0000017D  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000181  74 03	     1			JE ??0005							;if it is jump to finished
 00000183  46		     1			INC ESI							;if not increment esi
 00000184  EB F7	     1			JMP ??0004						;jump to the top of the loop and look at the next char
 00000186		     1		??0005:		
 00000186  46		     1			INC ESI							;increment esi to include the null character in the string
 00000187  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000189  5E		     1		POP ESI								;restore original esi
 0000018A  5B		     1		POP EBX								;restore original ebx
 0000018B  5D		     1		POP EBP								;restore originla ebp
 0000018C  8B F0				MOV ESI, EAX
 0000018E  4E					DEC ESI
 0000018F  C7 05 0000000C R			MOV tempNum, 32
	   00000020
 00000199  8B DA				MOV EBX, EDX
 0000019B  53					PUSH EBX
 0000019C  03 DE				ADD EBX, ESI
 0000019E  A1 0000000C R			MOV EAX, tempNum
 000001A3  89 03				MOV [EBX], EAX
 000001A5  5B					POP EBX
						getBytes EDX
 000001A6  55		     1		PUSH EBP							;preserves base register
 000001A7  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001A9  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000001AA  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000001AB  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000001AD  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000001B2		     1		??0006:
 000001B2  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000001B6  74 03	     1			JE ??0007							;if it is jump to finished
 000001B8  46		     1			INC ESI							;if not increment esi
 000001B9  EB F7	     1			JMP ??0006						;jump to the top of the loop and look at the next char
 000001BB		     1		??0007:		
 000001BB  46		     1			INC ESI							;increment esi to include the null character in the string
 000001BC  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 000001BE  5E		     1		POP ESI								;restore original esi
 000001BF  5B		     1		POP EBX								;restore original ebx
 000001C0  5D		     1		POP EBP								;restore originla ebp
 000001C1  8B F0				MOV ESI, EAX
 000001C3  4E					DEC ESI
 000001C4  58					POP EAX
						
 000001C5  41					INC ECX
 000001C6  E9 FFFFFF3F				JMP lpConvertToASCII
						
 000001CB				NoComma:
 000001CB  B9 00000001				MOV ECX, 1
 000001D0  FF 4D 0C				DEC rows
 000001D3  C7 05 0000000C R			MOV tempNum, 10
	   0000000A
 000001DD  53					PUSH EBX
 000001DE  03 DE				ADD EBX, ESI
 000001E0  50					PUSH EAX
 000001E1  A1 0000000C R			MOV EAX, tempNum
 000001E6  89 03				MOV [EBX], EAX
						getBytes EDX
 000001E8  55		     1		PUSH EBP							;preserves base register
 000001E9  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001EB  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000001EC  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000001ED  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000001EF  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000001F4		     1		??0008:
 000001F4  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000001F8  74 03	     1			JE ??0009							;if it is jump to finished
 000001FA  46		     1			INC ESI							;if not increment esi
 000001FB  EB F7	     1			JMP ??0008						;jump to the top of the loop and look at the next char
 000001FD		     1		??0009:		
 000001FD  46		     1			INC ESI							;increment esi to include the null character in the string
 000001FE  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000200  5E		     1		POP ESI								;restore original esi
 00000201  5B		     1		POP EBX								;restore original ebx
 00000202  5D		     1		POP EBP								;restore originla ebp
 00000203  8B F0				MOV ESI, EAX
 00000205  4E					DEC ESI
 00000206  58					POP EAX
 00000207  5B					POP EBX
 00000208  C7 05 0000000C R			MOV tempNum, 09
	   00000009
 00000212  53					PUSH EBX
 00000213  03 DE				ADD EBX, ESI
 00000215  50					PUSH EAX
 00000216  A1 0000000C R			MOV EAX, tempNum
 0000021B  89 03				MOV [EBX], EAX
						getBytes EDX
 0000021D  55		     1		PUSH EBP							;preserves base register
 0000021E  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000220  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000221  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000222  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000224  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000229		     1		??000A:
 00000229  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 0000022D  74 03	     1			JE ??000B							;if it is jump to finished
 0000022F  46		     1			INC ESI							;if not increment esi
 00000230  EB F7	     1			JMP ??000A						;jump to the top of the loop and look at the next char
 00000232		     1		??000B:		
 00000232  46		     1			INC ESI							;increment esi to include the null character in the string
 00000233  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000235  5E		     1		POP ESI								;restore original esi
 00000236  5B		     1		POP EBX								;restore original ebx
 00000237  5D		     1		POP EBP								;restore originla ebp
 00000238  8B F0				MOV ESI, EAX
 0000023A  4E					DEC ESI
 0000023B  58					POP EAX
 0000023C  5B					POP EBX
 0000023D  E9 FFFFFEC8				JMP lpConvertToASCII
						
 00000242				finished:
 00000242  C7 05 0000000C R			MOV tempNum, 00
	   00000000
 0000024C  53					PUSH EBX
 0000024D  03 DE				ADD EBX, ESI
 0000024F  83 EB 05				SUB EBX, 5
 00000252  50					PUSH EAX
 00000253  A1 0000000C R			MOV EAX, tempNum
 00000258  89 03				MOV [EBX], EAX
 0000025A  8B 45 F8				MOV EAX, outAddr
						
 0000025D  89 45 14				MOV lpStringToHold, EAX
						RET
						
 00000265				oneByone:
 00000265  8B 5D FC				MOV EBX, startAddr
 00000268  8B 04 1F				MOV EAX, [EBX + EDI]
 0000026B  A3 0000000C R			MOV tempNum, EAX
 00000270  8B DA				MOV EBX, EDX
 00000272  53					PUSH EBX
 00000273  03 DE				ADD EBX, ESI
						INVOKE intasc32, EBX, tempNum	
 00000281  5B					POP EBX
 00000282  EB BE				JMP finished
					
					
					
 00000284			displayArray ENDP
				END
Microsoft (R) Macro Assembler Version 6.11		    10/25/19 00:45:22
proj4procs.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

getBytes . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000011 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000284 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
displayArray . . . . . . . . . .	P Near	 000000A1 _TEXT	Length= 000001E3 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  lpStringtoHold . . . . . . . .	DWord	 bp + 00000014
  startAddr  . . . . . . . . . .	DWord	 bp - 00000004
  outAddr  . . . . . . . . . . .	DWord	 bp - 00000008
  ??0000 . . . . . . . . . . . .	L Near	 000000EF _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 000000F8 _TEXT	
  lpConvertToASCII . . . . . . .	L Near	 0000010A _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000141 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 0000014A _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 0000017D _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 00000186 _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 000001B2 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 000001BB _TEXT	
  NoComma  . . . . . . . . . . .	L Near	 000001CB _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 000001F4 _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 000001FD _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 00000229 _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 00000232 _TEXT	
  finished . . . . . . . . . . .	L Near	 00000242 _TEXT	
  oneByone . . . . . . . . . . .	L Near	 00000265 _TEXT	
extractDwords  . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000A1 Public C
  StringofChars  . . . . . . . .	DWord	 bp + 00000008
  ArrayDwords  . . . . . . . . .	DWord	 bp + 0000000C
  addOut . . . . . . . . . . . .	DWord	 bp - 00000004
  addASCII . . . . . . . . . . .	DWord	 bp - 00000008
  lpConvertandMove . . . . . . .	L Near	 00000020 _TEXT	
  lpCompareWhitelist . . . . . .	L Near	 00000034 _TEXT	
  ValidChar  . . . . . . . . . .	L Near	 00000044 _TEXT	
  lpCompareNext  . . . . . . . .	L Near	 0000005F _TEXT	
  lpClearBTemp . . . . . . . . .	L Near	 0000007E _TEXT	
  ValidNextChar  . . . . . . . .	L Near	 00000095 _TEXT	
  finished . . . . . . . . . . .	L Near	 0000009B _TEXT	
intasc32Comma  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
WhiteListChars . . . . . . . . .	Byte	 00000000 _DATA	
bNumBytes  . . . . . . . . . . .	Byte	 0000000C _DATA	
bTemps . . . . . . . . . . . . .	Byte	 00000011 _DATA	
iColCount  . . . . . . . . . . .	DWord	 0000000D _DATA	
tempNum  . . . . . . . . . . . .	DWord	 0000000C _DATA	

	   0 Warnings
	   0 Errors
