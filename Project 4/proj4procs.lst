Microsoft (R) Macro Assembler Version 6.11		    11/01/19 16:09:55
proj4procs.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj4procs.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:          Proj3
				;*  Date:         11/02/2019
				;*  Purpose:      This handles the manipulation of arrays and matricies. 
				;******************************************************************************************

					.486						;This tells assembler to generate 32-bit code

					.model flat					;This tells assembler that all addresses are real addresses

					.stack 100h					;EVERY program needs to have a stack allocated

				;******************************************************************************************

				;  List all necessary prototypes for methods to be called here

					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				  ;This converts ASCII characters to the dword value
					intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword			  ;converts ints to ascii
					putstring  PROTO NEAR stdcall, lpStringToDisplay:dword  				  ;Will display ;characters until the NULL character is found
					sortedArray PROTO Near32 C, lpArrayDwords:dword, numElts:dword			  ;returns 1 if the array passed in is sorted in ascending order
					smallestValue PROTO Near32 C, lpArrayDwords:dword, rows:dword, cols:dword ;returns the smallest value in an array	
					displayArray PROTO Near32 C, lpArrayDwords:dword, rows:dword, cols:dword, ;converts an array passed in into ascii and formatting for display	
					lpStringtoHold:dword
				;******************************************************************************************
				COMMENT %

				******************************************************************************
				*Name: DisplayString                                                         *
				*Purpose:                                                                    *
				*	The purpose of this macro is to display a set of strings to the console  *
				*                                                                            *
				*Date Created: 10/02/2019                                                    *
				*Date Modified: 10/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				DisplayString MACRO String:REQ

					INVOKE putstring, ADDR String    				;;display The string passed in 

				ENDM

				COMMENT %

				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  Intakes an address and counts the number of bytes into a string including*
				*     the null char and returns the number.                                  *
				*Date Created: 10/24/2019                                                    *
				*Date Modified: 10/25/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytes MACRO String:REQ
					LOCAL stLoop						;add a local label so the assembler doesnt yell when this is called more than once
					LOCAL done							;add a local label so the assembler doesnt yell when this is called more than once
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
 00000000			.DATA

 00000000 30 31 32 33 34		WhiteListChars byte 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 43		;set of whitelisted characters, 0 1 2 3 4 5 6 7 8 9 + - 
	   35 36 37 38 39
	   2D 2B
 0000000C 0A 0D 00			crlf byte  10,13,0														;Null-terminated string to skip to new line
 0000000F 0A 0A 0D 21 21		strSortAlready byte 10,10,13, "!!! The data is already sorted !!!",0
	   21 20 54 68 65
	   20 64 61 74 61
	   20 69 73 20 61
	   6C 72 65 61 64
	   79 20 73 6F 72
	   74 65 64 20 21
	   21 21 00
 00000035 0A 0A 0D 53 6F		strSortComplete byte 10,10,13, "Sort Complete!",0
	   72 74 20 43 6F
	   6D 70 6C 65 74
	   65 21 00
 00000047				tempNum dword 0 dup (12)												;memory to hold a temp number that is built
 00000047 00				bNumBytes byte ?														;memory to hold the number of bytes in a string
 00000048 00000000			iColCount dword 0														;memory to keep track of the col count
 0000004C  00000064 [			tempSelectionSortASCII dword 100 dup(0), 00								;memory to hold the string generated in ascii
	    00000000
	   ] 00000000
 000001E0				bTemps byte 0 dup(?)													;memory to hold the number that is built in extractDwords
					
				;******************************************************************************************
 00000000			.CODE

				COMMENT %
				********************************************************************************
				*Name: extractDwords                                                           *
				*Purpose:                                                                      *
				*	     This method takes in two addresses, one with ascii characters and one *
				*        where the converted numbers will go. It translates the ascii character*
				*		 to the dword value and stores into the output location    			   *
				*Date Created: 10/23/2019                                                      *
				*Date Modified: 10/23/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param StringofChars:dword                                                    *
				*@param ArrayDwords:dword												 	   *
				*******************************************************************************%
 00000000			extractDwords PROC Near32 C uses EBX ECX EDX EDI , StringofChars:dword, ArrayDwords:dword
					LOCAL addOut:dword, addASCII:dword			;sets up our stack frame and declares our local variables. 
					
 0000000A  8B 45 0C			MOV EAX, ArrayDwords						;moves into EAX the address of the output array
 0000000D  89 45 FC			MOV addOut, EAX								;moves the address into our local variable for clarity.
 00000010  8B 45 08			MOV EAX, StringofChars						;moves into EAX the address of the array with ascii values.
 00000013  89 45 F8			MOV addASCII, EAX							;moves the address into our local variable for clarity.
					
 00000016  BB 00000000			MOV EBX, 0									;set EBX to 0 to avoid calculation error
 0000001B  BF 00000000			MOV EDI, 0									;sets our initial point in bTemps to the first place
					
 00000020				lpConvertandMove:	
 00000020  8B 45 F8				MOV EAX, addASCII						;moves the address of the ascii values into eax so we can reference it
 00000023  8A 18				MOV BL, byte ptr [EAX]					;moves into BL the byte at the address position
 00000025  80 FB 00				CMP BL, 00								;compares this byte to 00 to test if we are at the end of the array
 00000028  74 71				JE finished								;if it is equal to 00, then jump to the finished label. 
						
 0000002A  B9 0000000C				MOV ECX, lengthof WhiteListChars		;sets up our loop with the number of elements in the whitelisted characters array
 0000002F  BE 00000000				MOV ESI, 0								;sets our initial position in the whitelisted characters array to 0
						
 00000034					lpCompareWhitelist:
 00000034  3A 9E 00000000 R				CMP BL, WhiteListChars[ESI]			;compares bl to see if it is one of the whitelisted characters
 0000003A  74 08					JE ValidChar						;if it is a valid char, jump to the valid section
 0000003C  46						INC ESI								;increment esi to the next position in the whitelisted characters array
 0000003D  E2 F5				loop lpCompareWhitelist					;decrement ecx and loop back up
																;if it is not a valid char this executes:
 0000003F  FF 45 F8				INC addASCII							;increment addASCII so we get the next byte
 00000042  EB DC				JMP lpConvertandMove					;jump back up to the top to start the loop over again
						
 00000044					ValidChar:
 00000044  88 9F 000001E0 R				MOV bTemps[EDI], BL					;Moves into btemps at position edi the byte in bl to hold that byte of the number that is building
 0000004A  FF 45 F8					INC addASCII						;increment to the next position of addascii so we can see if the next char is valid
 0000004D  8B 45 F8					MOV EAX, addASCII					;moves into eax the new address of the next byte 
 00000050  8A 18					MOV BL, byte ptr [EAX]				;moves the byte into Bl 
 00000052  FF 4D F8					DEC addASCII						;change it back to the previous character
							
 00000055  B9 0000000C					MOV ECX, lengthof WhiteListChars	;adds the number of elements in whitelisted characters array into ecx for the loop
 0000005A  BE 00000000					MOV ESI, 0							;sets our initial position in the whitelisted characters array to 0
						
 0000005F						lpCompareNext:
 0000005F  3A 9E 00000000 R					CMP BL, WhiteListChars[ESI]		;This compares the next byte to see if it is whitelisted too
 00000065  74 2E						JE ValidNextChar				;if it is a valid character, jump to the valid next char section
 00000067  46							INC ESI							;increment esi if it is not valid to get to the next position in whitelisted characters
 00000068  E2 F5					loop lpCompareNext					;decrement ECX and go to the top of the current loop
							
							INVOKE ascint32, ADDR bTemps		;if it is not a valid character, then we know the number is complete and we can execute asc to int conversion
 00000074  8B 55 FC					MOV EDX, addOut						;moves the address of the output array into edx so we can reference it
 00000077  89 02					MOV [EDX], EAX						;moves the resulting EAX value into the output array at the correct position
 00000079  B9 00000004					MOV ECX, 4							;imputs 4 into ECX so we can clear our bTemps variable to prevent curruption
 0000007E						lpClearBTemp:
 0000007E  C6 81 000001E0 R					MOV [bTemps + ECX], 0			;moves 0 into the slot ECX of bTemps
	   00
 00000085  E2 F7					loop  lpClearBTemp					;jump back to the top of the current loop
 00000087  83 45 FC 04					ADD addOut, 4						;adds 4 to the output address so we can get the next dword starting point
 0000008B  BF 00000000					MOV EDI, 0							;resets edi to 0 so we get a clean bTemps variable
 00000090  FF 45 F8					INC addASCII						;increments addASCII so we get the next byte in memory
 00000093  EB 8B					JMP lpConvertandMove				;jump back up to the very top of the loop 
							
 00000095					ValidNextChar:
 00000095  47						INC EDI								;increment edi so we can input in the next position in bTemps
 00000096  FF 45 F8					INC addASCII						;increment addASCII so we get the next byte in memory
 00000099  EB 85					JMP lpConvertandMove				;jump back up to the very top of the loop
							
							
 0000009B				finished:
						RET										;return back to where i was called 
 000000A1			extractDwords ENDP 

				COMMENT %
				********************************************************************************
				*Name: displayArray                                                            *
				*Purpose:                                                                      *
				*	      Intakes beginning address of dwords and converts it into the appropriate*
				*        matrix display for output and returns the address to the string 	   *
				*		 generated.															   *
				*		     			   													   *
				*Date Created: 10/24/2019                                                      *
				*Date Modified: 10/25/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword												 	           *
				*@param cols:dword												 	           *
				*@param lpStringtoHold:dword									 	           *
				*******************************************************************************%
 000000A1			displayArray PROC Near32 C uses EBX EDX EDI, lpArrayDwords:dword, rows:dword, cols:dword, lpStringtoHold:dword
					LOCAL startAddr:dword, outAddr:dword, tempNumRow:dword, tempNumCol:dword
 000000AA  8B 45 0C			MOV EAX, rows								;moves the number of rows into eax so we can check if it is a 1xM later
 000000AD  89 45 F4			MOV tempNumRow, EAX							;moves the row number into a temp variable for later
 000000B0  8B 45 10			MOV EAX, cols								;moves the number of cols into eax so we can check if it is a 1xM later
 000000B3  89 45 F0			MOV tempNumCol, EAX							;store the col number into a temp variable
 000000B6  8B 45 08			MOV EAX, lpArrayDwords						;moves into EAX the address of the output array
 000000B9  89 45 FC			MOV startAddr, EAX							;moves the address into our local variable for clarity.
 000000BC  8B 45 14			MOV EAX, lpStringtoHold						;moves into EAX the address of the array with ascii values.
 000000BF  89 45 F8			MOV outAddr, EAX							;moves the address into our local variable for clarity.

					
 000000C2  BF 00000000			MOV EDI, 0									;set the initial point into the original address to 0
 000000C7  BE 00000000			MOV ESI, 0									;set the initial point into the new address to 0
 000000CC  B9 00000001			MOV ECX, 1									;set ecx to 1 because we start with 1 col
 000000D1  8B 55 F8			MOV EDX, outAddr							;moves the address of out address to edx so we can derefrence the address
 000000D4  8B 5D FC			MOV EBX, startAddr							;moves the address of out address to edx so we can derefrence the address
					
 000000D7  C7 05 00000047 R		MOV tempNum, 09								;set the temp number to the tab character
	   00000009
 000000E1  8B DA			MOV EBX, EDX								;moves the address of out address into ebx so we can use it to put the character
 000000E3  53				PUSH EBX									;store ebx so we can have the unaffected value later
 000000E4  03 DE			ADD EBX, ESI								;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 000000E6  50				PUSH EAX									;preserve EAX so we can restore it later
 000000E7  A1 00000047 R		MOV EAX, tempNum							;move into eax the temp number which is tab
 000000EC  89 03			MOV [EBX], EAX								;moves into the location ebx points to the temp number 
 000000EE  5B				POP EBX										;restore our unaffected EBX
					getBytes EDX								;call the get bytes macro where we count the number of bytes used in the output address
 000000EF  55		     1		PUSH EBP							
 000000F0  8B EC	     1		MOV EBP, ESP						
 000000F2  53		     1		PUSH EBX							
 000000F3  56		     1		PUSH ESI							
 000000F4  8B DA	     1		MOV EBX, EDX						
 000000F6  BE 00000000	     1		MOV ESI, 0							
 000000FB		     1		??0000:
 000000FB  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 000000FF  74 03	     1			JE ??0001							
 00000101  46		     1			INC ESI							
 00000102  EB F7	     1			JMP ??0000						
 00000104		     1		??0001:		
 00000104  46		     1			INC ESI							
 00000105  8B C6	     1			MOV EAX, ESI					
 00000107  5E		     1		POP ESI								
 00000108  5B		     1		POP EBX								
 00000109  5D		     1		POP EBP								
 0000010A  8B F0			MOV ESI, EAX								;moves into ESI the offset that the previous macro returns
 0000010C  4E				DEC ESI										;decrement ESI to take into acount the null character the macro counts for.
					
 0000010D  50				PUSH EAX									;preserve EAX so we can restore it later
 0000010E  8B 45 0C			MOV EAX, rows								;moves into eax the number of rows we have
 00000111  03 45 10			ADD EAX, cols								;adds the number of cols into eax so we can test if we have a 1x1 matrix
 00000114  83 F8 02			CMP EAX, 2									;compares eax to 2 to check if it is a 1x1  (1 + 1 = 2)
 00000117  0F 84 0000013E		JE oneByone									;if it detects a 1x1 matrix, then jump to the proper section.
 0000011D  58				POP EAX										;otherwise, restore EAX so we can use the original value.
					
 0000011E				lpConvertToASCII:
 0000011E  83 7D 0C 00				CMP rows, 0								;check to see if we have used up the allowed number of rows
 00000122  0F 84 0000012E			JE finished								;if it is equal to 0, jump to the finished section
 00000128  8B 5D FC				MOV EBX, startAddr						;moves the address of out address to edx so we can derefrence the address
 0000012B  8B 04 1F				MOV EAX, [EBX + EDI]					;moves into eax the address of ebx + edi so we can get the correct number to convert
 0000012E  A3 00000047 R			MOV tempNum, EAX						;stores the number obtained in EAX into tempNum so we can use it in invoke, cant use eax
 00000133  8B DA				MOV EBX, EDX							;moves into ebx, the adress of the outaddress
 00000135  53					PUSH EBX								;stores our ebx variable so we can get it back later
 00000136  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
						INVOKE intasc32, EBX, tempNum			;calls intasc32 to convert the number into ascii characters and place into the address ebx points to
 00000144  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
 00000145  83 C7 04				ADD EDI, 4								;add 4 to edi so we get the next dword in the numbers to pull from.
						
 00000148  50					PUSH EAX								;store our EAX so we can get it back 
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000149  55		     1		PUSH EBP							
 0000014A  8B EC	     1		MOV EBP, ESP						
 0000014C  53		     1		PUSH EBX							
 0000014D  56		     1		PUSH ESI							
 0000014E  8B DA	     1		MOV EBX, EDX						
 00000150  BE 00000000	     1		MOV ESI, 0							
 00000155		     1		??0002:
 00000155  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000159  74 03	     1			JE ??0003							
 0000015B  46		     1			INC ESI							
 0000015C  EB F7	     1			JMP ??0002						
 0000015E		     1		??0003:		
 0000015E  46		     1			INC ESI							
 0000015F  8B C6	     1			MOV EAX, ESI					
 00000161  5E		     1		POP ESI								
 00000162  5B		     1		POP EBX								
 00000163  5D		     1		POP EBP								
 00000164  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 00000166  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 00000167  58					POP EAX									;restore our original eax
						
 00000168  3B 4D 10				CMP ECX, cols							;compare ecx to the number of cols to check if we are at the end of the row
 0000016B  74 72				JE NoComma								;if there is no more numbers to the row, the jump to the no comma section 
						
 0000016D  C7 05 00000047 R			MOV tempNum, 44							;moves the comma ascii value into temp num
	   0000002C
 00000177  8B DA				MOV EBX, EDX							;moves into ebx, the adress of the outaddress
 00000179  53					PUSH EBX								;stores our ebx variable so we can get it back later
 0000017A  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 0000017C  50					PUSH EAX								;store our EAX so we can get it back 
 0000017D  A1 00000047 R			MOV EAX, tempNum						;moves into EAX the value temp num so we can but it into place without calling mem to mem
 00000182  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value of eax, which is temp num
 00000184  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000185  55		     1		PUSH EBP							
 00000186  8B EC	     1		MOV EBP, ESP						
 00000188  53		     1		PUSH EBX							
 00000189  56		     1		PUSH ESI							
 0000018A  8B DA	     1		MOV EBX, EDX						
 0000018C  BE 00000000	     1		MOV ESI, 0							
 00000191		     1		??0004:
 00000191  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000195  74 03	     1			JE ??0005							
 00000197  46		     1			INC ESI							
 00000198  EB F7	     1			JMP ??0004						
 0000019A		     1		??0005:		
 0000019A  46		     1			INC ESI							
 0000019B  8B C6	     1			MOV EAX, ESI					
 0000019D  5E		     1		POP ESI								
 0000019E  5B		     1		POP EBX								
 0000019F  5D		     1		POP EBP								
 000001A0  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 000001A2  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 000001A3  C7 05 00000047 R			MOV tempNum, 32							;moves the space ascii value into temp num
	   00000020
 000001AD  8B DA				MOV EBX, EDX							;moves the address in edx into ebx so we can use it 
 000001AF  53					PUSH EBX								;stores our ebx variable so we can get it back later
 000001B0  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 000001B2  A1 00000047 R			MOV EAX, tempNum						;moves into EAX the value temp num so we can but it into place without calling mem to mem
 000001B7  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value of eax, which is temp num
 000001B9  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 000001BA  55		     1		PUSH EBP							
 000001BB  8B EC	     1		MOV EBP, ESP						
 000001BD  53		     1		PUSH EBX							
 000001BE  56		     1		PUSH ESI							
 000001BF  8B DA	     1		MOV EBX, EDX						
 000001C1  BE 00000000	     1		MOV ESI, 0							
 000001C6		     1		??0006:
 000001C6  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 000001CA  74 03	     1			JE ??0007							
 000001CC  46		     1			INC ESI							
 000001CD  EB F7	     1			JMP ??0006						
 000001CF		     1		??0007:		
 000001CF  46		     1			INC ESI							
 000001D0  8B C6	     1			MOV EAX, ESI					
 000001D2  5E		     1		POP ESI								
 000001D3  5B		     1		POP EBX								
 000001D4  5D		     1		POP EBP								
 000001D5  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 000001D7  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 000001D8  58					POP EAX									;restore our original eax
						
 000001D9  41					INC ECX									;increments we we know we are on the next col
 000001DA  E9 FFFFFF3F				JMP lpConvertToASCII					;jumps back to the top
						
 000001DF				NoComma:
 000001DF  B9 00000001				MOV ECX, 1								;reset the col value back to 1
 000001E4  FF 4D 0C				DEC rows								;decrement the number of rows so we can terminate this loop eventually
 000001E7  C7 05 00000047 R			MOV tempNum, 10							;moves the new line character into tempNum
	   0000000A
 000001F1  53					PUSH EBX								;pushes ebx to the stack so we can have the unaffected value later
 000001F2  03 DE				ADD EBX, ESI							;add the offset esi into ebx so we point to the right byte to place
 000001F4  50					PUSH EAX								;push eax to store it
 000001F5  A1 00000047 R			MOV EAX, tempNum						;moves the new line char into eax (avoid mem to mem)
 000001FA  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value eax which is new line
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 000001FC  55		     1		PUSH EBP							
 000001FD  8B EC	     1		MOV EBP, ESP						
 000001FF  53		     1		PUSH EBX							
 00000200  56		     1		PUSH ESI							
 00000201  8B DA	     1		MOV EBX, EDX						
 00000203  BE 00000000	     1		MOV ESI, 0							
 00000208		     1		??0008:
 00000208  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 0000020C  74 03	     1			JE ??0009							
 0000020E  46		     1			INC ESI							
 0000020F  EB F7	     1			JMP ??0008						
 00000211		     1		??0009:		
 00000211  46		     1			INC ESI							
 00000212  8B C6	     1			MOV EAX, ESI					
 00000214  5E		     1		POP ESI								
 00000215  5B		     1		POP EBX								
 00000216  5D		     1		POP EBP								
 00000217  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 00000219  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 0000021A  58					POP EAX									;restore original eax
 0000021B  5B					POP EBX									;restore original ebx
 0000021C  C7 05 00000047 R			MOV tempNum, 09							;moves the tab character into tempNum
	   00000009
 00000226  53					PUSH EBX								;pushes ebx to the stack so we can have the unaffected value later
 00000227  03 DE				ADD EBX, ESI							;add the offset esi into ebx so we point to the right byte to place
 00000229  50					PUSH EAX								;push eax to store it
 0000022A  A1 00000047 R			MOV EAX, tempNum						;moves the new line char into eax (avoid mem to mem)
 0000022F  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value eax which is new line
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000231  55		     1		PUSH EBP							
 00000232  8B EC	     1		MOV EBP, ESP						
 00000234  53		     1		PUSH EBX							
 00000235  56		     1		PUSH ESI							
 00000236  8B DA	     1		MOV EBX, EDX						
 00000238  BE 00000000	     1		MOV ESI, 0							
 0000023D		     1		??000A:
 0000023D  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000241  74 03	     1			JE ??000B							
 00000243  46		     1			INC ESI							
 00000244  EB F7	     1			JMP ??000A						
 00000246		     1		??000B:		
 00000246  46		     1			INC ESI							
 00000247  8B C6	     1			MOV EAX, ESI					
 00000249  5E		     1		POP ESI								
 0000024A  5B		     1		POP EBX								
 0000024B  5D		     1		POP EBP								
 0000024C  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 0000024E  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 0000024F  58					POP EAX									;restore original eax
 00000250  5B					POP EBX									;restore original ebx
 00000251  E9 FFFFFEC8				JMP lpConvertToASCII					;jump back to the top of the loop
						
 00000256				finished:
						RET										;return back to where i was called
						
 0000025B				oneByone:
 0000025B  8B 5D FC				MOV EBX, startAddr						;moves the starting address into ebx
 0000025E  8B 03				MOV EAX, [EBX]							;moves the value ebx points to into eax
 00000260  A3 00000047 R			MOV tempNum, EAX						;moves eax into the temp num variable
 00000265  8B DA				MOV EBX, EDX							;moves the eaddress of edx into ebx so we can modify it
 00000267  53					PUSH EBX								;pushes ebx to store it
 00000268  03 DE				ADD EBX, ESI							;adds the offset esi into ebx so we point to the right place
						INVOKE intasc32, EBX, tempNum			;convert the number into the ascii format and put into where ebx points
 00000276  5B					POP EBX									;restore ebx
 00000277  EB DD				JMP finished							;jump to the finished section

 00000279			displayArray ENDP

				COMMENT %
				********************************************************************************
				*Name: sortedArray                                                             *
				*Purpose:                                                                      *
				*	           This method accepts the address of a dword array and the number *
				*		of dwords in that array. It returns TRUE (1 in AL register) if the array*
				*		is in ascending sorted order, and 0 otherwise. 						   *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/26/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param numElts:dword												 	       *
				*@return Boolean:Byte												 	       *
				*******************************************************************************%
 00000279			sortedArray PROC Near32 C uses EBX ECX EDX EDI, lpArrayDwords:dword, numElts:dword
					LOCAL bool:byte
					
 00000283  8B 4D 0C			MOV ECX, numElts							;Moves the number of elements into othe ecx register so we can track our loop
 00000286  49				DEC ECX										;decrements the number of elements so dont grab outside of your area
 00000287  BF 00000000			MOV EDI, 0									;sets initial offset to 0
 0000028C  8B 45 08			MOV EAX, lpArrayDwords						;move the address into EAX so we can reference it
					
 0000028F				lpCheckAscending:
 0000028F  8B 1C 07				MOV EBX, [EAX + EDI]					;Move the value located at eax + edi into ebx
 00000292  83 C7 04				ADD EDI, 4								;increment our offset by 4 to get the next dword
 00000295  8B 14 07				MOV EDX, [EAX + EDI]					;Move the value located at eax + edi into edx
 00000298  3B DA				CMP EBX, EDX							;compare the two registers to see if ebx is less than or equal to edx
 0000029A  7E 0F				JLE LessThan							;if it is jump to appropriate section
 0000029C  C6 45 FF 00				MOV bool, 0								;if it is not, we can move 0 into our bool byte and assume it is not in sorted ascending order
 000002A0  EB 00				JMP done								;jump to done
						
 000002A2				done:
 000002A2  8A 45 FF				MOV AL, bool							;moves into AL the result of the loop above
						RET										;returns back to where this method was called from
						
 000002AB				LessThan:
 000002AB  C6 45 FF 01				MOV bool, 1								;move a 1 into our byte 
 000002AF  49					DEC ECX									;decrement our number of elements we have left
 000002B0  83 F9 00				CMP ECX, 0								;compare to 0 to see if we are at the end of our loop 
 000002B3  74 ED				JE done									;if it equals 0, then jump to done
 000002B5  EB D8				JMP lpCheckAscending					;if not, then jump back to the top of the loop

 000002B7			sortedArray ENDP

				COMMENT %
				********************************************************************************
				*Name: sumUpArray                                                              *
				*Purpose:                                                                      *
				*	       Adds up all the values in the matrix, and return the answer		   *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/26/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword													 	       *
				*@param cols:dword 													 	       *
				*@return sum:dword															   *
				*******************************************************************************%
 000002B7			sumUpArray PROC Near32 C uses EBX ECX EDI, lpArrayDwords:dword, rows:dword, cols:dword
					LOCAL sum:dword
					
 000002C0  8B 45 0C			MOV EAX, rows								;moves the number of rows into eax so we can multiply it to get numElements
 000002C3  F7 65 10			MUL cols									;Multiplies EAX by the number of cols
 000002C6  8B C8			MOV ECX, EAX								;stores the number of elements 
 000002C8  8B 45 08			MOV EAX, lpArrayDwords						;move the address into EAX so we can reference it
 000002CB  BF 00000000			MOV EDI, 0									;set the intital offset to 0
 000002D0  C7 45 FC			MOV sum, 0									;set the intital sum to 0
	   00000000
					
 000002D7				lpSumArray:
 000002D7  8B 1C 07				MOV EBX, [EAX + EDI]					;moves into ebx, the value located at eax offset edi
 000002DA  01 5D FC				ADD sum, EBX							;add the value into the sum
 000002DD  83 C7 04				ADD EDI, 4								;add 4 to edi so we get the next number in the sequence
 000002E0  E2 F5			loop lpSumArray								;decrement ecx and jump back to the top
					
 000002E2  8B 45 FC			MOV EAX, sum								;move our sum into eax for return
					RET											;return
					
 000002EA			sumUpArray ENDP

				COMMENT %
				********************************************************************************
				*Name: smallestValue                                                           *
				*Purpose:                                                                      *
				*	       Determine the smallest Value in the array and return the answer     *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/26/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword													 	       *
				*@param cols:dword 													 	       *
				*@return smallestVal:dword													   *
				*******************************************************************************%
 000002EA			smallestValue PROC Near32 C uses EBX ECX EDI, lpArrayDwords:dword, rows:dword, cols:dword
					LOCAL smallestVal:dword
						
 000002F3  BF 00000000			MOV EDI, 0									;set the intital offset to 0
 000002F8  8B 45 0C			MOV EAX, rows								;moves the number of rows into eax so we can multiply it to get numElements
 000002FB  F7 65 10			MUL cols									;Multiplies EAX by the number of cols
 000002FE  8B C8			MOV ECX, EAX								;stores the number of elements 
 00000300  8B 45 08			MOV EAX, lpArrayDwords						;move the address into EAX so we can reference it
 00000303  83 F9 01			CMP ECX, 1									;compare ecx to one to see if the user entered 1x1
 00000306  74 2C			JE oneByone									;if it is then jump to the one by one section
					
 00000308  8B 1C 07			MOV EBX, [EAX + EDI]						;moves into ebx the first value
 0000030B  89 5D FC			MOV smallestVal, EBX						;stores the first value as the smallest one
					
 0000030E				lpGetSmallest:
 0000030E  83 C7 04				ADD EDI, 4								;increments the offset by 4 so we get the next dword
 00000311  8B 1C 07				MOV EBX, [EAX + EDI]					;moves into ebx the value located at that location
 00000314  3B 5D FC				CMP EBX, smallestVal					;compare that value to the current smallest number
 00000317  7C 08				JL newSmallest							;if the register is less than the current smallest value jump to new smallest
 00000319  49					DEC ECX									;decrement ecx so we can terminate the loop eventually 
 0000031A  83 F9 00				CMP ECX, 0								;compares ecx to 0, so we check to see if the loop is done
 0000031D  74 0D				JE DoneLoop								;if it is 0 then jump to done loop
 0000031F  EB ED				JMP lpGetSmallest						;if it is not then jump back to the top
						
 00000321				newSmallest:
 00000321  89 5D FC				MOV smallestVal, EBX					;moves the value currently in ebx into our smallest value variable
 00000324  49					DEC ECX									;decrement ecx so we can terminate the loop eventually 
 00000325  83 F9 00				CMP ECX, 0								;compares ecx to 0, so we check to see if the loop is done
 00000328  74 02				JE DoneLoop								;if it is 0 then jump to done loop
 0000032A  EB E2				JMP lpGetSmallest						;if it is not then jump back to the top
						
 0000032C				DoneLoop:
 0000032C  8B 45 FC				MOV EAX, smallestVal					;moves into eax the value in smallest value so we can return it
						RET										;return
						
 00000334				oneByone:
 00000334  8B 1C 07				MOV EBX, [EAX + EDI]					;moves into ebx the first value
 00000337  89 5D FC				MOV smallestVal, EBX					;stores the first value as the smallest one
 0000033A  EB F0				JMP DoneLoop							;jump to end of loop
							

 0000033C			smallestValue ENDP

				COMMENT %
				********************************************************************************
				*Name: selectionSort                                                           *
				*Purpose:                                                                      *
				*	      Takes in an array, and sorts it displaying each pass 				   *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/27/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param iLegth:dword													 	   *
				*******************************************************************************%
 0000033C			selectionSort PROC Near32 C uses EBX EDX EDI, lpArrayDwords:dword, iLength:dword
					LOCAL smallestVal:dword, startAddr:dword, offsetAddr:Dword, storedNum:Dword, counter:dword
					
 00000345  8B 45 08			MOV EAX, lpArrayDwords						;moves the address into eax						
 00000348  89 45 F8			MOV startAddr, EAX							;stores this address into a different variable for clarity
 0000034B  B9 00000000			MOV ECX, 0									;sets ecx to 0 to set our initial counter
 00000350  BF 00000000			MOV EDI, 0									;sets the initial offset to 0
 00000355  8B 45 0C			MOV EAX, iLength							;moves ilength to eax so we dont do mem to mem
 00000358  89 45 EC			MOV counter, EAX 							;stores this as a seperate counter variable seperete from ecx
					
 0000035B  8B 45 F8			MOV EAX, startAddr							;moves the starting address into eax
 0000035E  89 45 F4			MOV offsetAddr, EAX							;moves the intital offset address into eax
 00000361  8B 18			MOV EBX, [EAX]								;moves into ebx the valuew located at what eax points to
 00000363  89 5D F0			MOV storedNum, EBX							;moves ebx into a variable as this is the first number we are storing
					
					INVOKE sortedArray, lpArrayDwords, iLength	;invoke the sorted array method to check if the array is already sorted
 00000374  3C 01			CMP AL, 1									;compares the result al to 1
 00000376  0F 84 000000B8		JE alreadySorted							;if it equals 1 then the data is already sorted and we can jump to the appropriate section
					
 0000037C				lpSelectionSort:
						INVOKE sortedArray, lpArrayDwords,		;check if the array is sorted.
						iLength		
 0000038A  3C 01				CMP AL, 1								;compare al to 1 to see if the data is sorted
 0000038C  0F 84 000000E4			JE SortComplete							;if it equals 1 then we jump to sort complete
						DisplayString crlf						;display the characters to skip to a new line
 0000039C  57					PUSH EDI								;preserve our edi so it doesnt get trashed when we invoke these methods
 0000039D  53					PUSH EBX								;preserve our ebx so it doesnt get trashed when we invoke these methods
						INVOKE displayArray, startAddr, 1, 		;display the array with 1 row and ilength cols
						iLength, addr tempSelectionSortASCII
						DisplayString tempSelectionSortASCII	;display the address that gets returns previously


 000003BD  5B					POP EBX									;return our original ebx
 000003BE  5F					POP EDI									;return our orginal edi
 000003BF  41					INC ECX									;increment ecx so we know how what pass we are on
 000003C0  FF 4D EC				DEC counter								;decrement our counter so we know how many swaps we have left to do
 000003C3  83 7D EC 00				CMP counter, 0							;if it equals 0, then the sort is complete
 000003C7  0F 84 000000A9			JE SortComplete							;jump to sort complete
 000003CD  83 7D EC 01				CMP counter, 1							;if it equals 1
 000003D1  74 51				JE swap									;jump to the section to swap the last two numbers. 
						INVOKE smallestValue, offsetAddr, 1, 	;get the smallest value starting at the offset address (the values before offset address should already be sorted so we can ignore them)
						counter
 000003E3  89 45 FC				MOV smallestVal, EAX					;moves the returning eax value into smallestVal
 000003E6  57					PUSH EDI								;store our edi so it doesnt get trashed (we could lose our offset)
 000003E7  BF 00000000				MOV EDI, 0								;move intial offset to 0 (going to get offset of the smallest number found)
						
 000003EC					lpGetPosofSmallest:
 000003EC  8B 5D F4					MOV EBX, offsetAddr					;moves the offset address into ebx so we can reference it
 000003EF  8B 04 1F					MOV EAX, [EBX + EDI]				;moves the value that ebx + edi points to into eax
 000003F2  3B 45 FC					CMP EAX, smallestVal				;compares this number to the smallest value to check if we found it 
 000003F5  74 05					JE foundOffset						;if we have we have our offset in edi
 000003F7  83 C7 04					ADD EDI, 4							;if not we can add 4 to edi to get the next number
 000003FA  EB F0					JMP lpGetPosofSmallest				;jump to the top of the loop
							
 000003FC						foundOffset:
 000003FC  83 7D EC 01					CMP counter, 1						;compare the counter to 1 to see if we only need to swap the last two 
 00000400  74 22					JE swap								;if it equals 1 then we jump to the swap section
 00000402  8B 04 1F					MOV EAX, [EBX + EDI]				;if not, we move ointo eax the number found
 00000405  8B 55 F0					MOV EDX, storedNum					;move into edx the stored number
 00000408  89 14 1F					MOV [EBX + EDI], EDX				;moves the stored number into the position where the smallest was found
 0000040B  89 03					MOV [EBX], EAX						;then we move the smallest number into the first position
 0000040D  5F						POP EDI								;restore our original edi

 0000040E  8B 45 F4				MOV EAX, offsetAddr						;moves the offset address into eax			
 00000411  83 C0 04				ADD EAX, 4								;adds 4 into eax to get the next number
 00000414  83 C7 04				ADD EDI, 4								;add 4 to edi so we keep track of the offset from the original address
 00000417  89 45 F4				MOV offsetAddr, EAX						;moves into offset address our new addres
 0000041A  8B 18				MOV EBX, [EAX]							;moves into oebx the first value that eax points to
 0000041C  89 5D F0				MOV storedNum, EBX						;this is our new stored number
 0000041F  E9 FFFFFF58			JMP lpSelectionSort							;jump back to the top of the loop
							
 00000424				swap:
 00000424  8B 5D F4				MOV EBX, offsetAddr						;moves into ebx the offset address
 00000427  8B 43 04				MOV EAX, [EBX + 4]						;moves into eax the next number in offset address
 0000042A  8B 55 F0				MOV EDX, storedNum						;moves into edx our stored number
 0000042D  89 53 04				MOV [EBX + 4], EDX						;moves the stored number into offset 4
 00000430  89 03				MOV [EBX], EAX							;moves eax into the first value ebx points to
 00000432  EB 42				JMP SortComplete						;the sort is complete and we can jump to the section
						
 00000434				alreadySorted:
						DisplayString crlf								;display the characters that skip to a new line
						INVOKE displayArray, startAddr, 1, iLength, 	;call display array method to get the string
						addr tempSelectionSortASCII
						DisplayString tempSelectionSortASCII			;display the string that was given back to us
						DisplayString strSortAlready					;display the string telling the user that the data is already in sorted order
						DisplayString crlf								;display the characters that skip to a new line						
						RET												;return
					
 00000476				SortComplete:	
						DisplayString crlf								;display the characters that skip to a new line
						INVOKE displayArray, lpArrayDwords, 1, iLength, ;call display array method to get the string
						addr tempSelectionSortASCII
						DisplayString tempSelectionSortASCII			;display the string that was given back to us
						DisplayString strSortComplete					;display the string telling the user that the data is sorted
						DisplayString crlf								;display the characters that skip to a new line	
						RET												;return
 000004B8			selectionSort ENDP

				COMMENT %
				********************************************************************************
				*Name: multArrays                                                              *
				*Purpose:                                                                      *
				*	      NOT IMPLEMENTED								     				   *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/27/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayA:dword                                                         *
				*@param rowsA:dword													 	  	   *
				*@param colsA:dword															   *
				*@param lpArrayB:dword														   *
				*@param colsB:dword															   *
				*******************************************************************************%
 000004B8			multArrays PROC stdcall, lpArrayA:dword, rowsA:dword, colsA:dword, lpArrayB:dword, colsB:dword
				    RET
 000004BF			multArrays endp

				END
Microsoft (R) Macro Assembler Version 6.11		    11/01/19 16:09:55
proj4procs.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

DisplayString  . . . . . . . . .	Proc
getBytes . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 000001E0 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 000004BF DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
displayArray . . . . . . . . . .	P Near	 000000A1 _TEXT	Length= 000001D8 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  lpStringtoHold . . . . . . . .	DWord	 bp + 00000014
  startAddr  . . . . . . . . . .	DWord	 bp - 00000004
  outAddr  . . . . . . . . . . .	DWord	 bp - 00000008
  tempNumRow . . . . . . . . . .	DWord	 bp - 0000000C
  tempNumCol . . . . . . . . . .	DWord	 bp - 00000010
  ??0000 . . . . . . . . . . . .	L Near	 000000FB _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 00000104 _TEXT	
  lpConvertToASCII . . . . . . .	L Near	 0000011E _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000155 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 0000015E _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 00000191 _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 0000019A _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 000001C6 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 000001CF _TEXT	
  NoComma  . . . . . . . . . . .	L Near	 000001DF _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 00000208 _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 00000211 _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 0000023D _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 00000246 _TEXT	
  finished . . . . . . . . . . .	L Near	 00000256 _TEXT	
  oneByone . . . . . . . . . . .	L Near	 0000025B _TEXT	
extractDwords  . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000A1 Public C
  StringofChars  . . . . . . . .	DWord	 bp + 00000008
  ArrayDwords  . . . . . . . . .	DWord	 bp + 0000000C
  addOut . . . . . . . . . . . .	DWord	 bp - 00000004
  addASCII . . . . . . . . . . .	DWord	 bp - 00000008
  lpConvertandMove . . . . . . .	L Near	 00000020 _TEXT	
  lpCompareWhitelist . . . . . .	L Near	 00000034 _TEXT	
  ValidChar  . . . . . . . . . .	L Near	 00000044 _TEXT	
  lpCompareNext  . . . . . . . .	L Near	 0000005F _TEXT	
  lpClearBTemp . . . . . . . . .	L Near	 0000007E _TEXT	
  ValidNextChar  . . . . . . . .	L Near	 00000095 _TEXT	
  finished . . . . . . . . . . .	L Near	 0000009B _TEXT	
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
multArrays . . . . . . . . . . .	P Near	 000004B8 _TEXT	Length= 00000007 Public STDCALL
  lpArrayA . . . . . . . . . . .	DWord	 bp + 00000008
  rowsA  . . . . . . . . . . . .	DWord	 bp + 0000000C
  colsA  . . . . . . . . . . . .	DWord	 bp + 00000010
  lpArrayB . . . . . . . . . . .	DWord	 bp + 00000014
  colsB  . . . . . . . . . . . .	DWord	 bp + 00000018
putstring  . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
selectionSort  . . . . . . . . .	P Near	 0000033C _TEXT	Length= 0000017C Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  iLength  . . . . . . . . . . .	DWord	 bp + 0000000C
  smallestVal  . . . . . . . . .	DWord	 bp - 00000004
  startAddr  . . . . . . . . . .	DWord	 bp - 00000008
  offsetAddr . . . . . . . . . .	DWord	 bp - 0000000C
  storedNum  . . . . . . . . . .	DWord	 bp - 00000010
  counter  . . . . . . . . . . .	DWord	 bp - 00000014
  lpSelectionSort  . . . . . . .	L Near	 0000037C _TEXT	
  lpGetPosofSmallest . . . . . .	L Near	 000003EC _TEXT	
  foundOffset  . . . . . . . . .	L Near	 000003FC _TEXT	
  swap . . . . . . . . . . . . .	L Near	 00000424 _TEXT	
  alreadySorted  . . . . . . . .	L Near	 00000434 _TEXT	
  SortComplete . . . . . . . . .	L Near	 00000476 _TEXT	
smallestValue  . . . . . . . . .	P Near	 000002EA _TEXT	Length= 00000052 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  smallestVal  . . . . . . . . .	DWord	 bp - 00000004
  lpGetSmallest  . . . . . . . .	L Near	 0000030E _TEXT	
  newSmallest  . . . . . . . . .	L Near	 00000321 _TEXT	
  DoneLoop . . . . . . . . . . .	L Near	 0000032C _TEXT	
  oneByone . . . . . . . . . . .	L Near	 00000334 _TEXT	
sortedArray  . . . . . . . . . .	P Near	 00000279 _TEXT	Length= 0000003E Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  numElts  . . . . . . . . . . .	DWord	 bp + 0000000C
  bool . . . . . . . . . . . . .	Byte	 bp - 00000001
  lpCheckAscending . . . . . . .	L Near	 0000028F _TEXT	
  done . . . . . . . . . . . . .	L Near	 000002A2 _TEXT	
  LessThan . . . . . . . . . . .	L Near	 000002AB _TEXT	
sumUpArray . . . . . . . . . . .	P Near	 000002B7 _TEXT	Length= 00000033 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  sum  . . . . . . . . . . . . .	DWord	 bp - 00000004
  lpSumArray . . . . . . . . . .	L Near	 000002D7 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
WhiteListChars . . . . . . . . .	Byte	 00000000 _DATA	
bNumBytes  . . . . . . . . . . .	Byte	 00000047 _DATA	
bTemps . . . . . . . . . . . . .	Byte	 000001E0 _DATA	
crlf . . . . . . . . . . . . . .	Byte	 0000000C _DATA	
iColCount  . . . . . . . . . . .	DWord	 00000048 _DATA	
strSortAlready . . . . . . . . .	Byte	 0000000F _DATA	
strSortComplete  . . . . . . . .	Byte	 00000035 _DATA	
tempNum  . . . . . . . . . . . .	DWord	 00000047 _DATA	
tempSelectionSortASCII . . . . .	DWord	 0000004C _DATA	

	   0 Warnings
	   0 Errors
