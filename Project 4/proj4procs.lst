Microsoft (R) Macro Assembler Version 6.11		    10/26/19 19:30:28
proj4procs.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj4procs.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:          Proj3
				;*  Date:         11/02/2019
				;*  Purpose:      This handles the manipulation of matrices. 
				;******************************************************************************************

					.486						;This tells assembler to generate 32-bit code

					.model flat					;This tells assembler that all addresses are real addresses

					.stack 100h					;EVERY program needs to have a stack allocated

				;******************************************************************************************

				;  List all necessary prototypes for methods to be called here

					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				;This converts ASCII characters to the dword value
					intasc32Comma proto Near32 stdcall, lpStringToHold:dword, dval:dword
					intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword
				;******************************************************************************************
				COMMENT %

				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  Intakes an address and counts the number of bytes into a string including*
				*     the null char and returns the number.                                  *
				*Date Created: 10/02/2019                                                    *
				*Date Modified: 10/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytes MACRO String:REQ
					LOCAL stLoop
					LOCAL done
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
 00000000			.DATA

 00000000 30 31 32 33 34		WhiteListChars byte 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 43		;set of whitelisted characters, 0 1 2 3 4 5 6 7 8 9 + - 
	   35 36 37 38 39
	   2D 2B
 0000000C				tempNum dword 0 dup (12)
 0000000C 00				bNumBytes byte ?
 0000000D 00000000			iColCount dword 0
 00000011				bTemps byte 0 dup(?)													;memory to hold the number that is built in extractDwords

				;******************************************************************************************
 00000000			.CODE

				COMMENT %
				********************************************************************************
				*Name: extractDwords                                                           *
				*Purpose:                                                                      *
				*	     This method takes in two addresses, one with ascii characters and one *
				*        where the converted numbers will go. It translates the ascii character*
				*		 to the dword value and stores into the output location    			   *
				*Date Created: 10/23/2019                                                      *
				*Date Modified: 10/23/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param StringofChars:dword                                                    *
				*@param ArrayDwords:dword												 	   *
				*******************************************************************************%
 00000000			extractDwords PROC Near32 C uses EBX ECX EDX EDI , StringofChars:dword, ArrayDwords:dword
					LOCAL addOut:dword, addASCII:dword			;sets up our stack frame and declares our local variables. 
					
 0000000A  8B 45 0C			MOV EAX, ArrayDwords						;moves into EAX the address of the output array
 0000000D  89 45 FC			MOV addOut, EAX								;moves the address into our local variable for clarity.
 00000010  8B 45 08			MOV EAX, StringofChars						;moves into EAX the address of the array with ascii values.
 00000013  89 45 F8			MOV addASCII, EAX							;moves the address into our local variable for clarity.
					
 00000016  BB 00000000			MOV EBX, 0									;set EBX to 0 to avoid calculation error
 0000001B  BF 00000000			MOV EDI, 0									;sets our initial point in bTemps to the first place
					
 00000020				lpConvertandMove:	
 00000020  8B 45 F8				MOV EAX, addASCII						;moves the address of the ascii values into eax so we can reference it
 00000023  8A 18				MOV BL, byte ptr [EAX]					;moves into BL the byte at the address position
 00000025  80 FB 00				CMP BL, 00								;compares this byte to 00 to test if we are at the end of the array
 00000028  74 71				JE finished								;if it is equal to 00, then jump to the finished label. 
						
 0000002A  B9 0000000C				MOV ECX, lengthof WhiteListChars		;sets up our loop with the number of elements in the whitelisted characters array
 0000002F  BE 00000000				MOV ESI, 0								;sets our initial position in the whitelisted characters array to 0
						
 00000034					lpCompareWhitelist:
 00000034  3A 9E 00000000 R				CMP BL, WhiteListChars[ESI]			;compares bl to see if it is one of the whitelisted characters
 0000003A  74 08					JE ValidChar						;if it is a valid char, jump to the valid section
 0000003C  46						INC ESI								;increment esi to the next position in the whitelisted characters array
 0000003D  E2 F5				loop lpCompareWhitelist					;decrement ecx and loop back up
																;if it is not a valid char this executes:
 0000003F  FF 45 F8				INC addASCII							;increment addASCII so we get the next byte
 00000042  EB DC				JMP lpConvertandMove					;jump back up to the top to start the loop over again
						
 00000044					ValidChar:
 00000044  88 9F 00000011 R				MOV bTemps[EDI], BL					;Moves into btemps at position edi the byte in bl to hold that byte of the number that is building
 0000004A  FF 45 F8					INC addASCII						;increment to the next position of addascii so we can see if the next char is valid
 0000004D  8B 45 F8					MOV EAX, addASCII					;moves into eax the new address of the next byte 
 00000050  8A 18					MOV BL, byte ptr [EAX]				;moves the byte into Bl 
 00000052  FF 4D F8					DEC addASCII						;change it back to the previous character
							
 00000055  B9 0000000C					MOV ECX, lengthof WhiteListChars	;adds the number of elements in whitelisted characters array into ecx for the loop
 0000005A  BE 00000000					MOV ESI, 0							;sets our initial position in the whitelisted characters array to 0
						
 0000005F						lpCompareNext:
 0000005F  3A 9E 00000000 R					CMP BL, WhiteListChars[ESI]		;This compares the next byte to see if it is whitelisted too
 00000065  74 2E						JE ValidNextChar				;if it is a valid character, jump to the valid next char section
 00000067  46							INC ESI							;increment esi if it is not valid to get to the next position in whitelisted characters
 00000068  E2 F5					loop lpCompareNext					;decrement ECX and go to the top of the current loop
							
							INVOKE ascint32, ADDR bTemps		;if it is not a valid character, then we know the number is complete and we can execute asc to int conversion
 00000074  8B 55 FC					MOV EDX, addOut						;moves the address of the output array into edx so we can reference it
 00000077  89 02					MOV [EDX], EAX						;moves the resulting EAX value into the output array at the correct position
 00000079  B9 00000004					MOV ECX, 4							;imputs 4 into ECX so we can clear our bTemps variable to prevent curruption
 0000007E						lpClearBTemp:
 0000007E  C6 81 00000011 R					MOV [bTemps + ECX], 0			;moves 0 into the slot ECX of bTemps
	   00
 00000085  E2 F7					loop  lpClearBTemp					;jump back to the top of the current loop
 00000087  83 45 FC 04					ADD addOut, 4						;adds 4 to the output address so we can get the next dword starting point
 0000008B  BF 00000000					MOV EDI, 0							;resets edi to 0 so we get a clean bTemps variable
 00000090  FF 45 F8					INC addASCII						;increments addASCII so we get the next byte in memory
 00000093  EB 8B					JMP lpConvertandMove				;jump back up to the very top of the loop 
							
 00000095					ValidNextChar:
 00000095  47						INC EDI								;increment edi so we can input in the next position in bTemps
 00000096  FF 45 F8					INC addASCII						;increment addASCII so we get the next byte in memory
 00000099  EB 85					JMP lpConvertandMove				;jump back up to the very top of the loop
							
							
 0000009B				finished:
						RET										;return back to where i was called 
 000000A1			extractDwords ENDP 

				COMMENT %
				********************************************************************************
				*Name: displayArray                                                            *
				*Purpose:                                                                      *
				*	      Intakes beginning address of dwords and converts it into the appropriate*
				*        matrix display for output and returns the address to the string 	   *
				*		 generated.															   *
				*		     			   													   *
				*Date Created: 10/24/2019                                                      *
				*Date Modified: 10/25/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword												 	           *
				*@param cols:dword												 	           *
				*@param lpStringtoHold:dword									 	           *
				*******************************************************************************%
 000000A1			displayArray PROC Near32 C uses EBX EDX EDI, lpArrayDwords:dword, rows:dword, cols:dword, lpStringtoHold:dword
					LOCAL startAddr:dword, outAddr:dword, tempNumRow:dword, tempNumCol:dword
 000000AA  8B 45 0C			MOV EAX, rows								;moves the number of rows into eax so we can check if it is a 1xM later
 000000AD  89 45 F4			MOV tempNumRow, EAX							;moves the row number into a temp variable for later
 000000B0  8B 45 10			MOV EAX, cols								;moves the number of cols into eax so we can check if it is a 1xM later
 000000B3  89 45 F0			MOV tempNumCol, EAX							;store the col number into a temp variable
 000000B6  8B 45 08			MOV EAX, lpArrayDwords						;moves into EAX the address of the output array
 000000B9  89 45 FC			MOV startAddr, EAX							;moves the address into our local variable for clarity.
 000000BC  8B 45 14			MOV EAX, lpStringtoHold						;moves into EAX the address of the array with ascii values.
 000000BF  89 45 F8			MOV outAddr, EAX							;moves the address into our local variable for clarity.

					
 000000C2  BF 00000000			MOV EDI, 0									;set the initial point into the original address to 0
 000000C7  BE 00000000			MOV ESI, 0									;set the initial point into the new address to 0
 000000CC  B9 00000001			MOV ECX, 1									;set ecx to 1 because we start with 1 col
 000000D1  8B 55 F8			MOV EDX, outAddr							;moves the address of out address to edx so we can derefrence the address
 000000D4  8B 5D FC			MOV EBX, startAddr							;moves the address of out address to edx so we can derefrence the address
					
 000000D7  C7 05 0000000C R		MOV tempNum, 09								;set the temp number to the tab character
	   00000009
 000000E1  8B DA			MOV EBX, EDX								;moves the address of out address into ebx so we can use it to put the character
 000000E3  53				PUSH EBX									;store ebx so we can have the unaffected value later
 000000E4  03 DE			ADD EBX, ESI								;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 000000E6  50				PUSH EAX									;preserve EAX so we can restore it later
 000000E7  A1 0000000C R		MOV EAX, tempNum							;move into eax the temp number which is tab
 000000EC  89 03			MOV [EBX], EAX								;moves into the location ebx points to the temp number 
 000000EE  5B				POP EBX										;restore our unaffected EBX
					getBytes EDX								;call the get bytes macro where we count the number of bytes used in the output address
 000000EF  55		     1		PUSH EBP							;preserves base register
 000000F0  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000000F2  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000000F3  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000000F4  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000000F6  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000000FB		     1		??0000:
 000000FB  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000000FF  74 03	     1			JE ??0001							;if it is jump to finished
 00000101  46		     1			INC ESI							;if not increment esi
 00000102  EB F7	     1			JMP ??0000						;jump to the top of the loop and look at the next char
 00000104		     1		??0001:		
 00000104  46		     1			INC ESI							;increment esi to include the null character in the string
 00000105  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000107  5E		     1		POP ESI								;restore original esi
 00000108  5B		     1		POP EBX								;restore original ebx
 00000109  5D		     1		POP EBP								;restore originla ebp
 0000010A  8B F0			MOV ESI, EAX								;moves into ESI the offset that the previous macro returns
 0000010C  4E				DEC ESI										;decrement ESI to take into acount the null character the macro counts for.
					
 0000010D  50				PUSH EAX									;preserve EAX so we can restore it later
 0000010E  8B 45 0C			MOV EAX, rows								;moves into eax the number of rows we have
 00000111  03 45 10			ADD EAX, cols								;adds the number of cols into eax so we can test if we have a 1x1 matrix
 00000114  83 F8 02			CMP EAX, 2									;compares eax to 2 to check if it is a 1x1  (1 + 1 = 2)
 00000117  0F 84 0000013E		JE oneByone									;if it detects a 1x1 matrix, then jump to the proper section.
 0000011D  58				POP EAX										;otherwise, restore EAX so we can use the original value.
					
 0000011E				lpConvertToASCII:
 0000011E  83 7D 0C 00				CMP rows, 0								;check to see if we have used up the allowed number of rows
 00000122  0F 84 0000012E			JE finished								;if it is equal to 0, jump to the finished section
 00000128  8B 5D FC				MOV EBX, startAddr						;moves the address of out address to edx so we can derefrence the address
 0000012B  8B 04 1F				MOV EAX, [EBX + EDI]					;moves into eax the address of ebx + edi so we can get the correct number to convert
 0000012E  A3 0000000C R			MOV tempNum, EAX						;stores the number obtained in EAX into tempNum so we can use it in invoke, cant use eax
 00000133  8B DA				MOV EBX, EDX							;moves into ebx, the adress of the outaddress
 00000135  53					PUSH EBX								;stores our ebx variable so we can get it back later
 00000136  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
						INVOKE intasc32, EBX, tempNum			;calls intasc32 to convert the number into ascii characters and place into the address ebx points to
 00000144  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
 00000145  83 C7 04				ADD EDI, 4								;add 4 to edi so we get the next dword in the numbers to pull from.
						
 00000148  50					PUSH EAX								;store our EAX so we can get it back 
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000149  55		     1		PUSH EBP							;preserves base register
 0000014A  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 0000014C  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 0000014D  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000014E  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000150  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000155		     1		??0002:
 00000155  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000159  74 03	     1			JE ??0003							;if it is jump to finished
 0000015B  46		     1			INC ESI							;if not increment esi
 0000015C  EB F7	     1			JMP ??0002						;jump to the top of the loop and look at the next char
 0000015E		     1		??0003:		
 0000015E  46		     1			INC ESI							;increment esi to include the null character in the string
 0000015F  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000161  5E		     1		POP ESI								;restore original esi
 00000162  5B		     1		POP EBX								;restore original ebx
 00000163  5D		     1		POP EBP								;restore originla ebp
 00000164  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 00000166  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 00000167  58					POP EAX									;restore our original eax
						
 00000168  3B 4D 10				CMP ECX, cols							;compare ecx to the number of cols to check if we are at the end of the row
 0000016B  74 72				JE NoComma								;if there is no more numbers to the row, the jump to the no comma section 
						
 0000016D  C7 05 0000000C R			MOV tempNum, 44							;moves the comma ascii value into temp num
	   0000002C
 00000177  8B DA				MOV EBX, EDX							;moves into ebx, the adress of the outaddress
 00000179  53					PUSH EBX								;stores our ebx variable so we can get it back later
 0000017A  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 0000017C  50					PUSH EAX								;store our EAX so we can get it back 
 0000017D  A1 0000000C R			MOV EAX, tempNum						;moves into EAX the value temp num so we can but it into place without calling mem to mem
 00000182  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value of eax, which is temp num
 00000184  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000185  55		     1		PUSH EBP							;preserves base register
 00000186  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000188  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000189  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000018A  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 0000018C  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000191		     1		??0004:
 00000191  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000195  74 03	     1			JE ??0005							;if it is jump to finished
 00000197  46		     1			INC ESI							;if not increment esi
 00000198  EB F7	     1			JMP ??0004						;jump to the top of the loop and look at the next char
 0000019A		     1		??0005:		
 0000019A  46		     1			INC ESI							;increment esi to include the null character in the string
 0000019B  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 0000019D  5E		     1		POP ESI								;restore original esi
 0000019E  5B		     1		POP EBX								;restore original ebx
 0000019F  5D		     1		POP EBP								;restore originla ebp
 000001A0  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 000001A2  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 000001A3  C7 05 0000000C R			MOV tempNum, 32							;moves the space ascii value into temp num
	   00000020
 000001AD  8B DA				MOV EBX, EDX							;moves the address in edx into ebx so we can use it 
 000001AF  53					PUSH EBX								;stores our ebx variable so we can get it back later
 000001B0  03 DE				ADD EBX, ESI							;adds into ebx the offset of ebx esi, so we get the correct byte to place a character
 000001B2  A1 0000000C R			MOV EAX, tempNum						;moves into EAX the value temp num so we can but it into place without calling mem to mem
 000001B7  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value of eax, which is temp num
 000001B9  5B					POP EBX									;restore our original ebx that is unaffected by the addition earlier.
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 000001BA  55		     1		PUSH EBP							;preserves base register
 000001BB  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001BD  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000001BE  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000001BF  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000001C1  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000001C6		     1		??0006:
 000001C6  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000001CA  74 03	     1			JE ??0007							;if it is jump to finished
 000001CC  46		     1			INC ESI							;if not increment esi
 000001CD  EB F7	     1			JMP ??0006						;jump to the top of the loop and look at the next char
 000001CF		     1		??0007:		
 000001CF  46		     1			INC ESI							;increment esi to include the null character in the string
 000001D0  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 000001D2  5E		     1		POP ESI								;restore original esi
 000001D3  5B		     1		POP EBX								;restore original ebx
 000001D4  5D		     1		POP EBP								;restore originla ebp
 000001D5  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 000001D7  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 000001D8  58					POP EAX									;restore our original eax
						
 000001D9  41					INC ECX									;increments we we know we are on the next col
 000001DA  E9 FFFFFF3F				JMP lpConvertToASCII					;jumps back to the top
						
 000001DF				NoComma:
 000001DF  B9 00000001				MOV ECX, 1								;reset the col value back to 1
 000001E4  FF 4D 0C				DEC rows								;decrement the number of rows so we can terminate this loop eventually
 000001E7  C7 05 0000000C R			MOV tempNum, 10							;moves the new line character into tempNum
	   0000000A
 000001F1  53					PUSH EBX								;pushes ebx to the stack so we can have the unaffected value later
 000001F2  03 DE				ADD EBX, ESI							;add the offset esi into ebx so we point to the right byte to place
 000001F4  50					PUSH EAX								;push eax to store it
 000001F5  A1 0000000C R			MOV EAX, tempNum						;moves the new line char into eax (avoid mem to mem)
 000001FA  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value eax which is new line
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 000001FC  55		     1		PUSH EBP							;preserves base register
 000001FD  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001FF  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000200  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000201  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000203  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000208		     1		??0008:
 00000208  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 0000020C  74 03	     1			JE ??0009							;if it is jump to finished
 0000020E  46		     1			INC ESI							;if not increment esi
 0000020F  EB F7	     1			JMP ??0008						;jump to the top of the loop and look at the next char
 00000211		     1		??0009:		
 00000211  46		     1			INC ESI							;increment esi to include the null character in the string
 00000212  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000214  5E		     1		POP ESI								;restore original esi
 00000215  5B		     1		POP EBX								;restore original ebx
 00000216  5D		     1		POP EBP								;restore originla ebp
 00000217  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 00000219  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 0000021A  58					POP EAX									;restore original eax
 0000021B  5B					POP EBX									;restore original ebx
 0000021C  C7 05 0000000C R			MOV tempNum, 09							;moves the tab character into tempNum
	   00000009
 00000226  53					PUSH EBX								;pushes ebx to the stack so we can have the unaffected value later
 00000227  03 DE				ADD EBX, ESI							;add the offset esi into ebx so we point to the right byte to place
 00000229  50					PUSH EAX								;push eax to store it
 0000022A  A1 0000000C R			MOV EAX, tempNum						;moves the new line char into eax (avoid mem to mem)
 0000022F  89 03				MOV [EBX], EAX							;moves into the location ebx points to the value eax which is new line
						getBytes EDX							;call the get bytes macro where we count the number of bytes used in the output address
 00000231  55		     1		PUSH EBP							;preserves base register
 00000232  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000234  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000235  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000236  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000238  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 0000023D		     1		??000A:
 0000023D  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000241  74 03	     1			JE ??000B							;if it is jump to finished
 00000243  46		     1			INC ESI							;if not increment esi
 00000244  EB F7	     1			JMP ??000A						;jump to the top of the loop and look at the next char
 00000246		     1		??000B:		
 00000246  46		     1			INC ESI							;increment esi to include the null character in the string
 00000247  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000249  5E		     1		POP ESI								;restore original esi
 0000024A  5B		     1		POP EBX								;restore original ebx
 0000024B  5D		     1		POP EBP								;restore originla ebp
 0000024C  8B F0				MOV ESI, EAX							;moves into ESI the offset that the previous macro returns
 0000024E  4E					DEC ESI									;decrement ESI to take into acount the null character the macro counts for.
 0000024F  58					POP EAX									;restore original eax
 00000250  5B					POP EBX									;restore original ebx
 00000251  E9 FFFFFEC8				JMP lpConvertToASCII					;jump back to the top of the loop
						
 00000256				finished:
						RET
						
 0000025B				oneByone:
 0000025B  8B 5D FC				MOV EBX, startAddr						;moves the starting address into ebx
 0000025E  8B 03				MOV EAX, [EBX]							;moves the value ebx points to into eax
 00000260  A3 0000000C R			MOV tempNum, EAX						;moves eax into the temp num variable
 00000265  8B DA				MOV EBX, EDX							;moves the eaddress of edx into ebx so we can modify it
 00000267  53					PUSH EBX								;pushes ebx to store it
 00000268  03 DE				ADD EBX, ESI							;adds the offset esi into ebx so we point to the right place
						INVOKE intasc32, EBX, tempNum			;convert the number into the ascii format and put into where ebx points
 00000276  5B					POP EBX									;restore ebx
 00000277  EB DD				JMP finished							;jump to the finished section

 00000279			displayArray ENDP

				COMMENT %
				********************************************************************************
				*Name: sortedArray                                                             *
				*Purpose:                                                                      *
				*	           This method accepts the address of a dword array and the number *
				*		of dwords in that array. It returns TRUE (1 in AL register) if the array*
				*		is in ascending sorted order, and 0 otherwise. 						   *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/26/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param numElts:dword												 	       *
				*@return Boolean:Byte												 	       *
				*******************************************************************************%
 00000279			sortedArray PROC Near32 C uses EBX ECX EDX EDI, lpArrayDwords:dword, numElts:dword
					LOCAL bool:byte
					
 00000283  8B 4D 0C			MOV ECX, numElts							;Moves the number of elements into othe ecx register so we can track our loop
 00000286  49				DEC ECX										;decrements the number of elements so dont grab outside of your area
 00000287  BF 00000000			MOV EDI, 0									;sets initial offset to 0
 0000028C  8B 45 08			MOV EAX, lpArrayDwords						;move the address into EAX so we can reference it
					
 0000028F				lpCheckAscending:
 0000028F  8B 1C 07				MOV EBX, [EAX + EDI]					;Move the value located at eax + edi into ebx
 00000292  83 C7 04				ADD EDI, 4								;increment our offset by 4 to get the next dword
 00000295  8B 14 07				MOV EDX, [EAX + EDI]					;Move the value located at eax + edi into edx
 00000298  3B DA				CMP EBX, EDX							;compare the two registers to see if ebx is less than or equal to edx
 0000029A  7E 0F				JLE LessThan							;if it is jump to appropriate section
 0000029C  C6 45 FF 00				MOV bool, 0								;if it is not, we can move 0 into our bool byte and assume it is not in sorted ascending order
 000002A0  EB 00				JMP done								;jump to done
						
 000002A2				done:
 000002A2  8A 45 FF				MOV AL, bool							;moves into AL the result of the loop above
						RET										;returns back to where this method was called from
						
 000002AB				LessThan:
 000002AB  C6 45 FF 01				MOV bool, 1								;move a 1 into our byte 
 000002AF  49					DEC ECX									;decrement our number of elements we have left
 000002B0  83 F9 00				CMP ECX, 0								;compare to 0 to see if we are at the end of our loop 
 000002B3  74 ED				JE done									;if it equals 0, then jump to done
 000002B5  EB D8				JMP lpCheckAscending					;if not, then jump back to the top of the loop

 000002B7			sortedArray ENDP

				COMMENT %
				********************************************************************************
				*Name: sumUpArray                                                              *
				*Purpose:                                                                      *
				*	       Adds up all the values in the matrix, and return the answer		   *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/26/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword													 	       *
				*@param cols:dword 													 	       *
				*@return sum:dword															   *
				*******************************************************************************%
 000002B7			sumUpArray PROC Near32 C uses EBX ECX EDI, lpArrayDwords:dword, rows:dword, cols:dword
					LOCAL sum:dword
					
 000002C0  8B 45 0C			MOV EAX, rows								;moves the number of rows into eax so we can multiply it to get numElements
 000002C3  F7 65 10			MUL cols									;Multiplies EAX by the number of cols
 000002C6  8B C8			MOV ECX, EAX								;stores the number of elements 
 000002C8  8B 45 08			MOV EAX, lpArrayDwords						;move the address into EAX so we can reference it
 000002CB  BF 00000000			MOV EDI, 0									;set the intital offset to 0
 000002D0  C7 45 FC			MOV sum, 0									;set the intital sum to 0
	   00000000
					
 000002D7				lpSumArray:
 000002D7  8B 1C 07				MOV EBX, [EAX + EDI]					;moves into ebx, the value located at eax offset edi
 000002DA  01 5D FC				ADD sum, EBX							;add the value into the sum
 000002DD  83 C7 04				ADD EDI, 4								;add 4 to edi so we get the next number in the sequence
 000002E0  E2 F5			loop lpSumArray								;decrement ecx and jump back to the top
					
 000002E2  8B 45 FC			MOV EAX, sum								;move our sum into eax for return
					RET											;return
					
 000002EA			sumUpArray ENDP

				COMMENT %
				********************************************************************************
				*Name: smallestValue                                                           *
				*Purpose:                                                                      *
				*	       Determine the smallest Value in the array and return the answer     *
				*																			   *
				*Date Created: 10/26/2019                                                      *
				*Date Modified: 10/26/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword													 	       *
				*@param cols:dword 													 	       *
				*@return smallestVal:dword													   *
				*******************************************************************************%
 000002EA			smallestValue PROC Near32 C uses EBX ECX EDI, lpArrayDwords:dword, rows:dword, cols:dword
					LOCAL smallestVal:dword
						
 000002F3  BF 00000000			MOV EDI, 0									;set the intital offset to 0
 000002F8  8B 45 0C			MOV EAX, rows								;moves the number of rows into eax so we can multiply it to get numElements
 000002FB  F7 65 10			MUL cols									;Multiplies EAX by the number of cols
 000002FE  8B C8			MOV ECX, EAX								;stores the number of elements 
 00000300  8B 45 08			MOV EAX, lpArrayDwords						;move the address into EAX so we can reference it
 00000303  83 F9 01			CMP ECX, 1
 00000306  74 2D			JE oneByone
 00000308  49				DEC ECX										;decrement ECX so we work with n-1 elements

					
 00000309  8B 1C 07			MOV EBX, [EAX + EDI]						;moves into ebx the first value
 0000030C  89 5D FC			MOV smallestVal, EBX						;stores the first value as the smallest one
					
 0000030F				lpGetSmallest:
 0000030F  83 C7 04				ADD EDI, 4								;increments the offset by 4 so we get the next dword
 00000312  8B 1C 07				MOV EBX, [EAX + EDI]					;moves into ebx the value located at that location
 00000315  3B 5D FC				CMP EBX, smallestVal					;compare that value to the current smallest number
 00000318  7C 08				JL newSmallest							;if the register is less than the current smallest value jump to new smallest
 0000031A  49					DEC ECX									;decrement ecx so we can terminate the loop eventually 
 0000031B  83 F9 00				CMP ECX, 0								;compares ecx to 0, so we check to see if the loop is done
 0000031E  74 0D				JE DoneLoop								;if it is 0 then jump to done loop
 00000320  EB ED				JMP lpGetSmallest						;if it is not then jump back to the top
						
 00000322				newSmallest:
 00000322  89 5D FC				MOV smallestVal, EBX					;moves the value currently in ebx into our smallest value variable
 00000325  49					DEC ECX									;decrement ecx so we can terminate the loop eventually 
 00000326  83 F9 00				CMP ECX, 0								;compares ecx to 0, so we check to see if the loop is done
 00000329  74 02				JE DoneLoop								;if it is 0 then jump to done loop
 0000032B  EB E2				JMP lpGetSmallest						;if it is not then jump back to the top
						
 0000032D				DoneLoop:
 0000032D  8B 45 FC				MOV EAX, smallestVal					;moves into eax the value in smallest value so we can return it
						RET										;return
						
 00000335				oneByone:
 00000335  8B 1C 07				MOV EBX, [EAX + EDI]					;moves into ebx the first value
 00000338  89 5D FC				MOV smallestVal, EBX					;stores the first value as the smallest one
 0000033B  EB F0				JMP DoneLoop
							

 0000033D			smallestValue ENDP
				END
Microsoft (R) Macro Assembler Version 6.11		    10/26/19 19:30:28
proj4procs.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

getBytes . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000011 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000033D DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
displayArray . . . . . . . . . .	P Near	 000000A1 _TEXT	Length= 000001D8 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  lpStringtoHold . . . . . . . .	DWord	 bp + 00000014
  startAddr  . . . . . . . . . .	DWord	 bp - 00000004
  outAddr  . . . . . . . . . . .	DWord	 bp - 00000008
  tempNumRow . . . . . . . . . .	DWord	 bp - 0000000C
  tempNumCol . . . . . . . . . .	DWord	 bp - 00000010
  ??0000 . . . . . . . . . . . .	L Near	 000000FB _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 00000104 _TEXT	
  lpConvertToASCII . . . . . . .	L Near	 0000011E _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000155 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 0000015E _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 00000191 _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 0000019A _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 000001C6 _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 000001CF _TEXT	
  NoComma  . . . . . . . . . . .	L Near	 000001DF _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 00000208 _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 00000211 _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 0000023D _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 00000246 _TEXT	
  finished . . . . . . . . . . .	L Near	 00000256 _TEXT	
  oneByone . . . . . . . . . . .	L Near	 0000025B _TEXT	
extractDwords  . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000A1 Public C
  StringofChars  . . . . . . . .	DWord	 bp + 00000008
  ArrayDwords  . . . . . . . . .	DWord	 bp + 0000000C
  addOut . . . . . . . . . . . .	DWord	 bp - 00000004
  addASCII . . . . . . . . . . .	DWord	 bp - 00000008
  lpConvertandMove . . . . . . .	L Near	 00000020 _TEXT	
  lpCompareWhitelist . . . . . .	L Near	 00000034 _TEXT	
  ValidChar  . . . . . . . . . .	L Near	 00000044 _TEXT	
  lpCompareNext  . . . . . . . .	L Near	 0000005F _TEXT	
  lpClearBTemp . . . . . . . . .	L Near	 0000007E _TEXT	
  ValidNextChar  . . . . . . . .	L Near	 00000095 _TEXT	
  finished . . . . . . . . . . .	L Near	 0000009B _TEXT	
intasc32Comma  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
smallestValue  . . . . . . . . .	P Near	 000002EA _TEXT	Length= 00000053 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  smallestVal  . . . . . . . . .	DWord	 bp - 00000004
  lpGetSmallest  . . . . . . . .	L Near	 0000030F _TEXT	
  newSmallest  . . . . . . . . .	L Near	 00000322 _TEXT	
  DoneLoop . . . . . . . . . . .	L Near	 0000032D _TEXT	
  oneByone . . . . . . . . . . .	L Near	 00000335 _TEXT	
sortedArray  . . . . . . . . . .	P Near	 00000279 _TEXT	Length= 0000003E Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  numElts  . . . . . . . . . . .	DWord	 bp + 0000000C
  bool . . . . . . . . . . . . .	Byte	 bp - 00000001
  lpCheckAscending . . . . . . .	L Near	 0000028F _TEXT	
  done . . . . . . . . . . . . .	L Near	 000002A2 _TEXT	
  LessThan . . . . . . . . . . .	L Near	 000002AB _TEXT	
sumUpArray . . . . . . . . . . .	P Near	 000002B7 _TEXT	Length= 00000033 Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  sum  . . . . . . . . . . . . .	DWord	 bp - 00000004
  lpSumArray . . . . . . . . . .	L Near	 000002D7 _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
WhiteListChars . . . . . . . . .	Byte	 00000000 _DATA	
bNumBytes  . . . . . . . . . . .	Byte	 0000000C _DATA	
bTemps . . . . . . . . . . . . .	Byte	 00000011 _DATA	
iColCount  . . . . . . . . . . .	DWord	 0000000D _DATA	
tempNum  . . . . . . . . . . . .	DWord	 0000000C _DATA	

	   0 Warnings
	   0 Errors
