Microsoft (R) Macro Assembler Version 6.11		    10/25/19 00:53:56
proj4procs.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: proj4procs.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:          Proj3
				;*  Date:         11/02/2019
				;*  Purpose:      This handles the manipulation of matrices. 
				;******************************************************************************************

					.486						;This tells assembler to generate 32-bit code

					.model flat					;This tells assembler that all addresses are real addresses

					.stack 100h					;EVERY program needs to have a stack allocated

				;******************************************************************************************

				;  List all necessary prototypes for methods to be called here

					ascint32 PROTO NEAR32 stdcall, lpStringToConvert:dword  				;This converts ASCII characters to the dword value
					intasc32Comma proto Near32 stdcall, lpStringToHold:dword, dval:dword
					intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword
				;******************************************************************************************
				COMMENT %

				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  *
				*                                                                            *
				*Date Created: 10/02/2019                                                    *
				*Date Modified: 10/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytes MACRO String:REQ
					LOCAL stLoop
					LOCAL done
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
 00000000			.DATA

 00000000 30 31 32 33 34		WhiteListChars byte 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 45, 43		;set of whitelisted characters, 0 1 2 3 4 5 6 7 8 9 + - 
	   35 36 37 38 39
	   2D 2B
 0000000C				tempNum dword 0 dup (12)
 0000000C 00				bNumBytes byte ?
 0000000D 00000000			iColCount dword 0
 00000011				bTemps byte 0 dup(?)													;memory to hold the number that is built in extractDwords

				;******************************************************************************************
 00000000			.CODE

				COMMENT %
				********************************************************************************
				*Name: extractDwords                                                           *
				*Purpose:                                                                      *
				*	     This method takes in two addresses, one with ascii characters and one *
				*        where the converted numbers will go. It translates the ascii character*
				*		 to the dword value and stores into the output location    			   *
				*Date Created: 10/23/2019                                                      *
				*Date Modified: 10/23/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param StringofChars:dword                                                    *
				*@param ArrayDwords:dword												 	   *
				*******************************************************************************%
 00000000			extractDwords PROC Near32 C uses EBX ECX EDX EDI , StringofChars:dword, ArrayDwords:dword
					LOCAL addOut:dword, addASCII:dword			;sets up our stack frame and declares our local variables. 
					
 0000000A  8B 45 0C			MOV EAX, ArrayDwords						;moves into EAX the address of the output array
 0000000D  89 45 FC			MOV addOut, EAX								;moves the address into our local variable for clarity.
 00000010  8B 45 08			MOV EAX, StringofChars						;moves into EAX the address of the array with ascii values.
 00000013  89 45 F8			MOV addASCII, EAX							;moves the address into our local variable for clarity.
					
 00000016  BB 00000000			MOV EBX, 0									;set EBX to 0 to avoid calculation error
 0000001B  BF 00000000			MOV EDI, 0									;sets our initial point in bTemps to the first place
					
 00000020				lpConvertandMove:	
 00000020  8B 45 F8				MOV EAX, addASCII						;moves the address of the ascii values into eax so we can reference it
 00000023  8A 18				MOV BL, byte ptr [EAX]					;moves into BL the byte at the address position
 00000025  80 FB 00				CMP BL, 00								;compares this byte to 00 to test if we are at the end of the array
 00000028  74 71				JE finished								;if it is equal to 00, then jump to the finished label. 
						
 0000002A  B9 0000000C				MOV ECX, lengthof WhiteListChars		;sets up our loop with the number of elements in the whitelisted characters array
 0000002F  BE 00000000				MOV ESI, 0								;sets our initial position in the whitelisted characters array to 0
						
 00000034					lpCompareWhitelist:
 00000034  3A 9E 00000000 R				CMP BL, WhiteListChars[ESI]			;compares bl to see if it is one of the whitelisted characters
 0000003A  74 08					JE ValidChar						;if it is a valid char, jump to the valid section
 0000003C  46						INC ESI								;increment esi to the next position in the whitelisted characters array
 0000003D  E2 F5				loop lpCompareWhitelist					;decrement ecx and loop back up
																;if it is not a valid char this executes:
 0000003F  FF 45 F8				INC addASCII							;increment addASCII so we get the next byte
 00000042  EB DC				JMP lpConvertandMove					;jump back up to the top to start the loop over again
						
 00000044					ValidChar:
 00000044  88 9F 00000011 R				MOV bTemps[EDI], BL					;Moves into btemps at position edi the byte in bl to hold that byte of the number that is building
 0000004A  FF 45 F8					INC addASCII						;increment to the next position of addascii so we can see if the next char is valid
 0000004D  8B 45 F8					MOV EAX, addASCII					;moves into eax the new address of the next byte 
 00000050  8A 18					MOV BL, byte ptr [EAX]				;moves the byte into Bl 
 00000052  FF 4D F8					DEC addASCII						;change it back to the previous character
							
 00000055  B9 0000000C					MOV ECX, lengthof WhiteListChars	;adds the number of elements in whitelisted characters array into ecx for the loop
 0000005A  BE 00000000					MOV ESI, 0							;sets our initial position in the whitelisted characters array to 0
						
 0000005F						lpCompareNext:
 0000005F  3A 9E 00000000 R					CMP BL, WhiteListChars[ESI]		;This compares the next byte to see if it is whitelisted too
 00000065  74 2E						JE ValidNextChar				;if it is a valid character, jump to the valid next char section
 00000067  46							INC ESI							;increment esi if it is not valid to get to the next position in whitelisted characters
 00000068  E2 F5					loop lpCompareNext					;decrement ECX and go to the top of the current loop
							
							INVOKE ascint32, ADDR bTemps		;if it is not a valid character, then we know the number is complete and we can execute asc to int conversion
 00000074  8B 55 FC					MOV EDX, addOut						;moves the address of the output array into edx so we can reference it
 00000077  89 02					MOV [EDX], EAX						;moves the resulting EAX value into the output array at the correct position
 00000079  B9 00000004					MOV ECX, 4							;imputs 4 into ECX so we can clear our bTemps variable to prevent curruption
 0000007E						lpClearBTemp:
 0000007E  C6 81 00000011 R					MOV [bTemps + ECX], 0			;moves 0 into the slot ECX of bTemps
	   00
 00000085  E2 F7					loop  lpClearBTemp					;jump back to the top of the current loop
 00000087  83 45 FC 04					ADD addOut, 4						;adds 4 to the output address so we can get the next dword starting point
 0000008B  BF 00000000					MOV EDI, 0							;resets edi to 0 so we get a clean bTemps variable
 00000090  FF 45 F8					INC addASCII						;increments addASCII so we get the next byte in memory
 00000093  EB 8B					JMP lpConvertandMove				;jump back up to the very top of the loop 
							
 00000095					ValidNextChar:
 00000095  47						INC EDI								;increment edi so we can input in the next position in bTemps
 00000096  FF 45 F8					INC addASCII						;increment addASCII so we get the next byte in memory
 00000099  EB 85					JMP lpConvertandMove				;jump back up to the very top of the loop
							
							
 0000009B				finished:
						RET										;return back to where i was called 
 000000A1			extractDwords ENDP 

				COMMENT %
				********************************************************************************
				*Name: displayArray                                                            *
				*Purpose:                                                                      *
				*	      *
				*        *
				*		     			   *
				*Date Created: 10/24/2019                                                      *
				*Date Modified: 10/24/2019                                                     *
				*                                                                              *
				*                                                                              *
				*@param lpArrayDwords:dword                                                    *
				*@param rows:dword												 	           *
				*@param cols:dword												 	           *
				*@param lpStringtoHold:dword									 	           *
				*******************************************************************************%
 000000A1			displayArray PROC Near32 C uses EBX EDX EDI, lpArrayDwords:dword, rows:dword, cols:dword, lpStringtoHold:dword
					LOCAL startAddr:dword, outAddr:dword
						
 000000AA  8B 45 08			MOV EAX, lpArrayDwords						;moves into EAX the address of the output array
 000000AD  89 45 FC			MOV startAddr, EAX							;moves the address into our local variable for clarity.
 000000B0  8B 45 14			MOV EAX, lpStringtoHold						;moves into EAX the address of the array with ascii values.
 000000B3  89 45 F8			MOV outAddr, EAX							;moves the address into our local variable for clarity.
					
 000000B6  BF 00000000			MOV EDI, 0
 000000BB  BE 00000000			MOV ESI, 0
 000000C0  B9 00000001			MOV ECX, 1
 000000C5  8B 55 F8			MOV EDX, outAddr
 000000C8  8B 5D FC			MOV EBX, startAddr
					
 000000CB  C7 05 0000000C R		MOV tempNum, 09
	   00000009
 000000D5  8B DA			MOV EBX, EDX
 000000D7  53				PUSH EBX
 000000D8  03 DE			ADD EBX, ESI
 000000DA  50				PUSH EAX
 000000DB  A1 0000000C R		MOV EAX, tempNum
 000000E0  89 03			MOV [EBX], EAX
 000000E2  5B				POP EBX
					getBytes EDX
 000000E3  55		     1		PUSH EBP							;preserves base register
 000000E4  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000000E6  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000000E7  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000000E8  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000000EA  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000000EF		     1		??0000:
 000000EF  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000000F3  74 03	     1			JE ??0001							;if it is jump to finished
 000000F5  46		     1			INC ESI							;if not increment esi
 000000F6  EB F7	     1			JMP ??0000						;jump to the top of the loop and look at the next char
 000000F8		     1		??0001:		
 000000F8  46		     1			INC ESI							;increment esi to include the null character in the string
 000000F9  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 000000FB  5E		     1		POP ESI								;restore original esi
 000000FC  5B		     1		POP EBX								;restore original ebx
 000000FD  5D		     1		POP EBP								;restore originla ebp
 000000FE  8B F0			MOV ESI, EAX
 00000100  4E				DEC ESI
					
 00000101  50				PUSH EAX
 00000102  8B 45 0C			MOV EAX, rows
 00000105  03 45 10			ADD EAX, cols
 00000108  83 F8 02			CMP EAX, 2
 0000010B  0F 84 0000015C		JE oneByone
 00000111  58				POP EAX
					
 00000112				lpConvertToASCII:
 00000112  83 7D 0C 00				CMP rows, 0
 00000116  0F 84 0000012E			JE finished
 0000011C  8B 5D FC				MOV EBX, startAddr
 0000011F  8B 04 1F				MOV EAX, [EBX + EDI]
 00000122  A3 0000000C R			MOV tempNum, EAX
 00000127  8B DA				MOV EBX, EDX
 00000129  53					PUSH EBX
 0000012A  03 DE				ADD EBX, ESI
						INVOKE intasc32, EBX, tempNum	
 00000138  5B					POP EBX
 00000139  83 C7 04				ADD EDI, 4
						
 0000013C  50					PUSH EAX
						getBytes EDX
 0000013D  55		     1		PUSH EBP							;preserves base register
 0000013E  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000140  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000141  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 00000142  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000144  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000149		     1		??0002:
 00000149  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 0000014D  74 03	     1			JE ??0003							;if it is jump to finished
 0000014F  46		     1			INC ESI							;if not increment esi
 00000150  EB F7	     1			JMP ??0002						;jump to the top of the loop and look at the next char
 00000152		     1		??0003:		
 00000152  46		     1			INC ESI							;increment esi to include the null character in the string
 00000153  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000155  5E		     1		POP ESI								;restore original esi
 00000156  5B		     1		POP EBX								;restore original ebx
 00000157  5D		     1		POP EBP								;restore originla ebp
 00000158  8B F0				MOV ESI, EAX
 0000015A  4E					DEC ESI
 0000015B  58					POP EAX
						
 0000015C  3B 4D 10				CMP ECX, cols
 0000015F  74 72				JE NoComma
						
 00000161  C7 05 0000000C R			MOV tempNum, 44
	   0000002C
 0000016B  8B DA				MOV EBX, EDX
 0000016D  53					PUSH EBX
 0000016E  03 DE				ADD EBX, ESI
 00000170  50					PUSH EAX
 00000171  A1 0000000C R			MOV EAX, tempNum
 00000176  89 03				MOV [EBX], EAX
 00000178  5B					POP EBX
						getBytes EDX
 00000179  55		     1		PUSH EBP							;preserves base register
 0000017A  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 0000017C  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 0000017D  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000017E  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 00000180  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000185		     1		??0004:
 00000185  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000189  74 03	     1			JE ??0005							;if it is jump to finished
 0000018B  46		     1			INC ESI							;if not increment esi
 0000018C  EB F7	     1			JMP ??0004						;jump to the top of the loop and look at the next char
 0000018E		     1		??0005:		
 0000018E  46		     1			INC ESI							;increment esi to include the null character in the string
 0000018F  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000191  5E		     1		POP ESI								;restore original esi
 00000192  5B		     1		POP EBX								;restore original ebx
 00000193  5D		     1		POP EBP								;restore originla ebp
 00000194  8B F0				MOV ESI, EAX
 00000196  4E					DEC ESI
 00000197  C7 05 0000000C R			MOV tempNum, 32
	   00000020
 000001A1  8B DA				MOV EBX, EDX
 000001A3  53					PUSH EBX
 000001A4  03 DE				ADD EBX, ESI
 000001A6  A1 0000000C R			MOV EAX, tempNum
 000001AB  89 03				MOV [EBX], EAX
 000001AD  5B					POP EBX
						getBytes EDX
 000001AE  55		     1		PUSH EBP							;preserves base register
 000001AF  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001B1  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000001B2  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000001B3  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000001B5  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000001BA		     1		??0006:
 000001BA  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 000001BE  74 03	     1			JE ??0007							;if it is jump to finished
 000001C0  46		     1			INC ESI							;if not increment esi
 000001C1  EB F7	     1			JMP ??0006						;jump to the top of the loop and look at the next char
 000001C3		     1		??0007:		
 000001C3  46		     1			INC ESI							;increment esi to include the null character in the string
 000001C4  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 000001C6  5E		     1		POP ESI								;restore original esi
 000001C7  5B		     1		POP EBX								;restore original ebx
 000001C8  5D		     1		POP EBP								;restore originla ebp
 000001C9  8B F0				MOV ESI, EAX
 000001CB  4E					DEC ESI
 000001CC  58					POP EAX
						
 000001CD  41					INC ECX
 000001CE  E9 FFFFFF3F				JMP lpConvertToASCII
						
 000001D3				NoComma:
 000001D3  B9 00000001				MOV ECX, 1
 000001D8  FF 4D 0C				DEC rows
 000001DB  C7 05 0000000C R			MOV tempNum, 10
	   0000000A
 000001E5  53					PUSH EBX
 000001E6  03 DE				ADD EBX, ESI
 000001E8  50					PUSH EAX
 000001E9  A1 0000000C R			MOV EAX, tempNum
 000001EE  89 03				MOV [EBX], EAX
						getBytes EDX
 000001F0  55		     1		PUSH EBP							;preserves base register
 000001F1  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 000001F3  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 000001F4  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 000001F5  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 000001F7  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 000001FC		     1		??0008:
 000001FC  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000200  74 03	     1			JE ??0009							;if it is jump to finished
 00000202  46		     1			INC ESI							;if not increment esi
 00000203  EB F7	     1			JMP ??0008						;jump to the top of the loop and look at the next char
 00000205		     1		??0009:		
 00000205  46		     1			INC ESI							;increment esi to include the null character in the string
 00000206  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 00000208  5E		     1		POP ESI								;restore original esi
 00000209  5B		     1		POP EBX								;restore original ebx
 0000020A  5D		     1		POP EBP								;restore originla ebp
 0000020B  8B F0				MOV ESI, EAX
 0000020D  4E					DEC ESI
 0000020E  58					POP EAX
 0000020F  5B					POP EBX
 00000210  C7 05 0000000C R			MOV tempNum, 09
	   00000009
 0000021A  53					PUSH EBX
 0000021B  03 DE				ADD EBX, ESI
 0000021D  50					PUSH EAX
 0000021E  A1 0000000C R			MOV EAX, tempNum
 00000223  89 03				MOV [EBX], EAX
						getBytes EDX
 00000225  55		     1		PUSH EBP							;preserves base register
 00000226  8B EC	     1		MOV EBP, ESP						;sets a new stack frame
 00000228  53		     1		PUSH EBX							;pushes EBX to the stack to store this
 00000229  56		     1		PUSH ESI							;pushes ESI to the stack to preseve
 0000022A  8B DA	     1		MOV EBX, EDX						;moves into ebx the first val in the stack that we are going to use
 0000022C  BE 00000000	     1		MOV ESI, 0							;sets the initial point to 0
 00000231		     1		??000A:
 00000231  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
 00000235  74 03	     1			JE ??000B							;if it is jump to finished
 00000237  46		     1			INC ESI							;if not increment esi
 00000238  EB F7	     1			JMP ??000A						;jump to the top of the loop and look at the next char
 0000023A		     1		??000B:		
 0000023A  46		     1			INC ESI							;increment esi to include the null character in the string
 0000023B  8B C6	     1			MOV EAX, ESI					;move the value of esi into eax for proper output and return
 0000023D  5E		     1		POP ESI								;restore original esi
 0000023E  5B		     1		POP EBX								;restore original ebx
 0000023F  5D		     1		POP EBP								;restore originla ebp
 00000240  8B F0				MOV ESI, EAX
 00000242  4E					DEC ESI
 00000243  58					POP EAX
 00000244  5B					POP EBX
 00000245  E9 FFFFFEC8				JMP lpConvertToASCII
						
 0000024A				finished:
 0000024A  C7 05 0000000C R			MOV tempNum, 00
	   00000000
 00000254  53					PUSH EBX
 00000255  03 DE				ADD EBX, ESI
 00000257  83 EB 05				SUB EBX, 5
 0000025A  50					PUSH EAX
 0000025B  A1 0000000C R			MOV EAX, tempNum
 00000260  89 03				MOV [EBX], EAX
 00000262  8B 45 F8				MOV EAX, outAddr
						
 00000265  89 45 14				MOV lpStringToHold, EAX
						RET
						
 0000026D				oneByone:
 0000026D  8B 5D FC				MOV EBX, startAddr
 00000270  8B 03				MOV EAX, [EBX]
 00000272  A3 0000000C R			MOV tempNum, EAX
 00000277  8B DA				MOV EBX, EDX
 00000279  53					PUSH EBX
 0000027A  03 DE				ADD EBX, ESI
						INVOKE intasc32, EBX, tempNum	
 00000288  5B					POP EBX
 00000289  EB BF				JMP finished
					
					
					
 0000028B			displayArray ENDP
				END
Microsoft (R) Macro Assembler Version 6.11		    10/25/19 00:53:56
proj4procs.asm						     Symbols 2 - 1




Macros:

                N a m e                 Type

getBytes . . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000011 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000028B DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

ascint32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
displayArray . . . . . . . . . .	P Near	 000000A1 _TEXT	Length= 000001EA Public C
  lpArrayDwords  . . . . . . . .	DWord	 bp + 00000008
  rows . . . . . . . . . . . . .	DWord	 bp + 0000000C
  cols . . . . . . . . . . . . .	DWord	 bp + 00000010
  lpStringtoHold . . . . . . . .	DWord	 bp + 00000014
  startAddr  . . . . . . . . . .	DWord	 bp - 00000004
  outAddr  . . . . . . . . . . .	DWord	 bp - 00000008
  ??0000 . . . . . . . . . . . .	L Near	 000000EF _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 000000F8 _TEXT	
  lpConvertToASCII . . . . . . .	L Near	 00000112 _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 00000149 _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 00000152 _TEXT	
  ??0004 . . . . . . . . . . . .	L Near	 00000185 _TEXT	
  ??0005 . . . . . . . . . . . .	L Near	 0000018E _TEXT	
  ??0006 . . . . . . . . . . . .	L Near	 000001BA _TEXT	
  ??0007 . . . . . . . . . . . .	L Near	 000001C3 _TEXT	
  NoComma  . . . . . . . . . . .	L Near	 000001D3 _TEXT	
  ??0008 . . . . . . . . . . . .	L Near	 000001FC _TEXT	
  ??0009 . . . . . . . . . . . .	L Near	 00000205 _TEXT	
  ??000A . . . . . . . . . . . .	L Near	 00000231 _TEXT	
  ??000B . . . . . . . . . . . .	L Near	 0000023A _TEXT	
  finished . . . . . . . . . . .	L Near	 0000024A _TEXT	
  oneByone . . . . . . . . . . .	L Near	 0000026D _TEXT	
extractDwords  . . . . . . . . .	P Near	 00000000 _TEXT	Length= 000000A1 Public C
  StringofChars  . . . . . . . .	DWord	 bp + 00000008
  ArrayDwords  . . . . . . . . .	DWord	 bp + 0000000C
  addOut . . . . . . . . . . . .	DWord	 bp - 00000004
  addASCII . . . . . . . . . . .	DWord	 bp - 00000008
  lpConvertandMove . . . . . . .	L Near	 00000020 _TEXT	
  lpCompareWhitelist . . . . . .	L Near	 00000034 _TEXT	
  ValidChar  . . . . . . . . . .	L Near	 00000044 _TEXT	
  lpCompareNext  . . . . . . . .	L Near	 0000005F _TEXT	
  lpClearBTemp . . . . . . . . .	L Near	 0000007E _TEXT	
  ValidNextChar  . . . . . . . .	L Near	 00000095 _TEXT	
  finished . . . . . . . . . . .	L Near	 0000009B _TEXT	
intasc32Comma  . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
WhiteListChars . . . . . . . . .	Byte	 00000000 _DATA	
bNumBytes  . . . . . . . . . . .	Byte	 0000000C _DATA	
bTemps . . . . . . . . . . . . .	Byte	 00000011 _DATA	
iColCount  . . . . . . . . . . .	DWord	 0000000D _DATA	
tempNum  . . . . . . . . . . . .	DWord	 0000000C _DATA	

	   0 Warnings
	   0 Errors
