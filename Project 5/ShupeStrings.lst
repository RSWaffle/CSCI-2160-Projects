Microsoft (R) Macro Assembler Version 6.11		    11/19/19 18:39:08
shupestrings.asm					     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: ShupeStrings.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Date:         Created 10/19/2019
				;*  Purpose:      A couple string methods that can manipulate a string and gather attributes
				;******************************************************************************************
					.486						;This tells assembler to generate 32-bit code
					.model flat					;This tells assembler that all addresses are real addresses
					.stack 100h					;EVERY program needs to have a stack allocated
				;******************************************************************************************
				memoryallocBailey PROTO Near32 stdcall, dSize:DWORD 							;Creates memory on the heap (of dSize words) and returns the address of the
				getBytes PROTO Near32 stdcall, string:dword
				
				COMMENT%
				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	  Intakes an address and counts the number of bytes into a string including*
				*     the null char and returns the number.                                  *
				*Date Created: 10/24/2019                                                    *
				*Date Modified: 10/25/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytesM MACRO String:REQ
					LOCAL stLoop						;add a local label so the assembler doesnt yell when this is called more than once
					LOCAL done							;add a local label so the assembler doesnt yell when this is called more than once
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
							stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
						POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
				.data
					numBytes dword ?			;memory to hold the number of bytes in a string
 00000000				bChar byte ?				;memory to hold a char to put into memory 
 00000000 00000000			originalAddr dword ?		;original address of a string
 00000004 00				cpAddr dword ?				;new address of a string after copying
 00000005 00000000		
 00000009 00000000		;******************************************************************************************
				.code
				
 00000000			
				
				COMMENT %
				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	counts the number of bytes in a string and returns the number in eax     *
				*                                                                            *
				*Date Created: 10/12/2019                                                    *
				*Date Modified: 11/15/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:dword                                                        *
				*@returns numOfBytes:dword													 *
				*****************************************************************************%
				getBytes PROC stdcall uses EDX ESI, String1:dword
					PUSH EBP							;;preserves base register
 00000000				MOV EBP, ESP						;;sets a new stack frame
 00000005  55				MOV EDX, String1					;;moves into ebx the first val in the stack that we are going to use
 00000006  8B EC			MOV ESI, 0							;;sets the initial point to 0
 00000008  8B 55 08				
 0000000B  BE 00000000			stLoop:
						CMP byte ptr [EDX + ESI], 0		;;compares the two positions to determine if this is the end of the string
 00000010					JE done							;;if it is jump to finished
 00000010  80 3C 16 00				INC ESI							;;if not increment esi
 00000014  74 03				JMP stLoop						;;jump to the top of the loop and look at the next char
 00000016  46				done:		
 00000017  EB F7				INC ESI							;;increment esi to include the null character in the string
 00000019					MOV EAX, ESI					;;move the value of esi into eax for proper output and return
 00000019  46				
 0000001A  8B C6			POP EBP								;;restore originla ebp
					RET 
 0000001C  5D			getBytes ENDP
				
 00000023			COMMENT%
				******************************************************************************
				*Name: appendString                                                          *
				*Purpose:                                                                    *
				*	  This method copies the null-terminated string starting at the address  *
				*  indicated by the source parameter into the string starting at the address *
				*  indicated by the destination. The destination string will be null-terminated*
				*  after appending.                                                          *
				*Date Created: 10/31/2019                                                    *
				*Date Modified: 11/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param lpDestination:dword                                                  *
				*@param lpDSource:dword	                                                     *
				*****************************************************************************%
				appendString PROC Near32 stdcall uses EDX ECX EDI EBX, lpDestination:dword, lpSource:dword
					LOCAL numBytesToCopy:dword
 00000023				
					MOV EDX, lpSource				;moves the source address into EDX so we can get the number of current bytes
					getBytesM EDX					;call the getbytes macro so we get the current number of bytes. 
 0000002D  8B 55 0C			MOV numBytesToCopy, EAX			;stores this into a local variable
					MOV EAX, lpDestination			;moves into EAX, the destination address
 00000030  55		     1		PUSH EBP							
 00000031  8B EC	     1		MOV EBP, ESP						
 00000033  53		     1		PUSH EBX							
 00000034  56		     1		PUSH ESI							
 00000035  8B DA	     1		MOV EBX, EDX						
 00000037  BE 00000000	     1		MOV ESI, 0							
 0000003C		     1		??0000:
 0000003C  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000040  74 03	     1			JE ??0001							
 00000042  46		     1			INC ESI							
 00000043  EB F7	     1			JMP ??0000						
 00000045		     1		??0001:		
 00000045  46		     1			INC ESI							
 00000046  8B C6	     1			MOV EAX, ESI					
 00000048  5E		     1		POP ESI								
 00000049  5B		     1		POP EBX								
 0000004A  5D		     1		POP EBP								
 0000004B  89 45 FC			getBytesM EAX					;call the getbytes macro so we get the current number of bytes. 
 0000004E  8B 45 08			MOV EDI, EAX					;stores the number of bytes in the output into EDI
					DEC EDI							;decrements edi so we ignore the null character the getBytes counts for
 00000051  55		     1		PUSH EBP							
 00000052  8B EC	     1		MOV EBP, ESP						
 00000054  53		     1		PUSH EBX							
 00000055  56		     1		PUSH ESI							
 00000056  8B D8	     1		MOV EBX, EAX						
 00000058  BE 00000000	     1		MOV ESI, 0							
 0000005D		     1		??0002:
 0000005D  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000061  74 03	     1			JE ??0003							
 00000063  46		     1			INC ESI							
 00000064  EB F7	     1			JMP ??0002						
 00000066		     1		??0003:		
 00000066  46		     1			INC ESI							
 00000067  8B C6	     1			MOV EAX, ESI					
 00000069  5E		     1		POP ESI								
 0000006A  5B		     1		POP EBX								
 0000006B  5D		     1		POP EBP								
 0000006C  8B F8			MOV EBX, lpDestination			;moves the address of the output into ebx
 0000006E  4F				MOV ECX, numBytesToCopy			;moves the number of bytes to copy into ecx so we can loop
 0000006F  8B 5D 08			ADD EBX, EDI 					;adds EDI to the initial address so we get the starting address were going to paste to
 00000072  8B 4D FC			
 00000075  03 DF			lpCopyString:
						MOV EAX, [EDX]				;moves the current value at address edx into eax
 00000077					MOV [EBX], AL				;moves into the current address of ebx the value in AL
 00000077  8B 02				INC EBX						;increments to the next position in the destination
 00000079  88 03				INC EDX						;increments to the next position in the source
 0000007B  43				loop lpCopyString				;decrement ecx, and jump back to the top
 0000007C  42				RET								;return back to where I was called from. 
 0000007D  E2 F8		appendString endp
				 
 00000087			COMMENT%
				******************************************************************************
				*Name: placeString                                                           *
				*Purpose:                                                                    *
				*	  This method copies the null-terminated string starting at the address  *
				*  indicated by the source parameter into the string starting at the address *
				*  indicated by the destination. The destination string will be null-terminated*
				*  after appending.                                                          *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param lpDestination:dword                                                  *
				*@param lpDSource:dword	                                                     *
				*****************************************************************************%
				placeString PROC Near32 stdcall uses EDX ECX EDI EBX, lpDestination:dword, lpSource:dword
					LOCAL numBytesToCopy:dword
 00000087				
					MOV EDX, lpSource				;moves the source address into EDX so we can get the number of current bytes
					MOV EDX, 0					    ;call the getbytes macro so we get the current number of bytes. 
 00000091  8B 55 0C			MOV numBytesToCopy, EAX			;stores this into a local variable
 00000094  BA 00000000			MOV EAX, lpDestination			;moves into EAX, the destination address
 00000099  89 45 FC			MOV EAX,0				    	;call the getbytes macro so we get the current number of bytes. 
 0000009C  8B 45 08			MOV EDI, EAX					;stores the number of bytes in the output into EDI
 0000009F  B8 00000000			DEC EDI							;decrements edi so we ignore the null character the getBytes counts for
 000000A4  8B F8			MOV EBX, lpDestination			;moves the address of the output into ebx
 000000A6  4F				MOV ECX, numBytesToCopy			;moves the number of bytes to copy into ecx so we can loop
 000000A7  8B 5D 08			ADD EBX, EDI 					;adds EDI to the initial address so we get the starting address were going to paste to
 000000AA  8B 4D FC			
 000000AD  03 DF			lpCopyString:
						MOV EAX, [EDX]				;moves the current value at address edx into eax
 000000AF					MOV [EBX], AL				;moves into the current address of ebx the value in AL
 000000AF  8B 02				INC EBX						;increments to the next position in the destination
 000000B1  88 03				INC EDX						;increments to the next position in the source
 000000B3  43				loop lpCopyString				;decrement ecx, and jump back to the top
 000000B4  42				RET								;return back to where I was called from. 
 000000B5  E2 F8		placeString endp 
				COMMENT %
 000000BF			******************************************************************************
				*Name: createStringCopy                                                      *
				*Purpose:                                                                    *
				*	accepts an address, makes a copy, sends back new addr in EAX		     *
				*                                                                            *
				*Date Created: 10/12/2019                                                    *
				*Date Modified: 11/15/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param Addr1:dword                                                          *
				*@returns Addr2:dword														 *
				*****************************************************************************%
				createStringCopy PROC stdcall uses EBX EDI EDX ESI, Addr1:dword
					PUSH EBP							;preserves base register
 000000BF				MOV EBP, ESP						;sets a new stack frame
 000000C6  55			
 000000C7  8B EC			MOV EBX, Addr1						;moves into ebx the address to the beginning of the original string.
					MOV originalAddr, EBX				;move the address in ebx into a variable
 000000C9  8B 5D 08			MOV ESI, 0							;sets the initial point to 0
 000000CC  89 1D 00000005 R		MOV EDI, 0							;sets the initial offset to 0
 000000D2  BE 00000000			INVOKE getBytes, EBX
 000000D7  BF 00000000			MOV numBytes, EBX					;move the number of bytes in the string into its own variable
					MOV EBX, 0							;clear the ebx register so we can use it later. 
 000000E2  89 1D 00000000 R	
 000000E8  BB 00000000			INVOKE 	memoryallocBailey, numBytes ;allocate space on the heap with the number of bytes we need. 
					MOV EDX, EAX						;move the address it gives us into its own variable 	
					MOV EAX, 0							;clear out eax to avoid issues
 000000F8  8B D0			MOV ESI, [originalAddr]				;move into EDI the derefrenced original address of the string
 000000FA  B8 00000000			topOfLoop:
 000000FF  8B 35 00000005 R			MOV BL, [ESI]					;move into BL the value at adress esi
 00000105					MOV bChar, BL					;move this into its variable 
 00000105  8A 1E				CMP bChar, 00					;compare it to 00 to see if we reached the end of the string
 00000107  88 1D 00000004 R			JE finished						;if it is equal to 0, then jump to finished
 0000010D  80 3D 00000004 R			MOV AL, bChar					;moves the char into al so we can insert it at the new point
	   00
 00000114  74 0C				MOV [EDX + EDI], EAX			;moves the value in eax into the new address offset edi
 00000116  A0 00000004 R			INC EDI							;increment edi to get the next position in the new address
 0000011B  89 04 17				INC ESI							;increment esi to get the next position in the original address
 0000011E  47					JMP topOfLoop					;jump to the top of the loop with our incremented numbers. 
 0000011F  46				finished:
 00000120  EB E3				MOVSX EBX, bChar				;move into ebx the null character
 00000122					MOV [EDX + EDI], EBX			;moves the null character into the position in the new address
 00000122  0F BE 1D			MOV EAX, OFFSET cpAddr				;moves the address of the copyed address into EAX for return
	   00000004 R
 00000129  89 1C 17			
 0000012C  B8 00000009 R		POP EBP								;restore original ebp
					RET	4								;return
 00000131  5D			createStringCopy ENDP
				END
 00000137  C2 0004
 0000013A
Microsoft (R) Macro Assembler Version 6.11		    11/19/19 18:39:08
shupestrings.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

getBytesM  . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 0000000D DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000013A DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

appendString . . . . . . . . . .	P Near	 00000023 _TEXT	Length= 00000064 Public STDCALL
  lpDestination  . . . . . . . .	DWord	 bp + 00000008
  lpSource . . . . . . . . . . .	DWord	 bp + 0000000C
  numBytesToCopy . . . . . . . .	DWord	 bp - 00000004
  ??0000 . . . . . . . . . . . .	L Near	 0000003C _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 00000045 _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 0000005D _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 00000066 _TEXT	
  lpCopyString . . . . . . . . .	L Near	 00000077 _TEXT	
createStringCopy . . . . . . . .	P Near	 000000BF _TEXT	Length= 0000007B Public STDCALL
  Addr1  . . . . . . . . . . . .	DWord	 bp + 00000008
  topOfLoop  . . . . . . . . . .	L Near	 00000105 _TEXT	
  finished . . . . . . . . . . .	L Near	 00000122 _TEXT	
getBytes . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000023 Public STDCALL
  String1  . . . . . . . . . . .	DWord	 bp + 00000008
  stLoop . . . . . . . . . . . .	L Near	 00000010 _TEXT	
  done . . . . . . . . . . . . .	L Near	 00000019 _TEXT	
memoryallocBailey  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
placeString  . . . . . . . . . .	P Near	 00000087 _TEXT	Length= 00000038 Public STDCALL
  lpDestination  . . . . . . . .	DWord	 bp + 00000008
  lpSource . . . . . . . . . . .	DWord	 bp + 0000000C
  numBytesToCopy . . . . . . . .	DWord	 bp - 00000004
  lpCopyString . . . . . . . . .	L Near	 000000AF _TEXT	


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
bChar  . . . . . . . . . . . . .	Byte	 00000004 _DATA	
cpAddr . . . . . . . . . . . . .	DWord	 00000009 _DATA	
numBytes . . . . . . . . . . . .	DWord	 00000000 _DATA	
originalAddr . . . . . . . . . .	DWord	 00000005 _DATA	

	   0 Warnings
	   0 Errors
