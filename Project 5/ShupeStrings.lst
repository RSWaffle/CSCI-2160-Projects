Microsoft (R) Macro Assembler Version 6.11		    11/15/19 23:53:49
ShupeStrings.asm					     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: ShupeStrings.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Date:         Created 10/19/2019
				;*  Purpose:      A couple string methods that can manipulate a string and gather attributes
				;******************************************************************************************
					.486						;This tells assembler to generate 32-bit code
					.model flat					;This tells assembler that all addresses are real addresses
					.stack 100h					;EVERY program needs to have a stack allocated
				;******************************************************************************************
				heapAllocHarrison PROTO Near32 stdcall, dSize:DWORD 							;Creates memory on the heap (of dSize words) and returns the address of the
				getBytes PROTO Near32 stdcall, string:dword

				COMMENT%
				******************************************************************************
				*Name: getBytes M                                                             *
				*Purpose:                                                                    *
				*	  Intakes an address and counts the number of bytes into a string including*
				*     the null char and returns the number.                                  *
				*Date Created: 10/24/2019                                                    *
				*Date Modified: 10/25/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:byte                                                         *
				*****************************************************************************%
				getBytesM MACRO String:REQ
					LOCAL stLoop						;add a local label so the assembler doesnt yell when this is called more than once
					LOCAL done							;add a local label so the assembler doesnt yell when this is called more than once
					PUSH EBP							;preserves base register
					MOV EBP, ESP						;sets a new stack frame
					PUSH EBX							;pushes EBX to the stack to store this
					PUSH ESI							;pushes ESI to the stack to preseve
					MOV EBX, String						;;moves into ebx the first val in the stack that we are going to use
					MOV ESI, 0							;sets the initial point to 0
						
					stLoop:
						CMP byte ptr [EBX + ESI], 0		;compares the two positions to determine if this is the end of the string
						JE done							;;if it is jump to finished
						INC ESI							;if not increment esi
						JMP stLoop						;;jump to the top of the loop and look at the next char
					done:		
						INC ESI							;increment esi to include the null character in the string
						MOV EAX, ESI					;move the value of esi into eax for proper output and return
					
					POP ESI								;restore original esi
					POP EBX								;restore original ebx
					POP EBP								;restore originla ebp
				ENDM
				;******************************************************************************************
 00000000			.data
 00000000 00000000			numBytes dword ?			;memory to hold the number of bytes in a string
 00000004 00				bChar byte ?				;memory to hold a char to put into memory 
 00000005 00000000			originalAddr dword ?		;original address of a string
 00000009 00000000			cpAddr dword ?				;new address of a string after copying

				;******************************************************************************************
 00000000			.code



				COMMENT %
				******************************************************************************
				*Name: getBytes                                                              *
				*Purpose:                                                                    *
				*	counts the number of bytes in a string and returns the number in eax     *
				*                                                                            *
				*Date Created: 10/12/2019                                                    *
				*Date Modified: 11/15/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param String1:dword                                                        *
				*@returns numOfBytes:dword													 *
				*****************************************************************************%
 00000000			getBytes PROC stdcall uses EDX ESI, String1:dword
 00000005  55				PUSH EBP							;;preserves base register
 00000006  8B EC			MOV EBP, ESP						;;sets a new stack frame
 00000008  8B 55 08			MOV EDX, String1					;;moves into ebx the first val in the stack that we are going to use
 0000000B  BE 00000000			MOV ESI, 0							;;sets the initial point to 0
						
 00000010				stLoop:
 00000010  80 3C 16 00				CMP byte ptr [EDX + ESI], 0		;;compares the two positions to determine if this is the end of the string
 00000014  74 03				JE done							;;if it is jump to finished
 00000016  46					INC ESI							;;if not increment esi
 00000017  EB F7				JMP stLoop						;;jump to the top of the loop and look at the next char
 00000019				done:		
 00000019  46					INC ESI							;;increment esi to include the null character in the string
 0000001A  8B C6				MOV EAX, ESI					;;move the value of esi into eax for proper output and return
					
 0000001C  5D				POP EBP								;;restore originla ebp
					RET 
 00000023			getBytes ENDP

				COMMENT%
				******************************************************************************
				*Name: appendString                                                          *
				*Purpose:                                                                    *
				*	  This method copies the null-terminated string starting at the address  *
				*  indicated by the source parameter into the string starting at the address *
				*  indicated by the destination. The destination string will be null-terminated*
				*  after appending.                                                          *
				*Date Created: 10/31/2019                                                    *
				*Date Modified: 11/02/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param lpDestination:dword                                                  *
				*@param lpDSource:dword	                                                     *
				*****************************************************************************%
 00000023			appendString PROC Near32 stdcall uses EDX ECX EDI EBX, lpDestination:dword, lpSource:dword
					LOCAL numBytesToCopy:dword
					
 0000002D  8B 55 0C			MOV EDX, lpSource				;moves the source address into EDX so we can get the number of current bytes
					getBytesM EDX					;call the getbytes macro so we get the current number of bytes. 
 00000030  55		     1		PUSH EBP							
 00000031  8B EC	     1		MOV EBP, ESP						
 00000033  53		     1		PUSH EBX							
 00000034  56		     1		PUSH ESI							
 00000035  8B DA	     1		MOV EBX, EDX						
 00000037  BE 00000000	     1		MOV ESI, 0							
 0000003C		     1		??0000:
 0000003C  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000040  74 03	     1			JE ??0001							
 00000042  46		     1			INC ESI							
 00000043  EB F7	     1			JMP ??0000						
 00000045		     1		??0001:		
 00000045  46		     1			INC ESI							
 00000046  8B C6	     1			MOV EAX, ESI					
 00000048  5E		     1		POP ESI								
 00000049  5B		     1		POP EBX								
 0000004A  5D		     1		POP EBP								
 0000004B  89 45 FC			MOV numBytesToCopy, EAX			;stores this into a local variable
 0000004E  8B 45 08			MOV EAX, lpDestination			;moves into EAX, the destination address
					getBytesM EAX					;call the getbytes macro so we get the current number of bytes. 
 00000051  55		     1		PUSH EBP							
 00000052  8B EC	     1		MOV EBP, ESP						
 00000054  53		     1		PUSH EBX							
 00000055  56		     1		PUSH ESI							
 00000056  8B D8	     1		MOV EBX, EAX						
 00000058  BE 00000000	     1		MOV ESI, 0							
 0000005D		     1		??0002:
 0000005D  80 3C 1E 00	     1			CMP byte ptr [EBX + ESI], 0		
 00000061  74 03	     1			JE ??0003							
 00000063  46		     1			INC ESI							
 00000064  EB F7	     1			JMP ??0002						
 00000066		     1		??0003:		
 00000066  46		     1			INC ESI							
 00000067  8B C6	     1			MOV EAX, ESI					
 00000069  5E		     1		POP ESI								
 0000006A  5B		     1		POP EBX								
 0000006B  5D		     1		POP EBP								
 0000006C  8B F8			MOV EDI, EAX					;stores the number of bytes in the output into EDI
 0000006E  4F				DEC EDI							;decrements edi so we ignore the null character the getBytes counts for
 0000006F  8B 5D 08			MOV EBX, lpDestination			;moves the address of the output into ebx
 00000072  8B 4D FC			MOV ECX, numBytesToCopy			;moves the number of bytes to copy into ecx so we can loop
 00000075  03 DF			ADD EBX, EDI 					;adds EDI to the initial address so we get the starting address were going to paste to
					
 00000077				lpCopyString:
 00000077  8B 02				MOV EAX, [EDX]				;moves the current value at address edx into eax
 00000079  88 03				MOV [EBX], AL				;moves into the current address of ebx the value in AL
 0000007B  43					INC EBX						;increments to the next position in the destination
 0000007C  42					INC EDX						;increments to the next position in the source
 0000007D  E2 F8			loop lpCopyString				;decrement ecx, and jump back to the top
					RET								;return back to where I was called from. 
 00000087			appendString endp 

				COMMENT %
				******************************************************************************
				*Name: createStringCopy                                                      *
				*Purpose:                                                                    *
				*	accepts an address, makes a copy, sends back new addr in EAX		     *
				*                                                                            *
				*Date Created: 10/12/2019                                                    *
				*Date Modified: 11/15/2019                                                   *
				*                                                                            *
				*                                                                            *
				*@param Addr1:dword                                                          *
				*@returns Addr2:dword														 *
				*****************************************************************************%
 00000087			createStringCopy PROC stdcall uses EBX EDI EDX ESI, Addr1:dword
 0000008E  55				PUSH EBP							;preserves base register
 0000008F  8B EC			MOV EBP, ESP						;sets a new stack frame

 00000091  8B 5D 08			MOV EBX, Addr1						;moves into ebx the address to the beginning of the original string.
 00000094  89 1D 00000005 R		MOV originalAddr, EBX				;move the address in ebx into a variable
 0000009A  BE 00000000			MOV ESI, 0							;sets the initial point to 0
 0000009F  BF 00000000			MOV EDI, 0							;sets the initial offset to 0
					INVOKE getBytes, EBX
 000000AA  89 1D 00000000 R		MOV numBytes, EBX					;move the number of bytes in the string into its own variable
 000000B0  BB 00000000			MOV EBX, 0							;clear the ebx register so we can use it later. 

					INVOKE 	heapAllocHarrison, numBytes ;allocate space on the heap with the number of bytes we need. 
 000000C0  8B D0			MOV EDX, EAX						;move the address it gives us into its own variable 	
 000000C2  B8 00000000			MOV EAX, 0							;clear out eax to avoid issues
 000000C7  8B 35 00000005 R		MOV ESI, [originalAddr]				;move into EDI the derefrenced original address of the string
 000000CD				topOfLoop:
 000000CD  8A 1E				MOV BL, [ESI]					;move into BL the value at adress esi
 000000CF  88 1D 00000004 R			MOV bChar, BL					;move this into its variable 
 000000D5  80 3D 00000004 R			CMP bChar, 00					;compare it to 00 to see if we reached the end of the string
	   00
 000000DC  74 0C				JE finished						;if it is equal to 0, then jump to finished
 000000DE  A0 00000004 R			MOV AL, bChar					;moves the char into al so we can insert it at the new point
 000000E3  89 04 17				MOV [EDX + EDI], EAX			;moves the value in eax into the new address offset edi
 000000E6  47					INC EDI							;increment edi to get the next position in the new address
 000000E7  46					INC ESI							;increment esi to get the next position in the original address
 000000E8  EB E3				JMP topOfLoop					;jump to the top of the loop with our incremented numbers. 
 000000EA				finished:
 000000EA  0F BE 1D				MOVSX EBX, bChar				;move into ebx the null character
	   00000004 R
 000000F1  89 1C 17				MOV [EDX + EDI], EBX			;moves the null character into the position in the new address
 000000F4  B8 00000009 R		MOV EAX, OFFSET cpAddr				;moves the address of the copyed address into EAX for return
					
 000000F9  5D				POP EBP								;restore original ebp
					RET	4								;return
 000000FF  C2 0004		createStringCopy ENDP
 00000102			END
Microsoft (R) Macro Assembler Version 6.11		    11/15/19 23:53:49
ShupeStrings.asm					     Symbols 2 - 1




Macros:

                N a m e                 Type

getBytesM  . . . . . . . . . . .	Proc


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 0000000D DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000102 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

appendString . . . . . . . . . .	P Near	 00000023 _TEXT	Length= 00000064 Public STDCALL
  lpDestination  . . . . . . . .	DWord	 bp + 00000008
  lpSource . . . . . . . . . . .	DWord	 bp + 0000000C
  numBytesToCopy . . . . . . . .	DWord	 bp - 00000004
  ??0000 . . . . . . . . . . . .	L Near	 0000003C _TEXT	
  ??0001 . . . . . . . . . . . .	L Near	 00000045 _TEXT	
  ??0002 . . . . . . . . . . . .	L Near	 0000005D _TEXT	
  ??0003 . . . . . . . . . . . .	L Near	 00000066 _TEXT	
  lpCopyString . . . . . . . . .	L Near	 00000077 _TEXT	
createStringCopy . . . . . . . .	P Near	 00000087 _TEXT	Length= 0000007B Public STDCALL
  Addr1  . . . . . . . . . . . .	DWord	 bp + 00000008
  topOfLoop  . . . . . . . . . .	L Near	 000000CD _TEXT	
  finished . . . . . . . . . . .	L Near	 000000EA _TEXT	
getBytes . . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 00000023 Public STDCALL
  String1  . . . . . . . . . . .	DWord	 bp + 00000008
  stLoop . . . . . . . . . . . .	L Near	 00000010 _TEXT	
  done . . . . . . . . . . . . .	L Near	 00000019 _TEXT	
heapAllocHarrison  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
bChar  . . . . . . . . . . . . .	Byte	 00000004 _DATA	
cpAddr . . . . . . . . . . . . .	DWord	 00000009 _DATA	
numBytes . . . . . . . . . . . .	DWord	 00000000 _DATA	
originalAddr . . . . . . . . . .	DWord	 00000005 _DATA	

	   0 Warnings
	   0 Errors
