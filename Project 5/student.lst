Microsoft (R) Macro Assembler Version 6.11		    11/20/19 00:28:38
student.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: Student.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:		  Proj 5
				;*  Date:         Created 11/23/2019
				;*  Purpose:      create a student class that can hold different attrubutes about a student
				;*				   and create setters and getters
				;******************************************************************************************
					.486						;This tells assembler to generate 32-bit code
					.model flat					;This tells assembler that all addresses are real addresses
					.stack 100h					;EVERY program needs to have a stack allocated
				;******************************************************************************************
				memoryallocBailey PROTO Near32 stdcall, dSize:DWORD
				appendString	  PROTO Near32 stdcall, lpDestination:dword, lpSource:dword
				intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword
				Student_setName PROTO stdcall, ths:dword, addrFirst:dword, addrLast:dword
				Student_getZip PROTO stdcall, ths:dword
				Student_getName PROTO stdcall, ths:dword
				Student_getStreet PROTO stdcall, ths:dword
				getBytes PROTO stdcall, String1:dword
				Student_calcAvg PROTO stdcall, ths:dword
				Student_letterGrade PROTO stdcall, ths:dword
				;******************************************************************************************	
 0000019A			Student STRUCT 
 00000000  00000064 [			last byte 100 dup(0)					;space to hold the last name of the student
	    00
	   ]
 00000064  00000064 [			first byte 100 dup(0)					;space to hold the first name of the student
	    00
	   ]
 000000C8  000000C8 [			street byte 200 dup(0)					;space to hold the street address
	    00
	   ]
 00000190  00000000			zip dword ?								;space to hold the zip
 00000194  0000				test1 word ?							;word to hold the test score 1
 00000196  0000				test2 word ?							;word to hold the test score 2
 00000198  0000				test3 word ? 							;word to hold the test score 3
				Student ENDS
				;******************************************************************************************
 00000000			.DATA
 00000000 20 00			spaceChar byte 32,0							;memory to hold the space char
 00000002 0A 00			nextLine byte 10,0							;memory to store the next line char
				
 00000004 54 65 73 74 20	strTest1 byte "Test 1: ", 0
	   31 3A 20 00
 0000000D 54 65 73 74 20	strTest2 byte "Test 2: ", 0
	   32 3A 20 00
 00000016 54 65 73 74 20	strTest3 byte "Test 3: ", 0
	   33 3A 20 00
 0000001F 41 76 65 72 61	strAverage byte "Average: ", 0
	   67 65 3A 20 00
 00000029 47 72 61 64 65	strGrade byte "Grade: ", 0
	   3A 20 00
				;******************************************************************************************
 00000000			.CODE
				
				COMMENT%
				******************************************************************************
				*Name: Student_1                                                             *
				*Purpose:                                                                    *
				*	  Creates a student object with dynamic memory allocated                 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*****************************************************************************%
 00000000			Student_1 PROC stdcall
					INVOKE memoryallocBailey, sizeof Student 	;allocates memory onto the heap the required amount for a student struct
 0000000A  C3				RET											;returns where I was called, address in EAX
 0000000B			Student_1 endp
				
				COMMENT%
				******************************************************************************
				*Name: Student_2                                                             *
				*Purpose:                                                                    *
				*	  Creates a student object with enough memory allocated, with a name set *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param addrFirst:dword                                                      *
				*@param addrLast:dword                                                       *
				*****************************************************************************%
 0000000B			Student_2 PROC stdcall, firstN:dword, lastN:dword
					INVOKE memoryallocBailey, sizeof Student	;allocate enough memory to hold a student
 00000018  50				PUSH EAX									;store the address it gives
					INVOKE Student_setName, EAX, firstN, lastN	;set the name of the student
 00000025  58				POP EAX										;restore our pushed address of the student
					RET 8										;return back to where i was called with 8 bytes, address in EAX
 00000027  C2 0008		Student_2 ENDP
 0000002A			
				COMMENT%
				******************************************************************************
				*Name: Student_3                                                             *
				*Purpose:                                                                    *
				*	  Creates a student object with enough memory allocated, also intakes    *
				*      another student and copies from it and fills the new student.		 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param sc:dword                                         		             *
				*****************************************************************************%
				Student_3 PROC stdcall, sc:dword
 0000002A			
					RET 4										;returns back to where I was called with 4 bytes, address in eax.
				Student_3 ENDP
 0000002E  C2 0004		
 00000031			COMMENT%
				******************************************************************************
				*Name: setName                                                               *
				*Purpose:                                                                    *
				*	  Intakes a student first and last name and stores it onto the heap address*
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param addrFirst:dword                                                      *
				*@param addrLast:dword                                                       *
				*****************************************************************************%
				Student_setName PROC stdcall uses EBX, ths:dword, addrFirst:dword, addrLast:dword
					MOV EBX, ths										;moves the address of the student into ebx.
 00000031				ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
 00000035  8B 5D 08			INVOKE appendString, addr [EBX].first, addrFirst	;appends the first name string sent in onto the correct memory location	
					INVOKE appendString, addr [EBX].last, addrLast		;appends the last name string sent in ontto the correct memory location	
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 12												;return to where I was called, returning 12 bytes.
				Student_setName ENDP
				
 00000051  C2 000C		COMMENT%
 00000054			******************************************************************************
				*Name: setTestScores                                                         *
				*Purpose:                                                                    *
				*	  Intakes a student and test scores and stores them in the appropriate   *
				*			memory location 												 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param t1:word                                                              *
				*@param t2:word                                                              *
				*@param t3:word                                                              *
				*****************************************************************************%
				Student_setTestScores PROC stdcall uses ebx edx, ths:dword, t1:word, t2:word, t3:word
					MOV EBX, ths										;moves the address of the student into ebx.
					ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
 00000054				MOV DX, t1											;moves the first test into dx
 00000059  8B 5D 08			MOV [EBX].test1, DX									;moves the word into the memory location where test 1 is 
					MOV DX, t2											;moves the first test into dx
 0000005C  66| 8B 55 0C			MOV [EBX].test2, DX									;moves the word into the memory location where test 1 is 
 00000060  66| 89 93			MOV DX, t3											;moves the first test into dx
	   00000194
 00000067  66| 8B 55 10			MOV [EBX].test3, DX									;moves the word into the memory location where test 1 is 
 0000006B  66| 89 93			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
	   00000196
 00000072  66| 8B 55 14			RET 10												;return to where I was called, returning 12 bytes.
 00000076  66| 89 93		Student_setTestScores ENDP
	   00000198
				
				COMMENT%
 00000080  C2 000A		******************************************************************************
 00000083			*Name: setTest                                                               *
				*Purpose:                                                                    *
				*	  Intakes a student and test scores and stores them in the appropriate   *
				*			memory location 												 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param score:word                                                           *
				*@param testNum:word                                                         *
				*****************************************************************************%
				Student_setTest PROC stdcall uses EBX, ths:dword, score:word, numTest:word
					MOV EBX, ths										;moves the address of the student into ebx.
					ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
					.IF numTest == 1									;if the in test num is equal to 1
 00000083					MOV DX, score									;moves the first test into dx
 00000087  8B 5D 08				MOV [EBX].test1, DX								;moves the word into the memory location where test 1 is 
					.ELSEIF numTest == 2								;if the in test num is equal to 2
						MOV DX, score									;moves the first test into dx
 00000091  66| 8B 55 0C				MOV [EBX].test2, DX								;moves the word into the memory location where test 1 is 	
 00000095  66| 89 93			.ELSEIF numTest == 3								;if the in test num is equal to 3
	   00000194
						MOV DX, score									;moves the first test into dx
 000000A5  66| 8B 55 0C				MOV [EBX].test3, DX								;moves the word into the memory location where test 1 is 
 000000A9  66| 89 93			.ELSE												;if the test number is not 1-3
	   00000196
																		;if this was java i would throw an exception here
 000000B9  66| 8B 55 0C			.ENDIF												;end if
 000000BD  66| 89 93			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
	   00000198
					RET 8												;return to where i was called from and return 8 bytes
				Student_setTest ENDP
				
				COMMENT%
				******************************************************************************
 000000C8  C2 0008		*Name: setStreet                                                             *
 000000CB			*Purpose:                                                                    *
				*	  Intakes a student and a street and copies the street onto the memory   *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param streetAddr:dword                                                     *
				*****************************************************************************%
				Student_Street PROC stdcall, ths:dword, streetAddr:dword
					MOV EBX, ths										;moves the address of the student into ebx.
					ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
					INVOKE appendString, addr [EBX].street, streetAddr	;appends the street in into the location it should go onto the heap
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 000000CB				RET 8												;return to where i was called from and return 8 bytes
 000000CE  8B 5D 08		Student_Street ENDP
				
				COMMENT%
				******************************************************************************
				*Name: setZip                                                                *
 000000E1  C2 0008		*Purpose:                                                                    *
 000000E4			*	  Intakes a student and a dword zip code, then places the zip in, into   *
				*     the student's zip                                                      *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param inZip:dword                                                          *
				*****************************************************************************%
				Student_setZip PROC stdcall uses EBX EDX, ths:dword, inZip:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:ptr Student								;assumes ebx is a student pointer so we dont have to type it 
					MOV EDX, inZip										;moves the zip parameter into a register, cant do mem to mem
					MOV [EBX].zip, EDX									;moves the zip sent into the method into the zip in student 
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 000000E4				RET 8												;returns to where I was called returning 8 bytes. 
 000000E9  8B 5D 08		Student_setZip ENDP
				
 000000EC  8B 55 0C		COMMENT%
 000000EF  89 93 00000190	******************************************************************************
				*Name: setAddr                                                               *
				*Purpose:                                                                    *
 000000F8  C2 0008		*	  Intakes a student and a dword address to an address, then places the   *
 000000FB			*		address in, into the student's address              				 *
				*                                                                            *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param inAddr:dword                                                         *
				*****************************************************************************%
				Student_setAddr PROC stdcall uses EBX EDX, ths:dword, inAddr:dword, inZip:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE appendString, addr [EBX].street, inAddr		;appends the street in into the location it should go onto the heap
					MOV EDX, inZip										;moves the zip param into edx, cant do mem to mem
					MOV [EBX].zip, EDX									;moves the zip sent into the method into the zip in the student
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 000000FB				RET 8												;returns to where I was called, returning 8 bytes.
 00000100  8B 5D 08		Student_setAddr ENDP
				
				COMMENT%
 00000112  8B 55 10		******************************************************************************
 00000115  89 93 00000190	*Name: getName                                                               *
				*Purpose:                                                                    *
				*	  Intakes a student and returns the address of where the name is 		 *
 0000011E  C2 0008		*			( new generated string on the heap)                              *
 00000121			*                                                                            *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getName PROC stdcall uses EBX EDX, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 200						;allocate 200 bytes of memory (enough for a big name)
					MOV EDX, EAX										;moves the address of the heap onto edx so we can invoke it
					INVOKE appendString, EDX, addr [EBX].first			;appends the first name at the address
					INVOKE appendString, EDX, addr spaceChar			;appends a space character onto the address
					INVOKE appendString, EDX, addr [EBX].last			;appends the last name onto the address
 00000121				MOV EAX, EDX										;moves the address of the name into eax for returning
 00000126  8B 5D 08			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, returning 8 bytes.
				Student_getName ENDP
 00000133  8B D0		
				COMMENT%
				******************************************************************************
				*Name: getTest                                                               *
 00000153  8B C2		*Purpose:                                                                    *
				*	  Intakes a student and test number and retuns the test grade            *
				*                                                                            *
 00000158  C2 0004		*Date Created: 11/19/2019                                                    *
 0000015B			*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param numTest:word                                                         *
				*@returns testScore:word                                                     *  
				*****************************************************************************%
				Student_getTest PROC stdcall uses EBX, ths:dword, numTest:word
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					.IF numTest == 1									;if the in test num is equal to 1
						MOV AX, [EBX].test1								;moves the score from the test into AX
					.ELSEIF numTest == 2								;if the in test num is equal to 2
						MOV AX, [EBX].test2								;moves the score from the test into AX	
					.ELSEIF numTest == 3								;if the in test num is equal to 3
						MOV AX, [EBX].test3								;moves the score from the test into AX
 0000015B				.ELSE												;if the test number is not 1-3
 0000015F  8B 5D 08			.ENDIF												;if this was java i would throw an exception at the else
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 6												;returns to where I was called, returning 8 bytes.
 00000169  66| 8B 83		Student_getTest ENDP
	   00000194
				
 00000179  66| 8B 83		
	   00000196
				COMMENT%
 00000189  66| 8B 83		******************************************************************************
	   00000198
				*Name: getAddress                                                            *
				*Purpose:                                                                    *
				*	  Intakes a student and returns the street + zip 			             *
				*                                                                            *
 00000194  C2 0006		*Date Created: 11/19/2019                                                    *
 00000197			*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getAddress PROC stdcall uses ECX EDX EDI, ths:dword 
					MOV EDX, 0
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 205						;allocates enough memory for a complete address
					MOV EDI, EAX										;moves into edi the address given back from the allocation
					INVOKE Student_getStreet, ths						;gets the street from the current student passed in
					MOV EDX, EAX										;moves into EDX, the returning street address in EAX
					INVOKE appendString, EDI, EDX						;appends the street to the blank allocated memory
					INVOKE appendString, EDI, addr spaceChar			;appends a space character onto the address
 00000197				INVOKE Student_getZip, ths							;gets the current zip from the student and address is in eax
 0000019D  BA 00000000			MOV EDX, EAX										;moves the address of the zip into eax
 000001A2  8B 5D 08			INVOKE appendString, EDI, EDX						;appends the zip at the end of the current string allocated (the street and the space to seperate)
					MOV EAX, EDI										;moves the address of the address into eax for returning
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 000001AF  8B F8			RET 4												;returns to where I was called, returning 8 bytes.
				Student_getAddress ENDP
 000001B9  8B D0		
				COMMENT%
				******************************************************************************
				*Name: getStreet                                                             *
 000001D5  8B D0		*Purpose:                                                                    *
				*	  Intakes a student and returns the street      			             *
 000001DE  8B C7		*                                                                            *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
 000001E4  C2 0004		*                                                                            *
 000001E7			*@param ths:dword                                                            *
				*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getStreet PROC stdcall uses ebx edx, ths:dword
					MOV EDX, 0											;clear our edx
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 200						;allocate 205 bytes of memory (enough for a street and 5 digit zip)
					MOV EDX, EAX										;moves the address of the heap onto edx so we can invoke it
					INVOKE appendString, EDX, addr [EBX].street			;appends the street at the address
					MOV EAX, EDX										;moves the address of the address into eax for returning
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, returning 8 bytes.
				Student_getStreet ENDP
 000001E7			
 000001EC  BA 00000000		COMMENT%
 000001F1  8B 5D 08		******************************************************************************
				*Name: getStreet                                                             *
				*Purpose:                                                                    *
 000001FE  8B D0		*	  Intakes a student and returns the street      			             *
				*                                                                            *
 0000020D  8B C2		*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
 00000212  C2 0004		*@param ths:dword                                                            *
 00000215			*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getZip PROC stdcall uses ebx ecx edi, ths:dword
					MOV ECX, 0											;clear out ecx
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 5							;allocate 5 bytes to convert the zip
					MOV EDI, EAX										;move the address of the zip into edi
					MOV ECX, [EBX].zip									;moves the address of the zip into ECX
					INVOKE intasc32, EDI, dword ptr [ECX]				;converts the zipcode into ascii form 
					MOV EAX, EDI										;moves the address of the address into eax for returning
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, returning 8 bytes.
				Student_getZip ENDP
 00000215			
 0000021B  B9 00000000		COMMENT%
 00000220  8B 5D 08		******************************************************************************
				*Name: findMax                                                               *
				*Purpose:                                                                    *
 0000022A  8B F8		*	  finds the max test grade of the student        			             *
 0000022C  8B 8B 00000190	*                                                                            *
				*Date Created: 11/19/2019                                                    *
 0000023A  8B C7		*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
 00000240  C2 0004		*@returns outTest:word                                                       *  
 00000243			*****************************************************************************%
				Student_findMax PROC stdcall uses EBX , ths:dword										
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV AX, [EBX].test1									;moves the value in t1 into register so we can compare without mem to mem error
					.IF  AX > [EBX].test2 && AX > [EBX].test3			;if the value in t1 is greater than t2 and t3
						MOV AX, [EBX].test1								;moves the first test into the largest spot
					.ELSE												;considering the value in t1 is less than t2 and t3 we can use else
						MOV AX, [EBX].test2								;moves the value of t2 into the register for comparison
						.IF AX > [EBX].test3							;if the value t2 is greater than t3, it is therefore the greatest number	
							MOV AX, [EBX].test2							;moves the test 2 into the largest spot
						.ELSE											;test3 is the greatest if this gets hit
							MOV AX, [EBX].test3							;move the test score 3 into the largest spot
						.ENDIF											;end if
 00000243				.ENDIF												;ends if
 00000247  8B 5D 08			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, returning 8 bytes.
 0000024A  66| 8B 83		Student_findMax ENDP
	   00000194
				
 00000263  66| 8B 83		COMMENT%
	   00000194
				******************************************************************************
 0000026C  66| 8B 83		*Name: findMin                                                               *
	   00000196
				*Purpose:                                                                    *
 0000027C  66| 8B 83		*	  finds the min test grade of the student        			             *
	   00000196
				*                                                                            *
 00000285  66| 8B 83		*Date Created: 11/19/2019                                                    *
	   00000198
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outTest:word                                                       *  
 0000028E  C2 0004		*****************************************************************************%
 00000291			Student_findMin PROC stdcall, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV AX, [EBX].test1									;moves the value in t1 into register so we can compare without mem to mem error
					.IF  AX < [EBX].test2 && AX < [EBX].test3			;if the value in t1 is greater than t2 and t3
						MOV AX, [EBX].test1								;moves the first test into the smallest spot
					.ELSE												;considering the value in t1 is less than t2 and t3 we can use else
						MOV AX, [EBX].test2								;moves the value of t2 into the register for comparison
						.IF AX < [EBX].test3							;if the value t2 is greater than t3, it is therefore the greatest number	
							MOV AX, [EBX].test2							;moves the test 2 into the smallest spot
						.ELSE											;test3 is the greatest if this gets hit
							MOV AX, [EBX].test3							;move the test score 3 into the smallest spot
						.ENDIF											;end if
					.ENDIF												;ends if
 00000291				ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 00000294  8B 5D 08			RET 4												;returns to where I was called, returning 8 bytes.
				Student_findMin ENDP
 00000297  66| 8B 83		
	   00000194
				COMMENT%
 000002B0  66| 8B 83		******************************************************************************
	   00000194
				*Name: calcAvg                                                               *
 000002B9  66| 8B 83		*Purpose:                                                                    *
	   00000196
				*	  finds the average of the 3 test grades        			             *
 000002C9  66| 8B 83		*                                                                            *
	   00000196
				*Date Created: 11/19/2019                                                    *
 000002D2  66| 8B 83		*Date Modified: 11/19/2019                                                   *
	   00000198
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outAvg:word                                                        *  
				*****************************************************************************%
 000002DA  C2 0004		Student_calcAvg PROC stdcall uses EBX, ths:dword
 000002DD				MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV AX, [EBX].test1									;moves the first test into AX
					MOV DX, [EBX].test2									;moves the second test into DX
					ADD AX, DX											;add the first two tests together
					MOV DX, [EBX].test3									;move the third test into DX
					ADD AX, DX											;all 3 are added together now
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					MOV BL, 3											;we are dividing by 3
					iDIV BL												;divide by 3
					CBW													;converts the byte to word
					RET 4												;returns to where I was called, returning 8 bytes.
				Student_calcAvg ENDP
				
 000002DD			COMMENT%
 000002E1  8B 5D 08		******************************************************************************
				*Name: calcAvg                                                               *
 000002E4  66| 8B 83		*Purpose:                                                                    *
	   00000194
 000002EB  66| 8B 93		*	  sends back a string address containing the students record             *
	   00000196
 000002F2  66| 03 C2		*                                                                            *
 000002F5  66| 8B 93		*Date Created: 11/19/2019                                                    *
	   00000198
 000002FC  66| 03 C2		*Date Modified: 11/19/2019                                                   *
				*                                                                            *
 000002FF  B3 03		*@param ths:dword                                                            *
 00000301  F6 FB		*@returns outAddr:word                                                       *  
 00000303  66| 98		*****************************************************************************%
				Student_studentRecord PROC stdcall uses EBX EDX EDI ESI, ths:dword
 00000307  C2 0004			MOV EBX, ths										;moves the address of the student into ebx
 0000030A				ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 400						;holds enough space to have the record...
					MOV EDI, EAX										;moves the address given back into edi
					INVOKE Student_getName, ths							;gets the name of the student, address is in eax
					MOV EDX, EAX										;stores this address into edx
					INVOKE appendString, EDI, EDX						;appends the name onto the main string
					INVOKE appendString, EDI, addr nextLine				;appends the new line character
					INVOKE Student_getAddress, ths						;gets the address of the student, address is in eax
					MOV EDX, EAX										;moves the address into edx
					INVOKE appendString, EDI, EDX						;appends the address of the student at the end of the main string
					INVOKE appendString, EDI, addr nextLine				;appends the new line character
					INVOKE appendString, EDI, addr nextLine				;appends the new line character
					INVOKE appendString, EDI, addr strTest1				;append the test 1 string
					INVOKE Student_getTest, ths, 1						;get the score for the test
 0000030A				MOV DX, AX											;move the score into dx
 00000311  8B 5D 08			INVOKE memoryallocBailey, 4							;allocate 4 bytes, to hold the asc conversion
					MOV ESI, EAX										;move into esi the address of the 4 byte allocation
					INVOKE intasc32, ESI, DX							;converts the test into ascii
 0000031E  8B F8			INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;appends the space char
 00000328  8B D0			INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strTest2				;append the test 1 string
					INVOKE Student_getTest, ths, 2						;get the score for the test
					MOV DX, AX											;move the score into dx
 00000344  8B D0			INVOKE intasc32, ESI, DX							;converts the test into ascii
					INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;appends the space char
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strTest3				;append the test 1 string
					INVOKE Student_getTest, ths, 3						;get the score for the test
 00000378  66| 8B D0			MOV DX, AX											;move the score into dx
					INVOKE intasc32, ESI, DX							;converts the test into ascii
 00000382  8B F0			INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;appends the space char
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strAverage			;append the average string		
					INVOKE Student_calcAvg, ths							;get the average
					MOV DX, AX											;move the avg into dx
					INVOKE intasc32, ESI, DX							;converts the test into ascii
 000003C0  66| 8B D0			INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strGrade				;append the grade string to the main string
					INVOKE memoryallocBailey, 1							;allocated 1 byte of storage onto the heap
					MOV ESI, EAX										;moves the address of the 1 byte into esi
					INVOKE Student_letterGrade, ths						;gets the letter grade of the student
 000003FF  66| 8B D0			MOV [ESI], AL										;moves into tehe 1 byte storage the letter grade
					INVOKE appendString, EDI, ESI						;appends the letter grade onto the main string
					MOV EAX, EDI										;moves the address of the main string into eax
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, returning 8 bytes.
				Student_studentRecord ENDP
				
 0000043C  66| 8B D0		COMMENT%
				******************************************************************************
				*Name: letterGrade                                                           *
				*Purpose:                                                                    *
				*	  sends back a letter grade corresponding to the average                 *
				*                                                                            *
				*Date Created: 11/19/2019                                                    *
 00000478  8B F0		*Date Modified: 11/19/2019                                                   *
				*                                                                            *
 00000482  88 06		*@param ths:dword                                                            *
				*@returns outASCII:byte                                                      *  
 0000048B  8B C7		*****************************************************************************%
				Student_letterGrade PROC stdcall uses EBX EDX, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
 00000492  C2 0004			ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
 00000495				INVOKE Student_calcAvg, ths							;get the average of the tests
					.IF AX >= 90										;if the average is greater than or equal to 90
						MOV DL, 41h										;move the ASCII A (in hex) into DL
					.ELSEIF AX >= 80									;if it is greater or equal to 80
						MOV DL, 42h										;move the B character in DL
					.ELSEIF AX >= 70									;if it is greater or equal to 70
						MOV DL, 43h										;move the C character in DL
					.ELSEIF AX >= 60									;if it is greater or equal to 60
						MOV DL, 44h										;move the D character in DL
					.ELSE												;if it is not any of the above
						MOV DL, 45h										;move the F character into DL
					.ENDIF												;end if
					MOV AL, DL											;move DL into AL for output
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 00000495				RET 4												;returns to where I was called, returning 8 bytes.
 0000049A  8B 5D 08		Student_letterGrade ENDP
				
				COMMENT%
				******************************************************************************
 000004AB  B2 41		*Name: equals                                                                *
				*Purpose:                                                                    *
 000004B5  B2 42		*	  tests if the students tests are equal, if they are it returns 1        *
				*                                                                            *
 000004BF  B2 43		*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
 000004C9  B2 44		*                                                                            *
				*@param ths:dword                                                            *
 000004CD  B2 45		*@param sc:dword                                                             *
				*@returns outResult:byte                                                     *  
 000004CF  8A C2		*****************************************************************************%
				Student_equals PROC stdcall uses EBX ECX EDX, ths:dword, sc:dword
				MOV ECX, 0
 000004D4  C2 0004		INVOKE Student_getTest, ths, 1
 000004D7			MOV DX, AX
				INVOKE Student_getTest, sc, 1
				.IF AX == DX
					INVOKE Student_getTest, ths, 2
					MOV DX, AX
					INVOKE Student_getTest, sc, 2
					.IF AX == DX
						INVOKE Student_getTest, ths, 3
						MOV DX, AX
						INVOKE Student_getTest, sc, 3
						.IF AX == DX
							MOV CL, 1
						.ELSE
							MOV CL, 0
						.ENDIF
 000004D7				.ELSE
 000004DD  B9 00000000				MOV CL, 0
					.ENDIF
 000004EC  66| 8B D0		.ELSE
					MOV CL, 0
				.ENDIF
				MOV AL, CL
 00000508  66| 8B D0		RET 8
				Student_equals ENDP
				END
 00000524  66| 8B D0
 00000536  B1 01
 0000053A  B1 00
 0000053E  B1 00
 00000542  B1 00
 00000544  8A C1
 0000054A  C2 0008
 0000054D
Microsoft (R) Macro Assembler Version 6.11		    11/20/19 00:28:38
student.asm						     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Student  . . . . . . . . . . . .	 0000019A
  last . . . . . . . . . . . . .	 00000000	 Byte
  first  . . . . . . . . . . . .	 00000064	 Byte
  street . . . . . . . . . . . .	 000000C8	 Byte
  zip  . . . . . . . . . . . . .	 00000190	 DWord
  test1  . . . . . . . . . . . .	 00000194	 Word
  test2  . . . . . . . . . . . .	 00000196	 Word
  test3  . . . . . . . . . . . .	 00000198	 Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000031 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 0000054D DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

Student_1  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000000B Public STDCALL
Student_2  . . . . . . . . . . .	P Near	 0000000B _TEXT	Length= 0000001F Public STDCALL
  firstN . . . . . . . . . . . .	DWord	 bp + 00000008
  lastN  . . . . . . . . . . . .	DWord	 bp + 0000000C
Student_3  . . . . . . . . . . .	P Near	 0000002A _TEXT	Length= 00000007 Public STDCALL
  sc . . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_Street . . . . . . . . .	P Near	 000000CB _TEXT	Length= 00000019 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  streetAddr . . . . . . . . . .	DWord	 bp + 0000000C
Student_calcAvg  . . . . . . . .	P Near	 000002DD _TEXT	Length= 0000002D Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_equals . . . . . . . . .	P Near	 000004D7 _TEXT	Length= 00000076 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  sc . . . . . . . . . . . . . .	DWord	 bp + 0000000C
Student_findMax  . . . . . . . .	P Near	 00000243 _TEXT	Length= 0000004E Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_findMin  . . . . . . . .	P Near	 00000291 _TEXT	Length= 0000004C Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getAddress . . . . . . .	P Near	 00000197 _TEXT	Length= 00000050 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getName  . . . . . . . .	P Near	 00000121 _TEXT	Length= 0000003A Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getStreet  . . . . . . .	P Near	 000001E7 _TEXT	Length= 0000002E Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getTest  . . . . . . . .	P Near	 0000015B _TEXT	Length= 0000003C Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  numTest  . . . . . . . . . . .	Word	 bp + 0000000C
Student_getZip . . . . . . . . .	P Near	 00000215 _TEXT	Length= 0000002E Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_letterGrade  . . . . . .	P Near	 00000495 _TEXT	Length= 00000042 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_setAddr  . . . . . . . .	P Near	 000000FB _TEXT	Length= 00000026 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  inAddr . . . . . . . . . . . .	DWord	 bp + 0000000C
  inZip  . . . . . . . . . . . .	DWord	 bp + 00000010
Student_setName  . . . . . . . .	P Near	 00000031 _TEXT	Length= 00000023 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  addrFirst  . . . . . . . . . .	DWord	 bp + 0000000C
  addrLast . . . . . . . . . . .	DWord	 bp + 00000010
Student_setTestScores  . . . . .	P Near	 00000054 _TEXT	Length= 0000002F Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  t1 . . . . . . . . . . . . . .	Word	 bp + 0000000C
  t2 . . . . . . . . . . . . . .	Word	 bp + 00000010
  t3 . . . . . . . . . . . . . .	Word	 bp + 00000014
Student_setTest  . . . . . . . .	P Near	 00000083 _TEXT	Length= 00000048 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  score  . . . . . . . . . . . .	Word	 bp + 0000000C
  numTest  . . . . . . . . . . .	Word	 bp + 00000010
Student_setZip . . . . . . . . .	P Near	 000000E4 _TEXT	Length= 00000017 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  inZip  . . . . . . . . . . . .	DWord	 bp + 0000000C
Student_studentRecord  . . . . .	P Near	 0000030A _TEXT	Length= 0000018B Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
appendString . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
getBytes . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
memoryallocBailey  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
nextLine . . . . . . . . . . . .	Byte	 00000002 _DATA	
spaceChar  . . . . . . . . . . .	Byte	 00000000 _DATA	
strAverage . . . . . . . . . . .	Byte	 0000001F _DATA	
strGrade . . . . . . . . . . . .	Byte	 00000029 _DATA	
strTest1 . . . . . . . . . . . .	Byte	 00000004 _DATA	
strTest2 . . . . . . . . . . . .	Byte	 0000000D _DATA	
strTest3 . . . . . . . . . . . .	Byte	 00000016 _DATA	

	   0 Warnings
	   0 Errors
