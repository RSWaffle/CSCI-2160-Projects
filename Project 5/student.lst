Microsoft (R) Macro Assembler Version 6.11		    11/20/19 01:50:34
student.asm						     Page 1 - 1


				;******************************************************************************************
				;*  Program Name: Student.asm
				;*  Programmer:   Ryan Shupe
				;*  Class:        CSCI 2160-001
				;*  Lab:		  Proj 5
				;*  Date:         Created 11/23/2019
				;*  Purpose:      create a student class that can hold different attrubutes about a student
				;*				   and create setters and getters
				;******************************************************************************************
					.486						;This tells assembler to generate 32-bit code
					.model flat					;This tells assembler that all addresses are real addresses
					.stack 100h					;EVERY program needs to have a stack allocated
				;******************************************************************************************
				memoryallocBailey PROTO Near32 stdcall, dSize:DWORD
				appendString	  PROTO Near32 stdcall, lpDestination:dword, lpSource:dword
				intasc32 proto Near32 stdcall, lpStringToHold:dword, dval:dword
				Student_setName PROTO stdcall, ths:dword, addrFirst:dword, addrLast:dword
				Student_getZip PROTO stdcall, ths:dword
				Student_getName PROTO stdcall, ths:dword
				Student_getStreet PROTO stdcall, ths:dword
				getBytes PROTO stdcall, String1:dword
				Student_calcAvg PROTO stdcall, ths:dword
				Student_letterGrade PROTO stdcall, ths:dword
				Student_setTest PROTO stdcall, ths:dword, score:word, numTest:word
				Student_getTest PROTO stdcall, ths:dword, numTest:word
				Student_setStreet PROTO stdcall, ths:dword, streetAddr:dword
				Student_setZip PROTO stdcall, ths:dword, inZip:dword
				;******************************************************************************************	
 0000019A			Student STRUCT 
 00000000  00000064 [			last byte 100 dup(0)							;space to hold the last name of the student
	    00
	   ]
 00000064  00000064 [			first byte 100 dup(0)							;space to hold the first name of the student
	    00
	   ]
 000000C8  000000C8 [			street byte 200 dup(0)							;space to hold the street address
	    00
	   ]
 00000190  00000000			zip dword ?										;space to hold the zip
 00000194  0000				test1 word ?									;word to hold the test score 1
 00000196  0000				test2 word ?									;word to hold the test score 2
 00000198  0000				test3 word ? 									;word to hold the test score 3
				Student ENDS
				;******************************************************************************************
 00000000			.DATA
 00000000 20 00			spaceChar byte 32,0									;memory to hold the space char
 00000002 0A 00			nextLine byte 10,0									;memory to store the next line char
 00000004 00000000		tempAddr dword ?									;memory to hold an address
 00000008 00000000		tempVar dword ?										;memory to hold a dword
				
 0000000C 54 65 73 74 20	strTest1 byte "Test 1: ", 0
	   31 3A 20 00
 00000015 54 65 73 74 20	strTest2 byte "Test 2: ", 0
	   32 3A 20 00
 0000001E 54 65 73 74 20	strTest3 byte "Test 3: ", 0
	   33 3A 20 00
 00000027 41 76 65 72 61	strAverage byte "Average: ", 0
	   67 65 3A 20 00
 00000031 47 72 61 64 65	strGrade byte "Grade: ", 0
	   3A 20 00
				;******************************************************************************************
 00000000			.CODE
				
				COMMENT%
				******************************************************************************
				*Name: Student_1                                                             *
				*Purpose:                                                                    *
				*	  Creates a student object with dynamic memory allocated                 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*****************************************************************************%
 00000000			Student_1 PROC stdcall
					INVOKE memoryallocBailey, sizeof Student 			;allocates memory onto the heap the required amount for a student struct
 0000000A  C3				RET													;returns where I was called, address in EAX
 0000000B			Student_1 endp
				
				COMMENT%
				******************************************************************************
				*Name: Student_2                                                             *
				*Purpose:                                                                    *
				*	  Creates a student object with enough memory allocated, with a name set *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param addrFirst:dword                                                      *
				*@param addrLast:dword                                                       *
				*****************************************************************************%
 0000000B			Student_2 PROC stdcall, firstN:dword, lastN:dword
					INVOKE memoryallocBailey, sizeof Student			;allocate enough memory to hold a student
 00000018  50				PUSH EAX											;store the address it gives
					INVOKE Student_setName, EAX, firstN, lastN			;set the name of the student
 00000025  58				POP EAX												;restore our pushed address of the student
					RET 8												;return back to where i was called cleaning 8 bytes, address in EAX
 00000027  C2 0008		Student_2 ENDP
 0000002A			
				COMMENT%
				******************************************************************************
				*Name: Student_3                                                             *
				*Purpose:                                                                    *
				*	  Creates a student object with enough memory allocated, also intakes    *
				*      another student and copies from it and fills the new student.		 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param sc:dword                                         		             *
				*****************************************************************************%
				Student_3 PROC stdcall uses EBX EDX EDI, sc:dword
 0000002A				INVOKE memoryallocBailey, sizeof Student			;allocate enough memory to hold a student
					MOV tempAddr, EAX									;preserves address to the student
 0000003A  A3 00000004 R		MOV EBX, EAX										;move the allocated address into ebx
 0000003F  8B D8			ASSUME EBX:PTR Student								;assume ebx is a student
					MOV EDX, sc											;move into edx the address of the copy student
 00000041  8B 55 08			ASSUME EDX:PTR Student								;let edx point to a student
					INVOKE Student_setName, EBX, addr [EDX].first, 		;sets the name of the student to the name of the one we are making a copy of
					addr [EDX].last
					INVOKE Student_getZip, EDX							;gets the zip of the copy student
					MOV tempVar, EAX									;moves the zip into the temp var
 00000057  A3 00000008 R		INVOKE Student_setZip, EBX, addr tempVar			;sets the zip of the new student
					INVOKE Student_getStreet, EDX						;gets the street of the copy student
					INVOKE Student_setStreet, EBX, EAX					;sets the street of the new student
					INVOKE Student_getTest, EDX, 1						;get the first test of the copy student into ax
					INVOKE Student_setTest, EBX, AX, 1					;place the first test score into the new students test
					INVOKE Student_getTest, EDX, 2						;get the second test of the copy student into ax
					INVOKE Student_setTest, EBX, AX, 2					;place the second test score into the new students test
					INVOKE Student_getTest, EDX, 3						;get the third test of the copy student into ax
					INVOKE Student_setTest, EBX, AX, 3					;place the third test score into the new students test
					ASSUME EDX:PTR nothing								;edx doesnt point to a student anymore
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					MOV EAX, tempAddr									;restores address to the student
 000000B3  A1 00000004 R		RET 4												;returns back to where I was called with 4 bytes, address in eax.
				Student_3 ENDP
 000000BC  C2 0004		
 000000BF			COMMENT%
				******************************************************************************
				*Name: setName                                                               *
				*Purpose:                                                                    *
				*	  Intakes a student first and last name and stores it onto the heap address*
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param addrFirst:dword                                                      *
				*@param addrLast:dword                                                       *
				*****************************************************************************%
				Student_setName PROC stdcall uses EBX, ths:dword, addrFirst:dword, addrLast:dword
					MOV EBX, ths										;moves the address of the student into ebx.
 000000BF				ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
 000000C3  8B 5D 08			INVOKE appendString, addr [EBX].first, addrFirst	;appends the first name string sent in onto the correct memory location	
					INVOKE appendString, addr [EBX].last, addrLast		;appends the last name string sent in ontto the correct memory location	
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 12												;return to where I was called, cleaning 12 bytes.
				Student_setName ENDP
				
 000000DF  C2 000C		COMMENT%
 000000E2			******************************************************************************
				*Name: setTestScores                                                         *
				*Purpose:                                                                    *
				*	  Intakes a student and test scores and stores them in the appropriate   *
				*			memory location 												 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param t1:word                                                              *
				*@param t2:word                                                              *
				*@param t3:word                                                              *
				*****************************************************************************%
				Student_setTestScores PROC stdcall uses ebx edx, ths:dword, t1:word, t2:word, t3:word
					MOV EBX, ths										;moves the address of the student into ebx.
					ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
 000000E2				MOV DX, t1											;moves the first test into dx
 000000E7  8B 5D 08			MOV [EBX].test1, DX									;moves the word into the memory location where test 1 is 
					MOV DX, t2											;moves the first test into dx
 000000EA  66| 8B 55 0C			MOV [EBX].test2, DX									;moves the word into the memory location where test 1 is 
 000000EE  66| 89 93			MOV DX, t3											;moves the first test into dx
	   00000194
 000000F5  66| 8B 55 10			MOV [EBX].test3, DX									;moves the word into the memory location where test 1 is 
 000000F9  66| 89 93			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
	   00000196
 00000100  66| 8B 55 14			RET 10												;return to where I was called, cleaning 12 bytes.
 00000104  66| 89 93		Student_setTestScores ENDP
	   00000198
				
				COMMENT%
 0000010E  C2 000A		******************************************************************************
 00000111			*Name: setTest                                                               *
				*Purpose:                                                                    *
				*	  Intakes a student and test scores and stores them in the appropriate   *
				*			memory location 												 *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param score:word                                                           *
				*@param testNum:word                                                         *
				*****************************************************************************%
				Student_setTest PROC stdcall uses EBX EDX, ths:dword, score:word, numTest:word
					MOV EBX, ths										;moves the address of the student into ebx.
					ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
					.IF numTest == 1									;if the in test num is equal to 1
 00000111					MOV DX, score									;moves the first test into dx
 00000116  8B 5D 08				TEST DX, DX										;test dx with itself to set flags
						.IF SIGN?										;tests to see if the test score is negative
						.ELSE											;if it is not
 00000120  66| 8B 55 0C					.IF DX <= 100								;checks to see if it is less than 100
 00000124  66| 85 D2						MOV [EBX].test1, DX						;moves the word into the memory location where test 1 is 
							.ENDIF										;end if
						.ENDIF											;endif
					.ELSEIF numTest == 2								;if the in test num is equal to 2
 00000131  66| 89 93				MOV DX, score									;moves the first test into dx
	   00000194
								TEST DX, DX								;test dx with itself to set flags
						.IF SIGN?										;tests to see if the test score is negative
						.ELSE											;if it is not
 00000141  66| 8B 55 0C					.IF DX <= 100								;checks to see if it is less than 100
 00000145  66| 85 D2						MOV [EBX].test2, DX						;moves the word into the memory location where test 1 is 
							.ENDIF										;end if
						.ENDIF											;endif
					.ELSEIF numTest == 3								;if the in test num is equal to 3
 00000152  66| 89 93				MOV DX, score									;moves the first test into dx
	   00000196
						TEST DX, DX										;test dx with itself to set flags
						.IF SIGN?										;tests to see if the test score is negative
						.ELSE											;if it is not
 00000162  66| 8B 55 0C					.IF DX <= 100								;checks to see if it is less than 100
 00000166  66| 85 D2						MOV [EBX].test3, DX						;moves the word into the memory location where test 1 is 
							.ENDIF										;end if
						.ENDIF											;endif 
					.ELSE												;if the test number is not 1-3
 00000173  66| 89 93																;if this was java i would throw an exception here
	   00000198
					.ENDIF												;end if
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 8												;return to where i was called from and cleaning 8 bytes
				Student_setTest ENDP
				
				COMMENT%
				******************************************************************************
 0000017F  C2 0008		*Name: setStreet                                                             *
 00000182			*Purpose:                                                                    *
				*	  Intakes a student and a street and copies the street onto the memory   *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param streetAddr:dword                                                     *
				*****************************************************************************%
				Student_setStreet PROC stdcall uses EBX EDX, ths:dword, streetAddr:dword
					MOV EBX, ths										;moves the address of the student into ebx.
					ASSUME EBX:PTR Student								;assumes that ebx is a student pointer so we dont have to type that every line
					MOV EDX, streetAddr									;moves the address into EDX
					MOV AL, byte ptr[EDX]								;moves the first byte into al
 00000182				.IF AL == 0											;if it is null
 00000187  8B 5D 08			.ELSE												;if it is not
						INVOKE appendString, addr [EBX].street, streetAddr;appends the street in into the location it should go onto the heap
 0000018A  8B 55 0C			.ENDIF												;end if
 0000018D  8A 02			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 8												;return to where i was called from and cleaning 8 bytes
				Student_setStreet ENDP
				
				COMMENT%
				******************************************************************************
				*Name: setZip                                                                *
 000001A7  C2 0008		*Purpose:                                                                    *
 000001AA			*	  Intakes a student and a dword zip code, then places the zip in, into   *
				*     the student's zip                                                      *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param inZip:dword                                                          *
				*****************************************************************************%
				Student_setZip PROC stdcall uses EBX EDX, ths:dword, inZip:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:ptr Student								;assumes ebx is a student pointer so we dont have to type it 
					MOV EDX, inZip										;moves the zip parameter into a register, cant do mem to mem
					MOV AL, byte ptr[EDX]								;moves the first byte into al
					.IF AL == 0											;if it is null
 000001AA				.ELSE												;if it is not
 000001AF  8B 5D 08				MOV [EBX].zip, EDX								;moves the zip sent into the method into the zip in student 
					.ENDIF												;end if
 000001B2  8B 55 0C			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 000001B5  8A 02			RET 8												;returns to where I was called cleaning 8 bytes. 
				Student_setZip ENDP
				
 000001BD  89 93 00000190	COMMENT%
				******************************************************************************
				*Name: setAddr                                                               *
				*Purpose:                                                                    *
 000001C6  C2 0008		*	  Intakes a student and a dword address to an address, then places the   *
 000001C9			*		address in, into the student's address              				 *
				*                                                                            *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param inAddr:dword                                                         *
				*****************************************************************************%
				Student_setAddr PROC stdcall uses EBX EDX, ths:dword, inAddr:dword, inZip:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE Student_setStreet, ths, inAddr				;sets the street to the student
					INVOKE Student_setZip, ths, inZip					;sets the zip of the student
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 8												;returns to where I was called, cleaning 8 bytes.
 000001C9			Student_setAddr ENDP
 000001CE  8B 5D 08		
				COMMENT%
				******************************************************************************
				*Name: getName                                                               *
				*Purpose:                                                                    *
				*	  Intakes a student and returns the address of where the name is 		 *
 000001EA  C2 0008		*			( new generated string on the heap)                              *
 000001ED			*                                                                            *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getName PROC stdcall uses EBX EDX, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 200						;allocate 200 bytes of memory (enough for a big name)
					MOV EDX, EAX										;moves the address of the heap onto edx so we can invoke it
					INVOKE appendString, EDX, addr [EBX].first			;appends the first name at the address
					INVOKE appendString, EDX, addr spaceChar			;appends a space character onto the address
					INVOKE appendString, EDX, addr [EBX].last			;appends the last name onto the address
 000001ED				MOV EAX, EDX										;moves the address of the name into eax for returning
 000001F2  8B 5D 08			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, cleaning 8 bytes.
				Student_getName ENDP
 000001FF  8B D0		
				COMMENT%
				******************************************************************************
				*Name: getTest                                                               *
 0000021F  8B C2		*Purpose:                                                                    *
				*	  Intakes a student and test number and retuns the test grade            *
				*                                                                            *
 00000224  C2 0004		*Date Created: 11/19/2019                                                    *
 00000227			*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@param numTest:word                                                         *
				*@returns testScore:word                                                     *  
				*****************************************************************************%
				Student_getTest PROC stdcall uses EBX, ths:dword, numTest:word
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					.IF numTest == 1									;if the in test num is equal to 1
						MOV AX, [EBX].test1								;moves the score from the test into AX
					.ELSEIF numTest == 2								;if the in test num is equal to 2
						MOV AX, [EBX].test2								;moves the score from the test into AX	
					.ELSEIF numTest == 3								;if the in test num is equal to 3
						MOV AX, [EBX].test3								;moves the score from the test into AX
 00000227				.ELSE												;if the test number is not 1-3
 0000022B  8B 5D 08			.ENDIF												;if this was java i would throw an exception at the else
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 6												;returns to where I was called, cleaning 8 bytes.
 00000235  66| 8B 83		Student_getTest ENDP
	   00000194
				
 00000245  66| 8B 83		
	   00000196
				COMMENT%
 00000255  66| 8B 83		******************************************************************************
	   00000198
				*Name: getAddress                                                            *
				*Purpose:                                                                    *
				*	  Intakes a student and returns the street + zip 			             *
				*                                                                            *
 00000260  C2 0006		*Date Created: 11/19/2019                                                    *
 00000263			*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getAddress PROC stdcall uses ECX EDX EDI, ths:dword 
					MOV EDX, 0
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 205						;allocates enough memory for a complete address
					MOV EDI, EAX										;moves into edi the address given back from the allocation
					INVOKE Student_getStreet, ths						;gets the street from the current student passed in
					MOV EDX, EAX										;moves into EDX, the returning street address in EAX
					INVOKE appendString, EDI, EDX						;appends the street to the blank allocated memory
					INVOKE appendString, EDI, addr spaceChar			;appends a space character onto the address
 00000263				INVOKE Student_getZip, ths							;gets the current zip from the student and address is in eax
 00000269  BA 00000000			.IF EAX == -1										;if the zip is null
 0000026E  8B 5D 08			.ELSE												;if it is not
						MOV EDX, EAX									;moves the numbers of the zip into eax
						INVOKE memoryallocBailey, 5						;allocates enough memory for a complete address
 0000027B  8B F8				INVOKE intasc32, EAX, EDX						;converts the zip to ascii
						MOV EDX, EAX									;moves the addr of the zip into eax
 00000285  8B D0				INVOKE appendString, EDI, EDX					;appends the zip at the end of the current string allocated (the street and the space to seperate)
					.ENDIF												;endif
					MOV EAX, EDI										;moves the address of the address into eax for returning
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, cleaning 8 bytes.
				Student_getAddress ENDP
 000002A8  8B D0		
				COMMENT%
				******************************************************************************
 000002B8  8B D0		*Name: getStreet                                                             *
				*Purpose:                                                                    *
				*	  Intakes a student and returns the street      			             *
 000002C1  8B C7		*                                                                            *
				*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
 000002C7  C2 0004		*                                                                            *
 000002CA			*@param ths:dword                                                            *
				*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getStreet PROC stdcall uses ebx edx, ths:dword
					MOV EDX, 0											;clear our edx
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 200						;allocate 205 bytes of memory (enough for a street and 5 digit zip)
					MOV EDX, EAX										;moves the address of the heap onto edx so we can invoke it
					INVOKE appendString, EDX, addr [EBX].street			;appends the street at the address
					MOV EAX, EDX										;moves the address of the address into eax for returning
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, cleaning 8 bytes.
				Student_getStreet ENDP
 000002CA			
 000002CF  BA 00000000		COMMENT%
 000002D4  8B 5D 08		******************************************************************************
				*Name: getStreet                                                             *
				*Purpose:                                                                    *
 000002E1  8B D0		*	  Intakes a student and returns the street      			             *
				*                                                                            *
 000002F0  8B C2		*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
 000002F5  C2 0004		*@param ths:dword                                                            *
 000002F8			*@returns outAddr:dword                                                      *  
				*****************************************************************************%
				Student_getZip PROC stdcall uses ebx edx, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV EAX, [EBX].zip									;moves the address of the zip into EAX
					.IF EAX == 00										;if zip is null
						MOV EAX, -1										;move -1 into eax
					.ELSE												;if it is not
						MOV EDX, [EAX]									;moves the value at eax into edx
						MOV EAX, EDX									;moves back to eax for output
					.ENDIF												;end if
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, cleaning 8 bytes.
 000002F8			Student_getZip ENDP
 000002FD  8B 5D 08		
				COMMENT%
 00000300  8B 83 00000190	******************************************************************************
				*Name: findMax                                                               *
 0000030A  B8 FFFFFFFF		*Purpose:                                                                    *
				*	  finds the max test grade of the student        			             *
 00000311  8B 10		*                                                                            *
 00000313  8B C2		*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
 00000318  C2 0004		*@returns outTest:word                                                       *  
 0000031B			*****************************************************************************%
				Student_findMax PROC stdcall uses EBX , ths:dword										
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV AX, [EBX].test1									;moves the value in t1 into register so we can compare without mem to mem error
					.IF  AX > [EBX].test2 && AX > [EBX].test3			;if the value in t1 is greater than t2 and t3
						MOV AX, [EBX].test1								;moves the first test into the largest spot
					.ELSE												;considering the value in t1 is less than t2 and t3 we can use else
						MOV AX, [EBX].test2								;moves the value of t2 into the register for comparison
						.IF AX > [EBX].test3							;if the value t2 is greater than t3, it is therefore the greatest number	
							MOV AX, [EBX].test2							;moves the test 2 into the largest spot
						.ELSE											;test3 is the greatest if this gets hit
							MOV AX, [EBX].test3							;move the test score 3 into the largest spot
						.ENDIF											;end if
 0000031B				.ENDIF												;ends if
 0000031F  8B 5D 08			ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, cleaning 8 bytes.
 00000322  66| 8B 83		Student_findMax ENDP
	   00000194
				
 0000033B  66| 8B 83		COMMENT%
	   00000194
				******************************************************************************
 00000344  66| 8B 83		*Name: findMin                                                               *
	   00000196
				*Purpose:                                                                    *
 00000354  66| 8B 83		*	  finds the min test grade of the student        			             *
	   00000196
				*                                                                            *
 0000035D  66| 8B 83		*Date Created: 11/19/2019                                                    *
	   00000198
				*Date Modified: 11/19/2019                                                   *
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outTest:word                                                       *  
 00000366  C2 0004		*****************************************************************************%
 00000369			Student_findMin PROC stdcall, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV AX, [EBX].test1									;moves the value in t1 into register so we can compare without mem to mem error
					.IF  AX < [EBX].test2 && AX < [EBX].test3			;if the value in t1 is greater than t2 and t3
						MOV AX, [EBX].test1								;moves the first test into the smallest spot
					.ELSE												;considering the value in t1 is less than t2 and t3 we can use else
						MOV AX, [EBX].test2								;moves the value of t2 into the register for comparison
						.IF AX < [EBX].test3							;if the value t2 is greater than t3, it is therefore the greatest number	
							MOV AX, [EBX].test2							;moves the test 2 into the smallest spot
						.ELSE											;test3 is the greatest if this gets hit
							MOV AX, [EBX].test3							;move the test score 3 into the smallest spot
						.ENDIF											;end if
					.ENDIF												;ends if
 00000369				ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 0000036C  8B 5D 08			RET 4												;returns to where I was called, cleaning 8 bytes.
				Student_findMin ENDP
 0000036F  66| 8B 83		
	   00000194
				COMMENT%
 00000388  66| 8B 83		******************************************************************************
	   00000194
				*Name: calcAvg                                                               *
 00000391  66| 8B 83		*Purpose:                                                                    *
	   00000196
				*	  finds the average of the 3 test grades        			             *
 000003A1  66| 8B 83		*                                                                            *
	   00000196
				*Date Created: 11/19/2019                                                    *
 000003AA  66| 8B 83		*Date Modified: 11/19/2019                                                   *
	   00000198
				*                                                                            *
				*@param ths:dword                                                            *
				*@returns outAvg:word                                                        *  
				*****************************************************************************%
 000003B2  C2 0004		Student_calcAvg PROC stdcall uses EBX, ths:dword
 000003B5				MOV EBX, ths										;moves the address of the student into ebx
					ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					MOV AX, [EBX].test1									;moves the first test into AX
					MOV DX, [EBX].test2									;moves the second test into DX
					ADD AX, DX											;add the first two tests together
					MOV DX, [EBX].test3									;move the third test into DX
					ADD AX, DX											;all 3 are added together now
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					MOV BL, 3											;we are dividing by 3
					iDIV BL												;divide by 3
					CBW													;converts the byte to word
					RET 4												;returns to where I was called, cleaning 8 bytes.
				Student_calcAvg ENDP
				
 000003B5			COMMENT%
 000003B9  8B 5D 08		******************************************************************************
				*Name: calcAvg                                                               *
 000003BC  66| 8B 83		*Purpose:                                                                    *
	   00000194
 000003C3  66| 8B 93		*	  sends back a string address containing the students record             *
	   00000196
 000003CA  66| 03 C2		*                                                                            *
 000003CD  66| 8B 93		*Date Created: 11/19/2019                                                    *
	   00000198
 000003D4  66| 03 C2		*Date Modified: 11/19/2019                                                   *
				*                                                                            *
 000003D7  B3 03		*@param ths:dword                                                            *
 000003D9  F6 FB		*@returns outAddr:word                                                       *  
 000003DB  66| 98		*****************************************************************************%
				Student_studentRecord PROC stdcall uses EBX EDX EDI ESI, ths:dword
 000003DF  C2 0004			MOV EBX, ths										;moves the address of the student into ebx
 000003E2				ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
					INVOKE memoryallocBailey, 400						;holds enough space to have the record...
					MOV EDI, EAX										;moves the address given back into edi
					INVOKE Student_getName, ths							;gets the name of the student, address is in eax
					MOV EDX, EAX										;stores this address into edx
					INVOKE appendString, EDI, EDX						;appends the name onto the main string
					INVOKE appendString, EDI, addr nextLine				;appends the new line character
					INVOKE Student_getAddress, ths						;gets the address of the student, address is in eax
					MOV EDX, EAX										;moves the address into edx
					INVOKE appendString, EDI, EDX						;appends the address of the student at the end of the main string
					INVOKE appendString, EDI, addr nextLine				;appends the new line character
					INVOKE appendString, EDI, addr nextLine				;appends the new line character
					INVOKE appendString, EDI, addr strTest1				;append the test 1 string
					INVOKE Student_getTest, ths, 1						;get the score for the test
 000003E2				MOV DX, AX											;move the score into dx
 000003E9  8B 5D 08			INVOKE memoryallocBailey, 4							;allocate 4 bytes, to hold the asc conversion
					MOV ESI, EAX										;move into esi the address of the 4 byte allocation
					INVOKE intasc32, ESI, DX							;converts the test into ascii
 000003F6  8B F8			INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;appends the space char
 00000400  8B D0			INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strTest2				;append the test 1 string
					INVOKE Student_getTest, ths, 2						;get the score for the test
					MOV DX, AX											;move the score into dx
 0000041C  8B D0			INVOKE intasc32, ESI, DX							;converts the test into ascii
					INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;appends the space char
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strTest3				;append the test 1 string
					INVOKE Student_getTest, ths, 3						;get the score for the test
 00000450  66| 8B D0			MOV DX, AX											;move the score into dx
					INVOKE intasc32, ESI, DX							;converts the test into ascii
 0000045A  8B F0			INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;appends the space char
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strAverage			;append the average string		
					INVOKE Student_calcAvg, ths							;get the average
					MOV DX, AX											;move the avg into dx
					INVOKE intasc32, ESI, DX							;converts the test into ascii
 00000498  66| 8B D0			INVOKE appendString, EDI, ESI						;appends the test at the end of the main string
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr spaceChar			;append the space character
					INVOKE appendString, EDI, addr strGrade				;append the grade string to the main string
					INVOKE memoryallocBailey, 1							;allocated 1 byte of storage onto the heap
					MOV ESI, EAX										;moves the address of the 1 byte into esi
					INVOKE Student_letterGrade, ths						;gets the letter grade of the student
 000004D7  66| 8B D0			MOV [ESI], AL										;moves into tehe 1 byte storage the letter grade
					INVOKE appendString, EDI, ESI						;appends the letter grade onto the main string
					MOV EAX, EDI										;moves the address of the main string into eax
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
					RET 4												;returns to where I was called, cleaning 8 bytes.
				Student_studentRecord ENDP
				
 00000514  66| 8B D0		COMMENT%
				******************************************************************************
				*Name: letterGrade                                                           *
				*Purpose:                                                                    *
				*	  sends back a letter grade corresponding to the average                 *
				*                                                                            *
				*Date Created: 11/19/2019                                                    *
 00000550  8B F0		*Date Modified: 11/19/2019                                                   *
				*                                                                            *
 0000055A  88 06		*@param ths:dword                                                            *
				*@returns outASCII:byte                                                      *  
 00000563  8B C7		*****************************************************************************%
				Student_letterGrade PROC stdcall uses EBX EDX, ths:dword
					MOV EBX, ths										;moves the address of the student into ebx
 0000056A  C2 0004			ASSUME EBX:PTR Student								;assumes ebx is a student so we dont have to type it later
 0000056D				INVOKE Student_calcAvg, ths							;get the average of the tests
					.IF AX >= 90										;if the average is greater than or equal to 90
						MOV DL, 41h										;move the ASCII A (in hex) into DL
					.ELSEIF AX >= 80									;if it is greater or equal to 80
						MOV DL, 42h										;move the B character in DL
					.ELSEIF AX >= 70									;if it is greater or equal to 70
						MOV DL, 43h										;move the C character in DL
					.ELSEIF AX >= 60									;if it is greater or equal to 60
						MOV DL, 44h										;move the D character in DL
					.ELSE												;if it is not any of the above
						MOV DL, 45h										;move the F character into DL
					.ENDIF												;end if
					MOV AL, DL											;move DL into AL for output
					ASSUME EBX:ptr nothing								;ebx does not point to a student anymore
 0000056D				RET 4												;returns to where I was called, cleaning 8 bytes.
 00000572  8B 5D 08		Student_letterGrade ENDP
				
				COMMENT%
				******************************************************************************
 00000583  B2 41		*Name: equals                                                                *
				*Purpose:                                                                    *
 0000058D  B2 42		*	  tests if the students tests are equal, if they are it returns 1        *
				*                                                                            *
 00000597  B2 43		*Date Created: 11/19/2019                                                    *
				*Date Modified: 11/19/2019                                                   *
 000005A1  B2 44		*                                                                            *
				*@param ths:dword                                                            *
 000005A5  B2 45		*@param sc:dword                                                             *
				*@returns outResult:byte                                                     *  
 000005A7  8A C2		*****************************************************************************%
				Student_equals PROC stdcall uses EBX ECX EDX, ths:dword, sc:dword
				MOV ECX, 0												;moves 0 into ecx, to initialize
 000005AC  C2 0004		INVOKE Student_getTest, ths, 1							;get the first students test score
 000005AF			MOV DX, AX												;move the test score into edx
				INVOKE Student_getTest, sc, 1							;get the second students test score
				.IF AX == DX											;compare the two to see if they are equal
					INVOKE Student_getTest, ths, 2						;get the first students test score
					MOV DX, AX											;move the test score into edx
					INVOKE Student_getTest, sc, 2						;get the second students test score
					.IF AX == DX										;compare the two to see if they are equal
					INVOKE Student_getTest, ths, 3						;get the first students test score
					MOV DX, AX											;move the test score into edx
					INVOKE Student_getTest, sc, 3						;get the second students test score
						.IF AX == DX									;compare the two to see if they are equal
							MOV CL, 1									;if they are then the students test scores are equal
						.ELSE											;if not
							MOV CL, 0									;move 0 into cl if they are not equal
						.ENDIF											;end if
 000005AF				.ELSE												;if not
 000005B5  B9 00000000				MOV CL, 0										;move 0 into cl they are not equal
					.ENDIF												;end if
 000005C4  66| 8B D0		.ELSE													;if not
					MOV CL, 0											;move 0 into cl they are not equal
				.ENDIF													;end if
				MOV AL, CL												;move the cl into al for standard output
 000005E0  66| 8B D0		RET 8													;return to where i was called cleaning 8 bytes
				Student_equals ENDP
				END
 000005FC  66| 8B D0
 0000060E  B1 01
 00000612  B1 00
 00000616  B1 00
 0000061A  B1 00
 0000061C  8A C1
 00000622  C2 0008
 00000625
Microsoft (R) Macro Assembler Version 6.11		    11/20/19 01:50:34
student.asm						     Symbols 2 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

Student  . . . . . . . . . . . .	 0000019A
  last . . . . . . . . . . . . .	 00000000	 Byte
  first  . . . . . . . . . . . .	 00000064	 Byte
  street . . . . . . . . . . . .	 000000C8	 Byte
  zip  . . . . . . . . . . . . .	 00000190	 DWord
  test1  . . . . . . . . . . . .	 00000194	 Word
  test2  . . . . . . . . . . . .	 00000196	 Word
  test3  . . . . . . . . . . . .	 00000198	 Word


Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

FLAT . . . . . . . . . . . . . .	GROUP
STACK  . . . . . . . . . . . . .	32 Bit	 00000100 DWord	  Stack	  'STACK'	 
_DATA  . . . . . . . . . . . . .	32 Bit	 00000039 DWord	  Public  'DATA'	
_TEXT  . . . . . . . . . . . . .	32 Bit	 00000625 DWord	  Public  'CODE'	


Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

Student_1  . . . . . . . . . . .	P Near	 00000000 _TEXT	Length= 0000000B Public STDCALL
Student_2  . . . . . . . . . . .	P Near	 0000000B _TEXT	Length= 0000001F Public STDCALL
  firstN . . . . . . . . . . . .	DWord	 bp + 00000008
  lastN  . . . . . . . . . . . .	DWord	 bp + 0000000C
Student_3  . . . . . . . . . . .	P Near	 0000002A _TEXT	Length= 00000095 Public STDCALL
  sc . . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_calcAvg  . . . . . . . .	P Near	 000003B5 _TEXT	Length= 0000002D Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_equals . . . . . . . . .	P Near	 000005AF _TEXT	Length= 00000076 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  sc . . . . . . . . . . . . . .	DWord	 bp + 0000000C
Student_findMax  . . . . . . . .	P Near	 0000031B _TEXT	Length= 0000004E Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_findMin  . . . . . . . .	P Near	 00000369 _TEXT	Length= 0000004C Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getAddress . . . . . . .	P Near	 00000263 _TEXT	Length= 00000067 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getName  . . . . . . . .	P Near	 000001ED _TEXT	Length= 0000003A Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getStreet  . . . . . . .	P Near	 000002CA _TEXT	Length= 0000002E Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_getTest  . . . . . . . .	P Near	 00000227 _TEXT	Length= 0000003C Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  numTest  . . . . . . . . . . .	Word	 bp + 0000000C
Student_getZip . . . . . . . . .	P Near	 000002F8 _TEXT	Length= 00000023 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_letterGrade  . . . . . .	P Near	 0000056D _TEXT	Length= 00000042 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
Student_setAddr  . . . . . . . .	P Near	 000001C9 _TEXT	Length= 00000024 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  inAddr . . . . . . . . . . . .	DWord	 bp + 0000000C
  inZip  . . . . . . . . . . . .	DWord	 bp + 00000010
Student_setName  . . . . . . . .	P Near	 000000BF _TEXT	Length= 00000023 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  addrFirst  . . . . . . . . . .	DWord	 bp + 0000000C
  addrLast . . . . . . . . . . .	DWord	 bp + 00000010
Student_setStreet  . . . . . . .	P Near	 00000182 _TEXT	Length= 00000028 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  streetAddr . . . . . . . . . .	DWord	 bp + 0000000C
Student_setTestScores  . . . . .	P Near	 000000E2 _TEXT	Length= 0000002F Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  t1 . . . . . . . . . . . . . .	Word	 bp + 0000000C
  t2 . . . . . . . . . . . . . .	Word	 bp + 00000010
  t3 . . . . . . . . . . . . . .	Word	 bp + 00000014
Student_setTest  . . . . . . . .	P Near	 00000111 _TEXT	Length= 000000C6 Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  score  . . . . . . . . . . . .	Word	 bp + 0000000C
  numTest  . . . . . . . . . . .	Word	 bp + 00000010
Student_setZip . . . . . . . . .	P Near	 000001AA _TEXT	Length= 0000001F Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
  inZip  . . . . . . . . . . . .	DWord	 bp + 0000000C
Student_studentRecord  . . . . .	P Near	 000003E2 _TEXT	Length= 0000018B Public STDCALL
  ths  . . . . . . . . . . . . .	DWord	 bp + 00000008
appendString . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
getBytes . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
intasc32 . . . . . . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL
memoryallocBailey  . . . . . . .	P Near	 00000000 FLAT	Length= 00000000 External STDCALL


Symbols:

                N a m e                 Type     Value    Attr

@CodeSize  . . . . . . . . . . .	Number	 00000000h   
@DataSize  . . . . . . . . . . .	Number	 00000000h   
@Interface . . . . . . . . . . .	Number	 00000000h   
@Model . . . . . . . . . . . . .	Number	 00000007h   
@code  . . . . . . . . . . . . .	Text   	 _TEXT
@data  . . . . . . . . . . . . .	Text   	 FLAT
@fardata?  . . . . . . . . . . .	Text   	 FLAT
@fardata . . . . . . . . . . . .	Text   	 FLAT
@stack . . . . . . . . . . . . .	Text   	 FLAT
nextLine . . . . . . . . . . . .	Byte	 00000002 _DATA	
spaceChar  . . . . . . . . . . .	Byte	 00000000 _DATA	
strAverage . . . . . . . . . . .	Byte	 00000027 _DATA	
strGrade . . . . . . . . . . . .	Byte	 00000031 _DATA	
strTest1 . . . . . . . . . . . .	Byte	 0000000C _DATA	
strTest2 . . . . . . . . . . . .	Byte	 00000015 _DATA	
strTest3 . . . . . . . . . . . .	Byte	 0000001E _DATA	
tempAddr . . . . . . . . . . . .	DWord	 00000004 _DATA	
tempVar  . . . . . . . . . . . .	DWord	 00000008 _DATA	

	   0 Warnings
	   0 Errors
